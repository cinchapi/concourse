/*
 * Copyright (c) 2013-2021 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.cinchapi.concourse.server.storage;

import java.util.AbstractSet;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Supplier;

import com.cinchapi.concourse.util.Logger;
import com.google.common.hash.BloomFilter;
import com.google.common.hash.Funnels;

/**
 * A tool to remove duplicate {@link Write Writes} from a collection of
 * {@link WriteStream WriteStreams}.
 *
 * @author Jeff Nelson
 */
public final class WriteDeduper<T extends WriteStream> {

    /**
     * The collection of {@link WriteStream WriteStreams}.
     */
    private final Collection<T> streams;

    /**
     * A {@link Supplier factory} used to create a new {@link WriteStream} to
     * stage non-duplicate data.
     */
    private final Supplier<T> factory;

    /**
     * Tracks all the {@link Write#getVersion() versions) that have been seen.
     */
    private final VersionTracker versions;

    /**
     * Construct a new instance.
     * 
     * @param streams
     * @param factory
     */
    public WriteDeduper(Collection<T> streams, Supplier<T> factory) {
        this.streams = streams;
        this.factory = factory;
        this.versions = new VersionTracker(streams.size());
    }

    /**
     * Search through all of the {@link #streams} for any {@link Write Writes}
     * that are duplicated across the entire collection. Each {@link Stream}
     * that contains at least one duplicate {@link Write} is returned in a
     * {@link Map} from the offending stream to another one, generated by
     * {@link #factory} that is clear of all duplicates.
     * <p>
     * The collection of {@link #streams} is <strong>NOT</strong> modified and
     * the "cleaned" streams that are {@link Map#values() values} in the
     * returned {@link Map} are only guaranteed to have had non-duplicate from
     * the original stream {@link WriteStream#append(Write) appended} (e.g. no
     * sync or save). If desired, the caller must manually update external
     * collections with cleaned streams.
     * </p>
     * 
     * @return a {@link Map} from each stream with duplicate data to a replicate
     *         stream where duplicates have been removed
     */
    public Map<T, T> run() {
        Map<T, T> deduped = new HashMap<>();
        streams.forEach(stream -> {
            T staging = factory.get();
            AtomicBoolean changed = new AtomicBoolean(false);
            stream.writes().forEach(write -> {
                long version = write.getVersion();
                if(versions.add(version)) {
                    staging.append(write);
                }
                else {
                    changed.set(true);
                    Logger.warn("Found duplicate Write {} in {}", write,
                            stream);
                }
            });
            if(changed.get()) {
                deduped.put(stream, staging);
            }
        });
        return deduped;
    }

    /**
     * A {@link Set} that can efficiently store a range of {@link Write}
     * {@link Write#getVersion() versions}.
     * <p>
     * Because versions correspond to timestamps, the {@link VersionTracker}
     * does
     * not contain negative values. Furthermore, the first version is largely
     * offset from {@code 0}, so a {@link VersionTracker} is more efficient than
     * a
     * {@link LongBitSet}.
     * </p>
     *
     * @author Jeff Nelson
     */
    private static class VersionTracker extends AbstractSet<Long> {

        /**
         * Each version that has been {@link #add(Long) added}.
         */
        private final LinkedList<Long> versions;

        /**
         * A {@link BloomFilter} to speed up calls to {@link #contains(Object)}.
         */
        private final BloomFilter<Long> filter;

        /**
         * Construct a new instance.
         * 
         * @param numBlocks
         */
        public VersionTracker(int expectedInsertions) {
            this.versions = new LinkedList<>();
            this.filter = BloomFilter.create(Funnels.longFunnel(),
                    expectedInsertions);

        }

        @Override
        public Iterator<Long> iterator() {
            return versions.iterator();
        }

        @Override
        public int size() {
            return versions.size();
        }

        @Override
        public boolean contains(Object o) {
            if(o instanceof Long) {
                long version = (long) o;
                if(filter.mightContain(version)) {
                    return versions.contains(version);
                }
            }
            return false;
        }

        @Override
        public boolean add(Long e) {
            if(!contains(e)) {
                filter.put(e);
                versions.add(e);
                return true;
            }
            else {
                return false;
            }
        }
    }

}
