#
# Autogenerated by Thrift Compiler (0.12.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .data.ttypes import *
from .shared.ttypes import *
from .exceptions.ttypes import *
from .complex.ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    """
    The interface definition for the Concourse Server API.

    """
    def abort(self, creds, transaction, environment):
        """
        Abort the current transaction and discard any changes that are
        currently staged.
        <p>
        After returning, the driver will return to {@code autocommit} mode and
        all subsequent changes will be committed immediately.
        </p>
        <p>
        Calling this method when the driver is not in {@code staging} mode is a
        no-op.
        </p>
        @param record the id of the record in which an attempt is made to add
                        the data
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @throws exceptions.SecurityException if the {@code creds} don't represent a
                valid session

        Parameters:
         - creds
         - transaction
         - environment

        """
        pass

    def addKeyValue(self, key, value, creds, transaction, environment):
        """
        Append {@code key} as {@code value} in a new record.

        @param key the field name
        @param value the value to add
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return the new record id
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.InvalidArgumentException if any of provided data
                can't be stored

        Parameters:
         - key
         - value
         - creds
         - transaction
         - environment

        """
        pass

    def addKeyValueRecord(self, key, value, record, creds, transaction, environment):
        """
        Append {@code key} as {@code value} in {@code record}.

        @param key the field name
        @param value the value to add
        @param record the record id where an attempt is made to add the data
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a bool that indicates if the data was added
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.InvalidArgumentException if any of provided data
                can't be stored

        Parameters:
         - key
         - value
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def addKeyValueRecords(self, key, value, records, creds, transaction, environment):
        """
        Append {@code key} as {@code value} in each of the {@code records} where it
        doesn't exist.

        @param key the field name
        @param value the value to add
        @param records a list of record ids where an attempt is made to add the
                         data
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a mapping from each record id to a boolean that indicates if the
                          data was added
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.InvalidArgumentException if any of provided data
                can't be stored

        Parameters:
         - key
         - value
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def auditRecord(self, record, creds, transaction, environment):
        """
        List all the changes ever made to {@code record}.

        @param record the record id
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                         revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def auditRecordStart(self, record, start, creds, transaction, environment):
        """
        List all the changes made to {@code record} since {@code start}
        (inclusive).

        @param record the record id
        @param start an inclusive timestamp for the oldest change that should
                       possibly be included in the audit
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                         revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - record
         - start
         - creds
         - transaction
         - environment

        """
        pass

    def auditRecordStartstr(self, record, start, creds, transaction, environment):
        """
        List all the changes made to {@code record} since {@code start}
        (inclusive).

        @param record the record id
        @param start an inclusive timestamp for the oldest change that should
                       possibly be included in the audit
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                         revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - record
         - start
         - creds
         - transaction
         - environment

        """
        pass

    def auditRecordStartEnd(self, record, start, tend, creds, transaction, environment):
        """
        List all the changes made to {@code record} between {@code start}
        (inclusive) and {@code end} (non-inclusive).

        @param record the record id
        @param start an inclusive timestamp for the oldest change that should
                       possibly be included in the audit
        @param end a non-inclusive timestamp that for the most recent recent
                     change that should possibly be included in the audit
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        pass

    def auditRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
        """
        List all the changes made to {@code record} between {@code start}
        (inclusive) and {@code end} (non-inclusive).

        @param record the record id
        @param start an inclusive timestamp for the oldest change that should
                       possibly be included in the audit
        @param end a non-inclusive timestamp that for the most recent recent
                     change that should possibly be included in the audit
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        pass

    def auditKeyRecord(self, key, record, creds, transaction, environment):
        """
        List all the changes ever made to the {@code key} field in {@code record}.

        @param key the field name
        @param record the record id
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def auditKeyRecordStart(self, key, record, start, creds, transaction, environment):
        """
        List all the changes made to the {@code key} field in {@code record} since
        {@code start} (inclusive).

        @param key the field name
        @param record the record id
        @param start an inclusive timestamp for the oldest change that should
                       possibly be included in the audit
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - record
         - start
         - creds
         - transaction
         - environment

        """
        pass

    def auditKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
        """
        List all the changes made to the {@code key} field in {@code record} since
        {@code start} (inclusive).

        @param key the field name
        @param record the record id
        @param start an inclusive timestamp for the oldest change that should
                       possibly be included in the audit
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - record
         - start
         - creds
         - transaction
         - environment

        """
        pass

    def auditKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
        """
        List all the changes made to the {@code key} field in {@code record}
        between {@code start} (inclusive) and {@code end} (non-inclusive).

        @param key the field name
        @param record the record id
        @param start an inclusive timestamp for the oldest change that should
                       possibly be included in the audit
        @param end a non-inclusive timestamp that for the most recent change that
                     should possibly be included in the audit
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        pass

    def auditKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
        """
        List all the changes made to the {@code key} field in {@code record}
        between {@code start} (inclusive) and {@code end} (non-inclusive).

        @param key the field name
        @param record the record id
        @param start an inclusive timestamp for the oldest change that should
                       possibly be included in the audit
        @param end a non-inclusive timestamp that for the most recent recent
                     change that should possibly be included in the audit
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        pass

    def browseKey(self, key, creds, transaction, environment):
        """
        View the values from all records that are currently stored for {@code key}.

        @param keys the field name
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each value to the {@link Set} of records
                that contain that value in the {@code key} field
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - creds
         - transaction
         - environment

        """
        pass

    def browseKeys(self, keys, creds, transaction, environment):
        """
        View the values from all records that are currently stored for each of the
        {@code keys}.

        @param keys a list of field names
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each key to a {@link Map} associating
                each value to the set of records that contain that value in the
                {@code key} field
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - keys
         - creds
         - transaction
         - environment

        """
        pass

    def browseKeyTime(self, key, timestamp, creds, transaction, environment):
        """
        View the values from all records that were stored for {@code key} at
        {@code timestamp}.

        @param keys the field name
        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each value to the {@link Set} of records
                that contained that value in the {@code key} field at {@code
                timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def browseKeyTimestr(self, key, timestamp, creds, transaction, environment):
        """
        View the values from all records that were stored for {@code key} at
        {@code timestamp}.

        @param keys the field name
        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each value to the {@link Set} of records
                that contained that value in the {@code key} field at {@code
                timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def browseKeysTime(self, keys, timestamp, creds, transaction, environment):
        """
        View the values from all records that were stored for each of the
        {@code keys} at {@code timestamp}.

        @param keys a list of field names
        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each key to a {@link Map} associating
                each value to the {@link Set} of records that contained that value
                in the {@code key} field at {@code timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - keys
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def browseKeysTimestr(self, keys, timestamp, creds, transaction, environment):
        """
        View the values from all records that were stored for each of the
        {@code keys} at {@code timestamp}.

        @param keys a list of field names
        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each key to a {@link Map} associating
                each value to the {@link Set} of records that contained that value
                in the {@code key} field at {@code timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - keys
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def chronologizeKeyRecord(self, key, record, creds, transaction, environment):
        """
        View a time series that associates the timestamp of each modification for
        {@code key} in {@code record} to a snapshot containing the values that
        were stored in the field after the change.

        @param key the field name
        @param record the record id
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each modification timestamp to the
                {@link Set} of values that were stored in the field after the
                change.
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def chronologizeKeyRecordStart(self, key, record, start, creds, transaction, environment):
        """
        View a time series between {@code start} (inclusive) and the present that
        associates the timestamp of each modification for {@code key} in
        {@code record} to a snapshot containing the values that
        were stored in the field after the change.

        @param key the field name
        @param record the record id
        @param start the first possible {@link Timestamp} to include in the
                   time series
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each modification timestamp to the
                {@link Set} of values that were stored in the field after the
                change.
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - record
         - start
         - creds
         - transaction
         - environment

        """
        pass

    def chronologizeKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
        """
        View a time series between {@code start} (inclusive) and the present that
        associates the timestamp of each modification for {@code key} in
        {@code record} to a snapshot containing the values that
        were stored in the field after the change.

        @param key the field name
        @param record the record id
        @param start the first possible {@link Timestamp} to include in the
                   time series
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each modification timestamp to the
                {@link Set} of values that were stored in the field after the
                change.
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - record
         - start
         - creds
         - transaction
         - environment

        """
        pass

    def chronologizeKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
        """
        View a time series between {@code start} (inclusive) and {@code end}
        (non-inclusive) that associates the timestamp of each modification for
        {@code key} in {@code record} to a snapshot containing the values that
        were stored in the field after the change.

        @param key the field name
        @param record the record id
        @param start the first possible {@link Timestamp} to include in the
                   time series
        @param end the {@link Timestamp} that should be greater than every
                   timestamp in the time series
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each modification timestamp to the
                {@link Set} of values that were stored in the field after the
                change.
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        pass

    def chronologizeKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
        """
        View a time series between {@code start} (inclusive) and {@code end}
        (non-inclusive) that associates the timestamp of each modification for
        {@code key} in {@code record} to a snapshot containing the values that
        were stored in the field after the change.

        @param key the field name
        @param record the record id
        @param start the first possible {@link Timestamp} to include in the
                   time series
        @param end the {@link Timestamp} that should be greater than every
                   timestamp in the time series
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each modification timestamp to the
                {@link Set} of values that were stored in the field after the
                change.
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        pass

    def clearRecord(self, record, creds, transaction, environment):
        """
        Parameters:
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def clearRecords(self, records, creds, transaction, environment):
        """
        Parameters:
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def clearKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def clearKeysRecord(self, keys, record, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def clearKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def clearKeysRecords(self, keys, records, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def commit(self, creds, transaction, environment):
        """
        Attempt to permanently commit any changes that are staged in a transaction
        and return {@code true} if and only if all the changes can be applied.
        Otherwise, returns {@code false} and all the changes are discarded.
        <p>
        After returning, the driver will return to {@code autocommit} mode and
        all subsequent changes will be committed immediately.
        </p>
        <p>
        This method will return {@code false} if it is called when the driver is
        not in {@code staging} mode.
        </p>

        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return {@code true} if all staged changes are committed, otherwise {@code
                             false}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - creds
         - transaction
         - environment

        """
        pass

    def inspect(self):
        """
        List all plugins enabled in the database.

        @return the {@link Set} of plugins enabled.


        """
        pass

    def describe(self, creds, transaction, environment):
        """
        List all the keys in the database.

        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return the {@link Set} of keys in the database
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - creds
         - transaction
         - environment

        """
        pass

    def describeTime(self, timestamp, creds, transaction, environment):
        """
        List all the keys in the database at {@code timestamp}.

        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return the {@link Set} of keys that were in the database at
                {@code timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def describeTimestr(self, timestamp, creds, transaction, environment):
        """
        List all the keys in the database at {@code timestamp}.

        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return the {@link Set} of keys that were in the database at
                {@code timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def describeRecord(self, record, creds, transaction, environment):
        """
        List all the keys in {@code record} that have at least one value.

        @param record the record id
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return the {@link Set} of keys in {@code record}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def describeRecordTime(self, record, timestamp, creds, transaction, environment):
        """
        List all the keys in {@code record} that had at least one value at
        {@code timestamp}.

        @param record the record id
        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return the {@link Set} of keys that were in {@code record} at
                {@code timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def describeRecordTimestr(self, record, timestamp, creds, transaction, environment):
        """
        List all the keys in {@code record} that have at least one value.

        @param record the record id
        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return the {@link Set} of keys that were in {@code record} at
                {@code timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def describeRecords(self, records, creds, transaction, environment):
        """
        For each of the {@code records}, list all of the keys that have at least
        one value.

        @param records a collection of record ids
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each record id to the {@link Set} of
                keys in that record
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def describeRecordsTime(self, records, timestamp, creds, transaction, environment):
        """
        For each of the {@code records}, list all the keys that had at least one
        value at {@code timestamp}.

        @param records a collection of record ids
        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each record id to the {@link Set} of
                keys that were in that record at {@code timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def describeRecordsTimestr(self, records, timestamp, creds, transaction, environment):
        """
        For each of the {@code records}, list all the keys that had at least one
        value at {@code timestamp}.

        @param records a collection of record ids
        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each record id to the {@link Set} of
                keys that were in that record at {@code timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def diffRecordStart(self, record, start, creds, transaction, environment):
        """
        List the net changes made to {@code record} since {@code start}.

        <p>
        If you begin with the state of the {@code record} at {@code start} and
        re-apply all the changes in the diff, you'll re-create the state of the
        {@code record} at the present.
        </p>

        @param record the record id
        @param start the base timestamp from which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates each key in the {@code record} to
                another {@link Map} that associates a {@link Diff change
                description} to the {@link Set} of values that fit the
                description (i.e. <code>
                {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
                "value4"]}}
                </code> )
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - record
         - start
         - creds
         - transaction
         - environment

        """
        pass

    def diffRecordStartstr(self, record, start, creds, transaction, environment):
        """
        List the net changes made to {@code record} since {@code start}.

        <p>
        If you begin with the state of the {@code record} at {@code start} and
        re-apply all the changes in the diff, you'll re-create the state of the
        {@code record} at the present.
        </p>

        @param record the record id
        @param start the base timestamp from which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates each key in the {@code record} to
                another {@link Map} that associates a {@link Diff change
                description} to the {@link Set} of values that fit the
                description (i.e. <code>
                {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
                "value4"]}}
                </code> )
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - record
         - start
         - creds
         - transaction
         - environment

        """
        pass

    def diffRecordStartEnd(self, record, start, tend, creds, transaction, environment):
        """
        List the net changes made to {@code record} from {@code start} to
        {@code end}.

        <p>
        If you begin with the state of the {@code record} at {@code start} and
        re-apply all the changes in the diff, you'll re-create the state of the
        {@code record} at {@code end}.
        </p>

        @param record the record id
        @param start the base timestamp from which the diff is calculated
        @param end the comparison timestamp to which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates each key in the {@code record} to
                another {@link Map} that associates a {@link Diff change
                description} to the {@link Set} of values that fit the
                description (i.e. <code>
                {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
                "value4"]}}
                </code> )
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        pass

    def diffRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
        """
        List the net changes made to {@code record} from {@code start} to
        {@code end}.

        <p>
        If you begin with the state of the {@code record} at {@code start} and
        re-apply all the changes in the diff, you'll re-create the state of the
        {@code record} at {@code end}.
        </p>

        @param record the record id
        @param start the base timestamp from which the diff is calculated
        @param end the comparison timestamp to which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates each key in the {@code record} to
                another {@link Map} that associates a {@link Diff change
                description} to the {@link Set} of values that fit the
                description (i.e. <code>
                {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
                "value4"]}}
                </code> )
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        pass

    def diffKeyRecordStart(self, key, record, start, creds, transaction, environment):
        """
        List the net changes made to {@code key} in {@code record} since
        {@code start}.

        <p>
        If you begin with the state of the field at {@code start} and re-apply
        all the changes in the diff, you'll re-create the state of the field at
        the present.
        </p>

        @param key the field name
        @param record the record id
        @param start the base timestamp from which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates a {@link Diff change
                description} to the {@link Set} of values that fit the
                description (i.e. <code>
                {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
                </code> )
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - record
         - start
         - creds
         - transaction
         - environment

        """
        pass

    def diffKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
        """
        List the net changes made to {@code key} in {@code record} since
        {@code start}.

        <p>
        If you begin with the state of the field at {@code start} and re-apply
        all the changes in the diff, you'll re-create the state of the field at
        the present.
        </p>

        @param key the field name
        @param record the record id
        @param start the base timestamp from which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates a {@link Diff change
                description} to the {@link Set} of values that fit the
                description (i.e. <code>
                {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
                </code> )
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - record
         - start
         - creds
         - transaction
         - environment

        """
        pass

    def diffKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
        """
        List the net changes made to {@code key} in {@code record} from
        {@code start} to {@code end}.

        <p>
        If you begin with the state of the field at {@code start} and re-apply
        all the changes in the diff, you'll re-create the state of the field at
        {@code end}.
        </p>

        @param key the field name
        @param record the record id
        @param start the base timestamp from which the diff is calculated
        @param end the comparison timestamp to which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates a {@link Diff change
                description} to the {@link Set} of values that fit the
                description (i.e. <code>
                {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
                </code> )
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        pass

    def diffKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
        """
        List the net changes made to {@code key} in {@code record} from
        {@code start} to {@code end}.

        <p>
        If you begin with the state of the field at {@code start} and re-apply
        all the changes in the diff, you'll re-create the state of the field at
        {@code end}.
        </p>

        @param key the field name
        @param record the record id
        @param start the base timestamp from which the diff is calculated
        @param end the comparison timestamp to which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates a {@link Diff change
                description} to the {@link Set} of values that fit the
                description (i.e. <code>
                {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
                </code> )
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        pass

    def diffKeyStart(self, key, start, creds, transaction, environment):
        """
        List the net changes made to the {@code key} field across all records
        since {@code start}.

        <p>
        If you begin with the state of an inverted index for {@code key} at
        {@code start} and re-apply all the changes in the diff, you'll re-create
        the state of the same index at the present.
        </p>

        @param key the field name
        @param start the base timestamp from which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates each value stored for {@code key}
                across all records to another {@link Map} that associates a
                {@link Diff change description} to the {@link Set} of records
                where the description applies to that value in the {@code key}
                field (i.e. <code>
                {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
                </code>)
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - start
         - creds
         - transaction
         - environment

        """
        pass

    def diffKeyStartstr(self, key, start, creds, transaction, environment):
        """
        List the net changes made to the {@code key} field across all records
        since {@code start}.

        <p>
        If you begin with the state of an inverted index for {@code key} at
        {@code start} and re-apply all the changes in the diff, you'll re-create
        the state of the same index at the present.
        </p>

        @param key the field name
        @param start the base timestamp from which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates each value stored for {@code key}
                across all records to another {@link Map} that associates a
                {@link Diff change description} to the {@link Set} of records
                where the description applies to that value in the {@code key}
                field (i.e. <code>
                {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
                </code>)
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - start
         - creds
         - transaction
         - environment

        """
        pass

    def diffKeyStartEnd(self, key, start, tend, creds, transaction, environment):
        """
        List the net changes made to the {@code key} field across all records
        from {@code start} to {@code end}.

        <p>
        If you begin with the state of an inverted index for {@code key} at
        {@code start} and re-apply all the changes in the diff, you'll re-create
        the state of the same index at {@code end}.
        </p>

        @param key the field name
        @param start the base timestamp from which the diff is calculated
        @param end the comparison timestamp to which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates each value stored for {@code key}
                across all records to another {@link Map} that associates a
                {@link Diff change description} to the {@link Set} of records
                where the description applies to that value in the {@code key}
                field (i.e. <code>
                {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
                </code>)
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        pass

    def diffKeyStartstrEndstr(self, key, start, tend, creds, transaction, environment):
        """
        List the net changes made to the {@code key} field across all records
        from {@code start} to {@code end}.

        <p>
        If you begin with the state of an inverted index for {@code key} at
        {@code start} and re-apply all the changes in the diff, you'll re-create
        the state of the same index at {@code end}.
        </p>

        @param key the field name
        @param start the base timestamp from which the diff is calculated
        @param end the comparison timestamp to which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates each value stored for {@code key}
                across all records to another {@link Map} that associates a
                {@link Diff change description} to the {@link Set} of records
                where the description applies to that value in the {@code key}
                field (i.e. <code>
                {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
                </code>)
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        pass

    def invokePlugin(self, id, method, params, creds, transaction, environment):
        """
        Invoke a Plugin method.

        <p>
        Assuming that there is a plugin distribution that contains a class
        named after {@code id}, and has the specified {@code method}, invoke the
        same with {@code params} and return the result.
        </p>

        @param id the fully qualified name of the plugin class
        @param method the name of the method in {@code clazz} to invoke
        @param params a list of TObjects to pass to {@code method} as args
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return the result of the method invocation
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.InvalidArgumentException if any of the arguments are
                invalid

        Parameters:
         - id
         - method
         - params
         - creds
         - transaction
         - environment

        """
        pass

    def login(self, username, password, environment):
        """
        Attempt to authenticate the user identified by the {@code username} and
        {@code password} combination to the specified {@code environment}. If
        successful, establish a new session within the {@code environment} on
        behalf of that user and return an {@link shared.AccessToken}, which is
        required for all subsequent operations.

        <p>
        The AccessToken <em>may</em> expire after a while so clients should be
        prepared to seamlessly login again for active user sessions.
        </p>

        @param username a binary representation of the UTF-8 encoded username
        @param password a binary representation of the UTF-8 encoded password
        @param environment the name of the environment into which to login
        @return an {@link shared.AccessToken} to submit with all subsequent method
                calls
        @throws exceptions.SecurityException if the login is not successful

        Parameters:
         - username
         - password
         - environment

        """
        pass

    def logout(self, token, environment):
        """
        Terminate the session within {@code environment} for the user represented
        by the {@code token}. Afterwards, all other attempts to use {@code token}
        will result in a {@link exceptions.SecurityException} being thrown.

        @param token the {@link shared.AccessToken to expire}
        @param environment the environment of the session represented by the
                           {@code token}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session

        Parameters:
         - token
         - environment

        """
        pass

    def stage(self, token, environment):
        """
        Start a new transaction.
        <p>
        This method will turn on STAGING mode so that all subsequent changes are
        collected in an isolated buffer before possibly being committed to the
        database. Staged operations are guaranteed to be reliable, all or nothing
        units of work that allow correct recovery from failures and provide
        isolation between clients so the database is always in a consistent state.
        </p>
        <p>
        After this method returns, all subsequent operations will be done in
        {@code staging} mode until either #abort(shared.AccessToken) or
        #commit(shared.AccessToken) is called.
        </p>

        @param token
        @param environment
        @return TransactionToken
        @throws TSecurityException

        Parameters:
         - token
         - environment

        """
        pass

    def insertJson(self, json, creds, transaction, environment):
        """
        Parameters:
         - json
         - creds
         - transaction
         - environment

        """
        pass

    def insertJsonRecord(self, json, record, creds, transaction, environment):
        """
        Parameters:
         - json
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def insertJsonRecords(self, json, records, creds, transaction, environment):
        """
        Parameters:
         - json
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def removeKeyValueRecord(self, key, value, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def removeKeyValueRecords(self, key, value, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def setKeyValueRecord(self, key, value, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def setKeyValue(self, key, value, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - creds
         - transaction
         - environment

        """
        pass

    def setKeyValueRecords(self, key, value, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def reconcileKeyRecordValues(self, key, record, values, creds, transaction, environment):
        """
        The {@code value} in {@code key} of {@code record} are added
        and removed to be set as exactly the same as the input values

        @param key the field name
        @param record the record id where an attempt is made to add the data
        @param values collection of values to set
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a bool that indicates if the data was added
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.InvalidArgumentException if any of provided data
                can't be stored

        Parameters:
         - key
         - record
         - values
         - creds
         - transaction
         - environment

        """
        pass

    def inventory(self, creds, transaction, environment):
        """
        Parameters:
         - creds
         - transaction
         - environment

        """
        pass

    def selectRecord(self, record, creds, transaction, environment):
        """
        Parameters:
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def selectRecords(self, records, creds, transaction, environment):
        """
        Parameters:
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def selectRecordTime(self, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectRecordTimestr(self, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectRecordsTime(self, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectRecordsTimestr(self, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeysRecord(self, keys, record, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeysRecords(self, keys, records, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectCriteria(self, criteria, creds, transaction, environment):
        """
        Parameters:
         - criteria
         - creds
         - transaction
         - environment

        """
        pass

    def selectCcl(self, ccl, creds, transaction, environment):
        """
        Parameters:
         - ccl
         - creds
         - transaction
         - environment

        """
        pass

    def selectCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectCclTime(self, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectCclTimestr(self, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeyCriteria(self, key, criteria, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeyCcl(self, key, ccl, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeysCriteria(self, keys, criteria, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeysCcl(self, keys, ccl, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def selectKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def getKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeysRecord(self, keys, record, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def getKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeysRecords(self, keys, records, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def getKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def getKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeyCriteria(self, key, criteria, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - creds
         - transaction
         - environment

        """
        pass

    def getCriteria(self, criteria, creds, transaction, environment):
        """
        Parameters:
         - criteria
         - creds
         - transaction
         - environment

        """
        pass

    def getCcl(self, ccl, creds, transaction, environment):
        """
        Parameters:
         - ccl
         - creds
         - transaction
         - environment

        """
        pass

    def getCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getCclTime(self, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getCclTimestr(self, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeyCcl(self, key, ccl, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - creds
         - transaction
         - environment

        """
        pass

    def getKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeysCriteria(self, keys, criteria, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - creds
         - transaction
         - environment

        """
        pass

    def getKeysCcl(self, keys, ccl, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - creds
         - transaction
         - environment

        """
        pass

    def getKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def verifyKeyValueRecord(self, key, value, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def verifyKeyValueRecordTime(self, key, value, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def verifyKeyValueRecordTimestr(self, key, value, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def jsonifyRecords(self, records, identifier, creds, transaction, environment):
        """
        Parameters:
         - records
         - identifier
         - creds
         - transaction
         - environment

        """
        pass

    def jsonifyRecordsTime(self, records, timestamp, identifier, creds, transaction, environment):
        """
        Parameters:
         - records
         - timestamp
         - identifier
         - creds
         - transaction
         - environment

        """
        pass

    def jsonifyRecordsTimestr(self, records, timestamp, identifier, creds, transaction, environment):
        """
        Parameters:
         - records
         - timestamp
         - identifier
         - creds
         - transaction
         - environment

        """
        pass

    def findCriteria(self, criteria, creds, transaction, environment):
        """
        Parameters:
         - criteria
         - creds
         - transaction
         - environment

        """
        pass

    def findCcl(self, ccl, creds, transaction, environment):
        """
        Parameters:
         - ccl
         - creds
         - transaction
         - environment

        """
        pass

    def findKeyOperatorValues(self, key, operator, values, creds, transaction, environment):
        """
        Parameters:
         - key
         - operator
         - values
         - creds
         - transaction
         - environment

        """
        pass

    def findKeyOperatorValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - operator
         - values
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def findKeyOperatorValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - operator
         - values
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def findKeyOperatorstrValues(self, key, operator, values, creds, transaction, environment):
        """
        Parameters:
         - key
         - operator
         - values
         - creds
         - transaction
         - environment

        """
        pass

    def findKeyOperatorstrValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - operator
         - values
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def findKeyOperatorstrValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - operator
         - values
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def search(self, key, query, creds, transaction, environment):
        """
        Parameters:
         - key
         - query
         - creds
         - transaction
         - environment

        """
        pass

    def revertKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def revertKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def revertKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def revertKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def revertKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def revertKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def revertKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def revertKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def pingRecords(self, records, creds, transaction, environment):
        """
        Parameters:
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def pingRecord(self, record, creds, transaction, environment):
        """
        Parameters:
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def verifyAndSwap(self, key, expected, record, replacement, creds, transaction, environment):
        """
        Parameters:
         - key
         - expected
         - record
         - replacement
         - creds
         - transaction
         - environment

        """
        pass

    def verifyOrSet(self, key, value, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def findOrAddKeyValue(self, key, value, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - creds
         - transaction
         - environment

        """
        pass

    def findOrInsertCriteriaJson(self, criteria, json, creds, transaction, environment):
        """
        Parameters:
         - criteria
         - json
         - creds
         - transaction
         - environment

        """
        pass

    def findOrInsertCclJson(self, ccl, json, creds, transaction, environment):
        """
        Parameters:
         - ccl
         - json
         - creds
         - transaction
         - environment

        """
        pass

    def sumKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def sumKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def sumKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def sumKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def sumKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def sumKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def sumKey(self, key, creds, transaction, environment):
        """
        Parameters:
         - key
         - creds
         - transaction
         - environment

        """
        pass

    def sumKeyTime(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def sumKeyTimestr(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def sumKeyCriteria(self, key, criteria, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - creds
         - transaction
         - environment

        """
        pass

    def sumKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def sumKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def sumKeyCcl(self, key, ccl, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - creds
         - transaction
         - environment

        """
        pass

    def sumKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def sumKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def averageKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def averageKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def averageKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def averageKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def averageKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def averageKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def averageKey(self, key, creds, transaction, environment):
        """
        Parameters:
         - key
         - creds
         - transaction
         - environment

        """
        pass

    def averageKeyTime(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def averageKeyTimestr(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def averageKeyCriteria(self, key, criteria, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - creds
         - transaction
         - environment

        """
        pass

    def averageKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def averageKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def averageKeyCcl(self, key, ccl, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - creds
         - transaction
         - environment

        """
        pass

    def averageKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def averageKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def countKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def countKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def countKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def countKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def countKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def countKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def countKey(self, key, creds, transaction, environment):
        """
        Parameters:
         - key
         - creds
         - transaction
         - environment

        """
        pass

    def countKeyTime(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def countKeyTimestr(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def countKeyCriteria(self, key, criteria, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - creds
         - transaction
         - environment

        """
        pass

    def countKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def countKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def countKeyCcl(self, key, ccl, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - creds
         - transaction
         - environment

        """
        pass

    def countKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def countKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def maxKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def maxKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def maxKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def maxKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def maxKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def maxKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def maxKeyCriteria(self, key, criteria, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - creds
         - transaction
         - environment

        """
        pass

    def maxKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def maxKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def maxKeyCcl(self, key, ccl, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - creds
         - transaction
         - environment

        """
        pass

    def maxKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def maxKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def maxKey(self, key, creds, transaction, environment):
        """
        Parameters:
         - key
         - creds
         - transaction
         - environment

        """
        pass

    def maxKeyTime(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def maxKeyTimestr(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def minKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def minKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def minKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def minKey(self, key, creds, transaction, environment):
        """
        Parameters:
         - key
         - creds
         - transaction
         - environment

        """
        pass

    def minKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def minKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def minKeyCriteria(self, key, criteria, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - creds
         - transaction
         - environment

        """
        pass

    def minKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def minKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def minKeyCcl(self, key, ccl, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - creds
         - transaction
         - environment

        """
        pass

    def minKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def minKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def minKeyTime(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def minKeyTimestr(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def minKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeysRecord(self, keys, record, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeysRecords(self, keys, records, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeyCcl(self, key, ccl, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeysCcl(self, keys, ccl, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeyCriteria(self, key, criteria, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeysCriteria(self, keys, criteria, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def navigateKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        pass

    def getServerEnvironment(self, creds, token, environment):
        """
        Parameters:
         - creds
         - token
         - environment

        """
        pass

    def getServerVersion(self):
        pass

    def time(self, creds, token, environment):
        """
        Parameters:
         - creds
         - token
         - environment

        """
        pass

    def timePhrase(self, phrase, creds, token, environment):
        """
        Parameters:
         - phrase
         - creds
         - token
         - environment

        """
        pass

    def invokeManagement(self, method, params, creds):
        """
        Parameters:
         - method
         - params
         - creds

        """
        pass


class Client(Iface):
    """
    The interface definition for the Concourse Server API.

    """
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def abort(self, creds, transaction, environment):
        """
        Abort the current transaction and discard any changes that are
        currently staged.
        <p>
        After returning, the driver will return to {@code autocommit} mode and
        all subsequent changes will be committed immediately.
        </p>
        <p>
        Calling this method when the driver is not in {@code staging} mode is a
        no-op.
        </p>
        @param record the id of the record in which an attempt is made to add
                        the data
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @throws exceptions.SecurityException if the {@code creds} don't represent a
                valid session

        Parameters:
         - creds
         - transaction
         - environment

        """
        self.send_abort(creds, transaction, environment)
        self.recv_abort()

    def send_abort(self, creds, transaction, environment):
        self._oprot.writeMessageBegin('abort', TMessageType.CALL, self._seqid)
        args = abort_args()
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_abort(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = abort_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def addKeyValue(self, key, value, creds, transaction, environment):
        """
        Append {@code key} as {@code value} in a new record.

        @param key the field name
        @param value the value to add
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return the new record id
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.InvalidArgumentException if any of provided data
                can't be stored

        Parameters:
         - key
         - value
         - creds
         - transaction
         - environment

        """
        self.send_addKeyValue(key, value, creds, transaction, environment)
        return self.recv_addKeyValue()

    def send_addKeyValue(self, key, value, creds, transaction, environment):
        self._oprot.writeMessageBegin('addKeyValue', TMessageType.CALL, self._seqid)
        args = addKeyValue_args()
        args.key = key
        args.value = value
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addKeyValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addKeyValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addKeyValue failed: unknown result")

    def addKeyValueRecord(self, key, value, record, creds, transaction, environment):
        """
        Append {@code key} as {@code value} in {@code record}.

        @param key the field name
        @param value the value to add
        @param record the record id where an attempt is made to add the data
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a bool that indicates if the data was added
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.InvalidArgumentException if any of provided data
                can't be stored

        Parameters:
         - key
         - value
         - record
         - creds
         - transaction
         - environment

        """
        self.send_addKeyValueRecord(key, value, record, creds, transaction, environment)
        return self.recv_addKeyValueRecord()

    def send_addKeyValueRecord(self, key, value, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('addKeyValueRecord', TMessageType.CALL, self._seqid)
        args = addKeyValueRecord_args()
        args.key = key
        args.value = value
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addKeyValueRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addKeyValueRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addKeyValueRecord failed: unknown result")

    def addKeyValueRecords(self, key, value, records, creds, transaction, environment):
        """
        Append {@code key} as {@code value} in each of the {@code records} where it
        doesn't exist.

        @param key the field name
        @param value the value to add
        @param records a list of record ids where an attempt is made to add the
                         data
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a mapping from each record id to a boolean that indicates if the
                          data was added
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.InvalidArgumentException if any of provided data
                can't be stored

        Parameters:
         - key
         - value
         - records
         - creds
         - transaction
         - environment

        """
        self.send_addKeyValueRecords(key, value, records, creds, transaction, environment)
        return self.recv_addKeyValueRecords()

    def send_addKeyValueRecords(self, key, value, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('addKeyValueRecords', TMessageType.CALL, self._seqid)
        args = addKeyValueRecords_args()
        args.key = key
        args.value = value
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addKeyValueRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addKeyValueRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addKeyValueRecords failed: unknown result")

    def auditRecord(self, record, creds, transaction, environment):
        """
        List all the changes ever made to {@code record}.

        @param record the record id
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                         revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - record
         - creds
         - transaction
         - environment

        """
        self.send_auditRecord(record, creds, transaction, environment)
        return self.recv_auditRecord()

    def send_auditRecord(self, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('auditRecord', TMessageType.CALL, self._seqid)
        args = auditRecord_args()
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_auditRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = auditRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecord failed: unknown result")

    def auditRecordStart(self, record, start, creds, transaction, environment):
        """
        List all the changes made to {@code record} since {@code start}
        (inclusive).

        @param record the record id
        @param start an inclusive timestamp for the oldest change that should
                       possibly be included in the audit
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                         revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - record
         - start
         - creds
         - transaction
         - environment

        """
        self.send_auditRecordStart(record, start, creds, transaction, environment)
        return self.recv_auditRecordStart()

    def send_auditRecordStart(self, record, start, creds, transaction, environment):
        self._oprot.writeMessageBegin('auditRecordStart', TMessageType.CALL, self._seqid)
        args = auditRecordStart_args()
        args.record = record
        args.start = start
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_auditRecordStart(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = auditRecordStart_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecordStart failed: unknown result")

    def auditRecordStartstr(self, record, start, creds, transaction, environment):
        """
        List all the changes made to {@code record} since {@code start}
        (inclusive).

        @param record the record id
        @param start an inclusive timestamp for the oldest change that should
                       possibly be included in the audit
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                         revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - record
         - start
         - creds
         - transaction
         - environment

        """
        self.send_auditRecordStartstr(record, start, creds, transaction, environment)
        return self.recv_auditRecordStartstr()

    def send_auditRecordStartstr(self, record, start, creds, transaction, environment):
        self._oprot.writeMessageBegin('auditRecordStartstr', TMessageType.CALL, self._seqid)
        args = auditRecordStartstr_args()
        args.record = record
        args.start = start
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_auditRecordStartstr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = auditRecordStartstr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecordStartstr failed: unknown result")

    def auditRecordStartEnd(self, record, start, tend, creds, transaction, environment):
        """
        List all the changes made to {@code record} between {@code start}
        (inclusive) and {@code end} (non-inclusive).

        @param record the record id
        @param start an inclusive timestamp for the oldest change that should
                       possibly be included in the audit
        @param end a non-inclusive timestamp that for the most recent recent
                     change that should possibly be included in the audit
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        self.send_auditRecordStartEnd(record, start, tend, creds, transaction, environment)
        return self.recv_auditRecordStartEnd()

    def send_auditRecordStartEnd(self, record, start, tend, creds, transaction, environment):
        self._oprot.writeMessageBegin('auditRecordStartEnd', TMessageType.CALL, self._seqid)
        args = auditRecordStartEnd_args()
        args.record = record
        args.start = start
        args.tend = tend
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_auditRecordStartEnd(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = auditRecordStartEnd_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecordStartEnd failed: unknown result")

    def auditRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
        """
        List all the changes made to {@code record} between {@code start}
        (inclusive) and {@code end} (non-inclusive).

        @param record the record id
        @param start an inclusive timestamp for the oldest change that should
                       possibly be included in the audit
        @param end a non-inclusive timestamp that for the most recent recent
                     change that should possibly be included in the audit
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        self.send_auditRecordStartstrEndstr(record, start, tend, creds, transaction, environment)
        return self.recv_auditRecordStartstrEndstr()

    def send_auditRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
        self._oprot.writeMessageBegin('auditRecordStartstrEndstr', TMessageType.CALL, self._seqid)
        args = auditRecordStartstrEndstr_args()
        args.record = record
        args.start = start
        args.tend = tend
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_auditRecordStartstrEndstr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = auditRecordStartstrEndstr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecordStartstrEndstr failed: unknown result")

    def auditKeyRecord(self, key, record, creds, transaction, environment):
        """
        List all the changes ever made to the {@code key} field in {@code record}.

        @param key the field name
        @param record the record id
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        self.send_auditKeyRecord(key, record, creds, transaction, environment)
        return self.recv_auditKeyRecord()

    def send_auditKeyRecord(self, key, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('auditKeyRecord', TMessageType.CALL, self._seqid)
        args = auditKeyRecord_args()
        args.key = key
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_auditKeyRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = auditKeyRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecord failed: unknown result")

    def auditKeyRecordStart(self, key, record, start, creds, transaction, environment):
        """
        List all the changes made to the {@code key} field in {@code record} since
        {@code start} (inclusive).

        @param key the field name
        @param record the record id
        @param start an inclusive timestamp for the oldest change that should
                       possibly be included in the audit
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - record
         - start
         - creds
         - transaction
         - environment

        """
        self.send_auditKeyRecordStart(key, record, start, creds, transaction, environment)
        return self.recv_auditKeyRecordStart()

    def send_auditKeyRecordStart(self, key, record, start, creds, transaction, environment):
        self._oprot.writeMessageBegin('auditKeyRecordStart', TMessageType.CALL, self._seqid)
        args = auditKeyRecordStart_args()
        args.key = key
        args.record = record
        args.start = start
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_auditKeyRecordStart(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = auditKeyRecordStart_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecordStart failed: unknown result")

    def auditKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
        """
        List all the changes made to the {@code key} field in {@code record} since
        {@code start} (inclusive).

        @param key the field name
        @param record the record id
        @param start an inclusive timestamp for the oldest change that should
                       possibly be included in the audit
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - record
         - start
         - creds
         - transaction
         - environment

        """
        self.send_auditKeyRecordStartstr(key, record, start, creds, transaction, environment)
        return self.recv_auditKeyRecordStartstr()

    def send_auditKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
        self._oprot.writeMessageBegin('auditKeyRecordStartstr', TMessageType.CALL, self._seqid)
        args = auditKeyRecordStartstr_args()
        args.key = key
        args.record = record
        args.start = start
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_auditKeyRecordStartstr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = auditKeyRecordStartstr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecordStartstr failed: unknown result")

    def auditKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
        """
        List all the changes made to the {@code key} field in {@code record}
        between {@code start} (inclusive) and {@code end} (non-inclusive).

        @param key the field name
        @param record the record id
        @param start an inclusive timestamp for the oldest change that should
                       possibly be included in the audit
        @param end a non-inclusive timestamp that for the most recent change that
                     should possibly be included in the audit
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        self.send_auditKeyRecordStartEnd(key, record, start, tend, creds, transaction, environment)
        return self.recv_auditKeyRecordStartEnd()

    def send_auditKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
        self._oprot.writeMessageBegin('auditKeyRecordStartEnd', TMessageType.CALL, self._seqid)
        args = auditKeyRecordStartEnd_args()
        args.key = key
        args.record = record
        args.start = start
        args.tend = tend
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_auditKeyRecordStartEnd(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = auditKeyRecordStartEnd_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecordStartEnd failed: unknown result")

    def auditKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
        """
        List all the changes made to the {@code key} field in {@code record}
        between {@code start} (inclusive) and {@code end} (non-inclusive).

        @param key the field name
        @param record the record id
        @param start an inclusive timestamp for the oldest change that should
                       possibly be included in the audit
        @param end a non-inclusive timestamp that for the most recent recent
                     change that should possibly be included in the audit
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return for each change, a mapping from timestamp to a description of the
                revision
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        self.send_auditKeyRecordStartstrEndstr(key, record, start, tend, creds, transaction, environment)
        return self.recv_auditKeyRecordStartstrEndstr()

    def send_auditKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
        self._oprot.writeMessageBegin('auditKeyRecordStartstrEndstr', TMessageType.CALL, self._seqid)
        args = auditKeyRecordStartstrEndstr_args()
        args.key = key
        args.record = record
        args.start = start
        args.tend = tend
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_auditKeyRecordStartstrEndstr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = auditKeyRecordStartstrEndstr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecordStartstrEndstr failed: unknown result")

    def browseKey(self, key, creds, transaction, environment):
        """
        View the values from all records that are currently stored for {@code key}.

        @param keys the field name
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each value to the {@link Set} of records
                that contain that value in the {@code key} field
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - creds
         - transaction
         - environment

        """
        self.send_browseKey(key, creds, transaction, environment)
        return self.recv_browseKey()

    def send_browseKey(self, key, creds, transaction, environment):
        self._oprot.writeMessageBegin('browseKey', TMessageType.CALL, self._seqid)
        args = browseKey_args()
        args.key = key
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_browseKey(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = browseKey_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKey failed: unknown result")

    def browseKeys(self, keys, creds, transaction, environment):
        """
        View the values from all records that are currently stored for each of the
        {@code keys}.

        @param keys a list of field names
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each key to a {@link Map} associating
                each value to the set of records that contain that value in the
                {@code key} field
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - keys
         - creds
         - transaction
         - environment

        """
        self.send_browseKeys(keys, creds, transaction, environment)
        return self.recv_browseKeys()

    def send_browseKeys(self, keys, creds, transaction, environment):
        self._oprot.writeMessageBegin('browseKeys', TMessageType.CALL, self._seqid)
        args = browseKeys_args()
        args.keys = keys
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_browseKeys(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = browseKeys_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeys failed: unknown result")

    def browseKeyTime(self, key, timestamp, creds, transaction, environment):
        """
        View the values from all records that were stored for {@code key} at
        {@code timestamp}.

        @param keys the field name
        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each value to the {@link Set} of records
                that contained that value in the {@code key} field at {@code
                timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_browseKeyTime(key, timestamp, creds, transaction, environment)
        return self.recv_browseKeyTime()

    def send_browseKeyTime(self, key, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('browseKeyTime', TMessageType.CALL, self._seqid)
        args = browseKeyTime_args()
        args.key = key
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_browseKeyTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = browseKeyTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeyTime failed: unknown result")

    def browseKeyTimestr(self, key, timestamp, creds, transaction, environment):
        """
        View the values from all records that were stored for {@code key} at
        {@code timestamp}.

        @param keys the field name
        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each value to the {@link Set} of records
                that contained that value in the {@code key} field at {@code
                timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_browseKeyTimestr(key, timestamp, creds, transaction, environment)
        return self.recv_browseKeyTimestr()

    def send_browseKeyTimestr(self, key, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('browseKeyTimestr', TMessageType.CALL, self._seqid)
        args = browseKeyTimestr_args()
        args.key = key
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_browseKeyTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = browseKeyTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeyTimestr failed: unknown result")

    def browseKeysTime(self, keys, timestamp, creds, transaction, environment):
        """
        View the values from all records that were stored for each of the
        {@code keys} at {@code timestamp}.

        @param keys a list of field names
        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each key to a {@link Map} associating
                each value to the {@link Set} of records that contained that value
                in the {@code key} field at {@code timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - keys
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_browseKeysTime(keys, timestamp, creds, transaction, environment)
        return self.recv_browseKeysTime()

    def send_browseKeysTime(self, keys, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('browseKeysTime', TMessageType.CALL, self._seqid)
        args = browseKeysTime_args()
        args.keys = keys
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_browseKeysTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = browseKeysTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeysTime failed: unknown result")

    def browseKeysTimestr(self, keys, timestamp, creds, transaction, environment):
        """
        View the values from all records that were stored for each of the
        {@code keys} at {@code timestamp}.

        @param keys a list of field names
        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each key to a {@link Map} associating
                each value to the {@link Set} of records that contained that value
                in the {@code key} field at {@code timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - keys
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_browseKeysTimestr(keys, timestamp, creds, transaction, environment)
        return self.recv_browseKeysTimestr()

    def send_browseKeysTimestr(self, keys, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('browseKeysTimestr', TMessageType.CALL, self._seqid)
        args = browseKeysTimestr_args()
        args.keys = keys
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_browseKeysTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = browseKeysTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeysTimestr failed: unknown result")

    def chronologizeKeyRecord(self, key, record, creds, transaction, environment):
        """
        View a time series that associates the timestamp of each modification for
        {@code key} in {@code record} to a snapshot containing the values that
        were stored in the field after the change.

        @param key the field name
        @param record the record id
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each modification timestamp to the
                {@link Set} of values that were stored in the field after the
                change.
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        self.send_chronologizeKeyRecord(key, record, creds, transaction, environment)
        return self.recv_chronologizeKeyRecord()

    def send_chronologizeKeyRecord(self, key, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('chronologizeKeyRecord', TMessageType.CALL, self._seqid)
        args = chronologizeKeyRecord_args()
        args.key = key
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_chronologizeKeyRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = chronologizeKeyRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecord failed: unknown result")

    def chronologizeKeyRecordStart(self, key, record, start, creds, transaction, environment):
        """
        View a time series between {@code start} (inclusive) and the present that
        associates the timestamp of each modification for {@code key} in
        {@code record} to a snapshot containing the values that
        were stored in the field after the change.

        @param key the field name
        @param record the record id
        @param start the first possible {@link Timestamp} to include in the
                   time series
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each modification timestamp to the
                {@link Set} of values that were stored in the field after the
                change.
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - record
         - start
         - creds
         - transaction
         - environment

        """
        self.send_chronologizeKeyRecordStart(key, record, start, creds, transaction, environment)
        return self.recv_chronologizeKeyRecordStart()

    def send_chronologizeKeyRecordStart(self, key, record, start, creds, transaction, environment):
        self._oprot.writeMessageBegin('chronologizeKeyRecordStart', TMessageType.CALL, self._seqid)
        args = chronologizeKeyRecordStart_args()
        args.key = key
        args.record = record
        args.start = start
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_chronologizeKeyRecordStart(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = chronologizeKeyRecordStart_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecordStart failed: unknown result")

    def chronologizeKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
        """
        View a time series between {@code start} (inclusive) and the present that
        associates the timestamp of each modification for {@code key} in
        {@code record} to a snapshot containing the values that
        were stored in the field after the change.

        @param key the field name
        @param record the record id
        @param start the first possible {@link Timestamp} to include in the
                   time series
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each modification timestamp to the
                {@link Set} of values that were stored in the field after the
                change.
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - record
         - start
         - creds
         - transaction
         - environment

        """
        self.send_chronologizeKeyRecordStartstr(key, record, start, creds, transaction, environment)
        return self.recv_chronologizeKeyRecordStartstr()

    def send_chronologizeKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
        self._oprot.writeMessageBegin('chronologizeKeyRecordStartstr', TMessageType.CALL, self._seqid)
        args = chronologizeKeyRecordStartstr_args()
        args.key = key
        args.record = record
        args.start = start
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_chronologizeKeyRecordStartstr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = chronologizeKeyRecordStartstr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecordStartstr failed: unknown result")

    def chronologizeKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
        """
        View a time series between {@code start} (inclusive) and {@code end}
        (non-inclusive) that associates the timestamp of each modification for
        {@code key} in {@code record} to a snapshot containing the values that
        were stored in the field after the change.

        @param key the field name
        @param record the record id
        @param start the first possible {@link Timestamp} to include in the
                   time series
        @param end the {@link Timestamp} that should be greater than every
                   timestamp in the time series
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each modification timestamp to the
                {@link Set} of values that were stored in the field after the
                change.
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        self.send_chronologizeKeyRecordStartEnd(key, record, start, tend, creds, transaction, environment)
        return self.recv_chronologizeKeyRecordStartEnd()

    def send_chronologizeKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
        self._oprot.writeMessageBegin('chronologizeKeyRecordStartEnd', TMessageType.CALL, self._seqid)
        args = chronologizeKeyRecordStartEnd_args()
        args.key = key
        args.record = record
        args.start = start
        args.tend = tend
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_chronologizeKeyRecordStartEnd(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = chronologizeKeyRecordStartEnd_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecordStartEnd failed: unknown result")

    def chronologizeKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
        """
        View a time series between {@code start} (inclusive) and {@code end}
        (non-inclusive) that associates the timestamp of each modification for
        {@code key} in {@code record} to a snapshot containing the values that
        were stored in the field after the change.

        @param key the field name
        @param record the record id
        @param start the first possible {@link Timestamp} to include in the
                   time series
        @param end the {@link Timestamp} that should be greater than every
                   timestamp in the time series
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each modification timestamp to the
                {@link Set} of values that were stored in the field after the
                change.
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        self.send_chronologizeKeyRecordStartstrEndstr(key, record, start, tend, creds, transaction, environment)
        return self.recv_chronologizeKeyRecordStartstrEndstr()

    def send_chronologizeKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
        self._oprot.writeMessageBegin('chronologizeKeyRecordStartstrEndstr', TMessageType.CALL, self._seqid)
        args = chronologizeKeyRecordStartstrEndstr_args()
        args.key = key
        args.record = record
        args.start = start
        args.tend = tend
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_chronologizeKeyRecordStartstrEndstr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = chronologizeKeyRecordStartstrEndstr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecordStartstrEndstr failed: unknown result")

    def clearRecord(self, record, creds, transaction, environment):
        """
        Parameters:
         - record
         - creds
         - transaction
         - environment

        """
        self.send_clearRecord(record, creds, transaction, environment)
        self.recv_clearRecord()

    def send_clearRecord(self, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('clearRecord', TMessageType.CALL, self._seqid)
        args = clearRecord_args()
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_clearRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = clearRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        return

    def clearRecords(self, records, creds, transaction, environment):
        """
        Parameters:
         - records
         - creds
         - transaction
         - environment

        """
        self.send_clearRecords(records, creds, transaction, environment)
        self.recv_clearRecords()

    def send_clearRecords(self, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('clearRecords', TMessageType.CALL, self._seqid)
        args = clearRecords_args()
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_clearRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = clearRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        return

    def clearKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        self.send_clearKeyRecord(key, record, creds, transaction, environment)
        self.recv_clearKeyRecord()

    def send_clearKeyRecord(self, key, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('clearKeyRecord', TMessageType.CALL, self._seqid)
        args = clearKeyRecord_args()
        args.key = key
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_clearKeyRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = clearKeyRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        return

    def clearKeysRecord(self, keys, record, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - creds
         - transaction
         - environment

        """
        self.send_clearKeysRecord(keys, record, creds, transaction, environment)
        self.recv_clearKeysRecord()

    def send_clearKeysRecord(self, keys, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('clearKeysRecord', TMessageType.CALL, self._seqid)
        args = clearKeysRecord_args()
        args.keys = keys
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_clearKeysRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = clearKeysRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        return

    def clearKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        self.send_clearKeyRecords(key, records, creds, transaction, environment)
        self.recv_clearKeyRecords()

    def send_clearKeyRecords(self, key, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('clearKeyRecords', TMessageType.CALL, self._seqid)
        args = clearKeyRecords_args()
        args.key = key
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_clearKeyRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = clearKeyRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        return

    def clearKeysRecords(self, keys, records, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - creds
         - transaction
         - environment

        """
        self.send_clearKeysRecords(keys, records, creds, transaction, environment)
        self.recv_clearKeysRecords()

    def send_clearKeysRecords(self, keys, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('clearKeysRecords', TMessageType.CALL, self._seqid)
        args = clearKeysRecords_args()
        args.keys = keys
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_clearKeysRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = clearKeysRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        return

    def commit(self, creds, transaction, environment):
        """
        Attempt to permanently commit any changes that are staged in a transaction
        and return {@code true} if and only if all the changes can be applied.
        Otherwise, returns {@code false} and all the changes are discarded.
        <p>
        After returning, the driver will return to {@code autocommit} mode and
        all subsequent changes will be committed immediately.
        </p>
        <p>
        This method will return {@code false} if it is called when the driver is
        not in {@code staging} mode.
        </p>

        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return {@code true} if all staged changes are committed, otherwise {@code
                             false}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - creds
         - transaction
         - environment

        """
        self.send_commit(creds, transaction, environment)
        return self.recv_commit()

    def send_commit(self, creds, transaction, environment):
        self._oprot.writeMessageBegin('commit', TMessageType.CALL, self._seqid)
        args = commit_args()
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_commit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = commit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "commit failed: unknown result")

    def inspect(self):
        """
        List all plugins enabled in the database.

        @return the {@link Set} of plugins enabled.


        """
        self.send_inspect()
        return self.recv_inspect()

    def send_inspect(self):
        self._oprot.writeMessageBegin('inspect', TMessageType.CALL, self._seqid)
        args = inspect_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_inspect(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = inspect_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "inspect failed: unknown result")

    def describe(self, creds, transaction, environment):
        """
        List all the keys in the database.

        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return the {@link Set} of keys in the database
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - creds
         - transaction
         - environment

        """
        self.send_describe(creds, transaction, environment)
        return self.recv_describe()

    def send_describe(self, creds, transaction, environment):
        self._oprot.writeMessageBegin('describe', TMessageType.CALL, self._seqid)
        args = describe_args()
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_describe(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = describe_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "describe failed: unknown result")

    def describeTime(self, timestamp, creds, transaction, environment):
        """
        List all the keys in the database at {@code timestamp}.

        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return the {@link Set} of keys that were in the database at
                {@code timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_describeTime(timestamp, creds, transaction, environment)
        return self.recv_describeTime()

    def send_describeTime(self, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('describeTime', TMessageType.CALL, self._seqid)
        args = describeTime_args()
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_describeTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = describeTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "describeTime failed: unknown result")

    def describeTimestr(self, timestamp, creds, transaction, environment):
        """
        List all the keys in the database at {@code timestamp}.

        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return the {@link Set} of keys that were in the database at
                {@code timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_describeTimestr(timestamp, creds, transaction, environment)
        return self.recv_describeTimestr()

    def send_describeTimestr(self, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('describeTimestr', TMessageType.CALL, self._seqid)
        args = describeTimestr_args()
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_describeTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = describeTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "describeTimestr failed: unknown result")

    def describeRecord(self, record, creds, transaction, environment):
        """
        List all the keys in {@code record} that have at least one value.

        @param record the record id
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return the {@link Set} of keys in {@code record}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - record
         - creds
         - transaction
         - environment

        """
        self.send_describeRecord(record, creds, transaction, environment)
        return self.recv_describeRecord()

    def send_describeRecord(self, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('describeRecord', TMessageType.CALL, self._seqid)
        args = describeRecord_args()
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_describeRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = describeRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecord failed: unknown result")

    def describeRecordTime(self, record, timestamp, creds, transaction, environment):
        """
        List all the keys in {@code record} that had at least one value at
        {@code timestamp}.

        @param record the record id
        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return the {@link Set} of keys that were in {@code record} at
                {@code timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_describeRecordTime(record, timestamp, creds, transaction, environment)
        return self.recv_describeRecordTime()

    def send_describeRecordTime(self, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('describeRecordTime', TMessageType.CALL, self._seqid)
        args = describeRecordTime_args()
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_describeRecordTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = describeRecordTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecordTime failed: unknown result")

    def describeRecordTimestr(self, record, timestamp, creds, transaction, environment):
        """
        List all the keys in {@code record} that have at least one value.

        @param record the record id
        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return the {@link Set} of keys that were in {@code record} at
                {@code timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_describeRecordTimestr(record, timestamp, creds, transaction, environment)
        return self.recv_describeRecordTimestr()

    def send_describeRecordTimestr(self, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('describeRecordTimestr', TMessageType.CALL, self._seqid)
        args = describeRecordTimestr_args()
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_describeRecordTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = describeRecordTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecordTimestr failed: unknown result")

    def describeRecords(self, records, creds, transaction, environment):
        """
        For each of the {@code records}, list all of the keys that have at least
        one value.

        @param records a collection of record ids
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each record id to the {@link Set} of
                keys in that record
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - records
         - creds
         - transaction
         - environment

        """
        self.send_describeRecords(records, creds, transaction, environment)
        return self.recv_describeRecords()

    def send_describeRecords(self, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('describeRecords', TMessageType.CALL, self._seqid)
        args = describeRecords_args()
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_describeRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = describeRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecords failed: unknown result")

    def describeRecordsTime(self, records, timestamp, creds, transaction, environment):
        """
        For each of the {@code records}, list all the keys that had at least one
        value at {@code timestamp}.

        @param records a collection of record ids
        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each record id to the {@link Set} of
                keys that were in that record at {@code timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_describeRecordsTime(records, timestamp, creds, transaction, environment)
        return self.recv_describeRecordsTime()

    def send_describeRecordsTime(self, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('describeRecordsTime', TMessageType.CALL, self._seqid)
        args = describeRecordsTime_args()
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_describeRecordsTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = describeRecordsTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecordsTime failed: unknown result")

    def describeRecordsTimestr(self, records, timestamp, creds, transaction, environment):
        """
        For each of the {@code records}, list all the keys that had at least one
        value at {@code timestamp}.

        @param records a collection of record ids
        @param timestamp the historical timestamp to use in the lookup
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} associating each record id to the {@link Set} of
                keys that were in that record at {@code timestamp}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_describeRecordsTimestr(records, timestamp, creds, transaction, environment)
        return self.recv_describeRecordsTimestr()

    def send_describeRecordsTimestr(self, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('describeRecordsTimestr', TMessageType.CALL, self._seqid)
        args = describeRecordsTimestr_args()
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_describeRecordsTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = describeRecordsTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecordsTimestr failed: unknown result")

    def diffRecordStart(self, record, start, creds, transaction, environment):
        """
        List the net changes made to {@code record} since {@code start}.

        <p>
        If you begin with the state of the {@code record} at {@code start} and
        re-apply all the changes in the diff, you'll re-create the state of the
        {@code record} at the present.
        </p>

        @param record the record id
        @param start the base timestamp from which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates each key in the {@code record} to
                another {@link Map} that associates a {@link Diff change
                description} to the {@link Set} of values that fit the
                description (i.e. <code>
                {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
                "value4"]}}
                </code> )
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - record
         - start
         - creds
         - transaction
         - environment

        """
        self.send_diffRecordStart(record, start, creds, transaction, environment)
        return self.recv_diffRecordStart()

    def send_diffRecordStart(self, record, start, creds, transaction, environment):
        self._oprot.writeMessageBegin('diffRecordStart', TMessageType.CALL, self._seqid)
        args = diffRecordStart_args()
        args.record = record
        args.start = start
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_diffRecordStart(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = diffRecordStart_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "diffRecordStart failed: unknown result")

    def diffRecordStartstr(self, record, start, creds, transaction, environment):
        """
        List the net changes made to {@code record} since {@code start}.

        <p>
        If you begin with the state of the {@code record} at {@code start} and
        re-apply all the changes in the diff, you'll re-create the state of the
        {@code record} at the present.
        </p>

        @param record the record id
        @param start the base timestamp from which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates each key in the {@code record} to
                another {@link Map} that associates a {@link Diff change
                description} to the {@link Set} of values that fit the
                description (i.e. <code>
                {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
                "value4"]}}
                </code> )
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - record
         - start
         - creds
         - transaction
         - environment

        """
        self.send_diffRecordStartstr(record, start, creds, transaction, environment)
        return self.recv_diffRecordStartstr()

    def send_diffRecordStartstr(self, record, start, creds, transaction, environment):
        self._oprot.writeMessageBegin('diffRecordStartstr', TMessageType.CALL, self._seqid)
        args = diffRecordStartstr_args()
        args.record = record
        args.start = start
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_diffRecordStartstr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = diffRecordStartstr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "diffRecordStartstr failed: unknown result")

    def diffRecordStartEnd(self, record, start, tend, creds, transaction, environment):
        """
        List the net changes made to {@code record} from {@code start} to
        {@code end}.

        <p>
        If you begin with the state of the {@code record} at {@code start} and
        re-apply all the changes in the diff, you'll re-create the state of the
        {@code record} at {@code end}.
        </p>

        @param record the record id
        @param start the base timestamp from which the diff is calculated
        @param end the comparison timestamp to which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates each key in the {@code record} to
                another {@link Map} that associates a {@link Diff change
                description} to the {@link Set} of values that fit the
                description (i.e. <code>
                {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
                "value4"]}}
                </code> )
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        self.send_diffRecordStartEnd(record, start, tend, creds, transaction, environment)
        return self.recv_diffRecordStartEnd()

    def send_diffRecordStartEnd(self, record, start, tend, creds, transaction, environment):
        self._oprot.writeMessageBegin('diffRecordStartEnd', TMessageType.CALL, self._seqid)
        args = diffRecordStartEnd_args()
        args.record = record
        args.start = start
        args.tend = tend
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_diffRecordStartEnd(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = diffRecordStartEnd_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "diffRecordStartEnd failed: unknown result")

    def diffRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
        """
        List the net changes made to {@code record} from {@code start} to
        {@code end}.

        <p>
        If you begin with the state of the {@code record} at {@code start} and
        re-apply all the changes in the diff, you'll re-create the state of the
        {@code record} at {@code end}.
        </p>

        @param record the record id
        @param start the base timestamp from which the diff is calculated
        @param end the comparison timestamp to which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates each key in the {@code record} to
                another {@link Map} that associates a {@link Diff change
                description} to the {@link Set} of values that fit the
                description (i.e. <code>
                {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
                "value4"]}}
                </code> )
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        self.send_diffRecordStartstrEndstr(record, start, tend, creds, transaction, environment)
        return self.recv_diffRecordStartstrEndstr()

    def send_diffRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
        self._oprot.writeMessageBegin('diffRecordStartstrEndstr', TMessageType.CALL, self._seqid)
        args = diffRecordStartstrEndstr_args()
        args.record = record
        args.start = start
        args.tend = tend
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_diffRecordStartstrEndstr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = diffRecordStartstrEndstr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "diffRecordStartstrEndstr failed: unknown result")

    def diffKeyRecordStart(self, key, record, start, creds, transaction, environment):
        """
        List the net changes made to {@code key} in {@code record} since
        {@code start}.

        <p>
        If you begin with the state of the field at {@code start} and re-apply
        all the changes in the diff, you'll re-create the state of the field at
        the present.
        </p>

        @param key the field name
        @param record the record id
        @param start the base timestamp from which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates a {@link Diff change
                description} to the {@link Set} of values that fit the
                description (i.e. <code>
                {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
                </code> )
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - record
         - start
         - creds
         - transaction
         - environment

        """
        self.send_diffKeyRecordStart(key, record, start, creds, transaction, environment)
        return self.recv_diffKeyRecordStart()

    def send_diffKeyRecordStart(self, key, record, start, creds, transaction, environment):
        self._oprot.writeMessageBegin('diffKeyRecordStart', TMessageType.CALL, self._seqid)
        args = diffKeyRecordStart_args()
        args.key = key
        args.record = record
        args.start = start
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_diffKeyRecordStart(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = diffKeyRecordStart_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyRecordStart failed: unknown result")

    def diffKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
        """
        List the net changes made to {@code key} in {@code record} since
        {@code start}.

        <p>
        If you begin with the state of the field at {@code start} and re-apply
        all the changes in the diff, you'll re-create the state of the field at
        the present.
        </p>

        @param key the field name
        @param record the record id
        @param start the base timestamp from which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates a {@link Diff change
                description} to the {@link Set} of values that fit the
                description (i.e. <code>
                {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
                </code> )
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - record
         - start
         - creds
         - transaction
         - environment

        """
        self.send_diffKeyRecordStartstr(key, record, start, creds, transaction, environment)
        return self.recv_diffKeyRecordStartstr()

    def send_diffKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
        self._oprot.writeMessageBegin('diffKeyRecordStartstr', TMessageType.CALL, self._seqid)
        args = diffKeyRecordStartstr_args()
        args.key = key
        args.record = record
        args.start = start
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_diffKeyRecordStartstr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = diffKeyRecordStartstr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyRecordStartstr failed: unknown result")

    def diffKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
        """
        List the net changes made to {@code key} in {@code record} from
        {@code start} to {@code end}.

        <p>
        If you begin with the state of the field at {@code start} and re-apply
        all the changes in the diff, you'll re-create the state of the field at
        {@code end}.
        </p>

        @param key the field name
        @param record the record id
        @param start the base timestamp from which the diff is calculated
        @param end the comparison timestamp to which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates a {@link Diff change
                description} to the {@link Set} of values that fit the
                description (i.e. <code>
                {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
                </code> )
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        self.send_diffKeyRecordStartEnd(key, record, start, tend, creds, transaction, environment)
        return self.recv_diffKeyRecordStartEnd()

    def send_diffKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
        self._oprot.writeMessageBegin('diffKeyRecordStartEnd', TMessageType.CALL, self._seqid)
        args = diffKeyRecordStartEnd_args()
        args.key = key
        args.record = record
        args.start = start
        args.tend = tend
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_diffKeyRecordStartEnd(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = diffKeyRecordStartEnd_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyRecordStartEnd failed: unknown result")

    def diffKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
        """
        List the net changes made to {@code key} in {@code record} from
        {@code start} to {@code end}.

        <p>
        If you begin with the state of the field at {@code start} and re-apply
        all the changes in the diff, you'll re-create the state of the field at
        {@code end}.
        </p>

        @param key the field name
        @param record the record id
        @param start the base timestamp from which the diff is calculated
        @param end the comparison timestamp to which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates a {@link Diff change
                description} to the {@link Set} of values that fit the
                description (i.e. <code>
                {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
                </code> )
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - record
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        self.send_diffKeyRecordStartstrEndstr(key, record, start, tend, creds, transaction, environment)
        return self.recv_diffKeyRecordStartstrEndstr()

    def send_diffKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
        self._oprot.writeMessageBegin('diffKeyRecordStartstrEndstr', TMessageType.CALL, self._seqid)
        args = diffKeyRecordStartstrEndstr_args()
        args.key = key
        args.record = record
        args.start = start
        args.tend = tend
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_diffKeyRecordStartstrEndstr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = diffKeyRecordStartstrEndstr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyRecordStartstrEndstr failed: unknown result")

    def diffKeyStart(self, key, start, creds, transaction, environment):
        """
        List the net changes made to the {@code key} field across all records
        since {@code start}.

        <p>
        If you begin with the state of an inverted index for {@code key} at
        {@code start} and re-apply all the changes in the diff, you'll re-create
        the state of the same index at the present.
        </p>

        @param key the field name
        @param start the base timestamp from which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates each value stored for {@code key}
                across all records to another {@link Map} that associates a
                {@link Diff change description} to the {@link Set} of records
                where the description applies to that value in the {@code key}
                field (i.e. <code>
                {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
                </code>)
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - start
         - creds
         - transaction
         - environment

        """
        self.send_diffKeyStart(key, start, creds, transaction, environment)
        return self.recv_diffKeyStart()

    def send_diffKeyStart(self, key, start, creds, transaction, environment):
        self._oprot.writeMessageBegin('diffKeyStart', TMessageType.CALL, self._seqid)
        args = diffKeyStart_args()
        args.key = key
        args.start = start
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_diffKeyStart(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = diffKeyStart_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyStart failed: unknown result")

    def diffKeyStartstr(self, key, start, creds, transaction, environment):
        """
        List the net changes made to the {@code key} field across all records
        since {@code start}.

        <p>
        If you begin with the state of an inverted index for {@code key} at
        {@code start} and re-apply all the changes in the diff, you'll re-create
        the state of the same index at the present.
        </p>

        @param key the field name
        @param start the base timestamp from which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates each value stored for {@code key}
                across all records to another {@link Map} that associates a
                {@link Diff change description} to the {@link Set} of records
                where the description applies to that value in the {@code key}
                field (i.e. <code>
                {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
                </code>)
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - start
         - creds
         - transaction
         - environment

        """
        self.send_diffKeyStartstr(key, start, creds, transaction, environment)
        return self.recv_diffKeyStartstr()

    def send_diffKeyStartstr(self, key, start, creds, transaction, environment):
        self._oprot.writeMessageBegin('diffKeyStartstr', TMessageType.CALL, self._seqid)
        args = diffKeyStartstr_args()
        args.key = key
        args.start = start
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_diffKeyStartstr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = diffKeyStartstr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyStartstr failed: unknown result")

    def diffKeyStartEnd(self, key, start, tend, creds, transaction, environment):
        """
        List the net changes made to the {@code key} field across all records
        from {@code start} to {@code end}.

        <p>
        If you begin with the state of an inverted index for {@code key} at
        {@code start} and re-apply all the changes in the diff, you'll re-create
        the state of the same index at {@code end}.
        </p>

        @param key the field name
        @param start the base timestamp from which the diff is calculated
        @param end the comparison timestamp to which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates each value stored for {@code key}
                across all records to another {@link Map} that associates a
                {@link Diff change description} to the {@link Set} of records
                where the description applies to that value in the {@code key}
                field (i.e. <code>
                {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
                </code>)
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself

        Parameters:
         - key
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        self.send_diffKeyStartEnd(key, start, tend, creds, transaction, environment)
        return self.recv_diffKeyStartEnd()

    def send_diffKeyStartEnd(self, key, start, tend, creds, transaction, environment):
        self._oprot.writeMessageBegin('diffKeyStartEnd', TMessageType.CALL, self._seqid)
        args = diffKeyStartEnd_args()
        args.key = key
        args.start = start
        args.tend = tend
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_diffKeyStartEnd(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = diffKeyStartEnd_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyStartEnd failed: unknown result")

    def diffKeyStartstrEndstr(self, key, start, tend, creds, transaction, environment):
        """
        List the net changes made to the {@code key} field across all records
        from {@code start} to {@code end}.

        <p>
        If you begin with the state of an inverted index for {@code key} at
        {@code start} and re-apply all the changes in the diff, you'll re-create
        the state of the same index at {@code end}.
        </p>

        @param key the field name
        @param start the base timestamp from which the diff is calculated
        @param end the comparison timestamp to which the diff is calculated
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a {@link Map} that associates each value stored for {@code key}
                across all records to another {@link Map} that associates a
                {@link Diff change description} to the {@link Set} of records
                where the description applies to that value in the {@code key}
                field (i.e. <code>
                {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
                </code>)
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.ParseException if a string cannot be properly parsed
                into a timestamp

        Parameters:
         - key
         - start
         - tend
         - creds
         - transaction
         - environment

        """
        self.send_diffKeyStartstrEndstr(key, start, tend, creds, transaction, environment)
        return self.recv_diffKeyStartstrEndstr()

    def send_diffKeyStartstrEndstr(self, key, start, tend, creds, transaction, environment):
        self._oprot.writeMessageBegin('diffKeyStartstrEndstr', TMessageType.CALL, self._seqid)
        args = diffKeyStartstrEndstr_args()
        args.key = key
        args.start = start
        args.tend = tend
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_diffKeyStartstrEndstr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = diffKeyStartstrEndstr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyStartstrEndstr failed: unknown result")

    def invokePlugin(self, id, method, params, creds, transaction, environment):
        """
        Invoke a Plugin method.

        <p>
        Assuming that there is a plugin distribution that contains a class
        named after {@code id}, and has the specified {@code method}, invoke the
        same with {@code params} and return the result.
        </p>

        @param id the fully qualified name of the plugin class
        @param method the name of the method in {@code clazz} to invoke
        @param params a list of TObjects to pass to {@code method} as args
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return the result of the method invocation
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.InvalidArgumentException if any of the arguments are
                invalid

        Parameters:
         - id
         - method
         - params
         - creds
         - transaction
         - environment

        """
        self.send_invokePlugin(id, method, params, creds, transaction, environment)
        return self.recv_invokePlugin()

    def send_invokePlugin(self, id, method, params, creds, transaction, environment):
        self._oprot.writeMessageBegin('invokePlugin', TMessageType.CALL, self._seqid)
        args = invokePlugin_args()
        args.id = id
        args.method = method
        args.params = params
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_invokePlugin(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = invokePlugin_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "invokePlugin failed: unknown result")

    def login(self, username, password, environment):
        """
        Attempt to authenticate the user identified by the {@code username} and
        {@code password} combination to the specified {@code environment}. If
        successful, establish a new session within the {@code environment} on
        behalf of that user and return an {@link shared.AccessToken}, which is
        required for all subsequent operations.

        <p>
        The AccessToken <em>may</em> expire after a while so clients should be
        prepared to seamlessly login again for active user sessions.
        </p>

        @param username a binary representation of the UTF-8 encoded username
        @param password a binary representation of the UTF-8 encoded password
        @param environment the name of the environment into which to login
        @return an {@link shared.AccessToken} to submit with all subsequent method
                calls
        @throws exceptions.SecurityException if the login is not successful

        Parameters:
         - username
         - password
         - environment

        """
        self.send_login(username, password, environment)
        return self.recv_login()

    def send_login(self, username, password, environment):
        self._oprot.writeMessageBegin('login', TMessageType.CALL, self._seqid)
        args = login_args()
        args.username = username
        args.password = password
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_login(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = login_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "login failed: unknown result")

    def logout(self, token, environment):
        """
        Terminate the session within {@code environment} for the user represented
        by the {@code token}. Afterwards, all other attempts to use {@code token}
        will result in a {@link exceptions.SecurityException} being thrown.

        @param token the {@link shared.AccessToken to expire}
        @param environment the environment of the session represented by the
                           {@code token}
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session

        Parameters:
         - token
         - environment

        """
        self.send_logout(token, environment)
        self.recv_logout()

    def send_logout(self, token, environment):
        self._oprot.writeMessageBegin('logout', TMessageType.CALL, self._seqid)
        args = logout_args()
        args.token = token
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_logout(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = logout_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        return

    def stage(self, token, environment):
        """
        Start a new transaction.
        <p>
        This method will turn on STAGING mode so that all subsequent changes are
        collected in an isolated buffer before possibly being committed to the
        database. Staged operations are guaranteed to be reliable, all or nothing
        units of work that allow correct recovery from failures and provide
        isolation between clients so the database is always in a consistent state.
        </p>
        <p>
        After this method returns, all subsequent operations will be done in
        {@code staging} mode until either #abort(shared.AccessToken) or
        #commit(shared.AccessToken) is called.
        </p>

        @param token
        @param environment
        @return TransactionToken
        @throws TSecurityException

        Parameters:
         - token
         - environment

        """
        self.send_stage(token, environment)
        return self.recv_stage()

    def send_stage(self, token, environment):
        self._oprot.writeMessageBegin('stage', TMessageType.CALL, self._seqid)
        args = stage_args()
        args.token = token
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stage(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stage_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "stage failed: unknown result")

    def insertJson(self, json, creds, transaction, environment):
        """
        Parameters:
         - json
         - creds
         - transaction
         - environment

        """
        self.send_insertJson(json, creds, transaction, environment)
        return self.recv_insertJson()

    def send_insertJson(self, json, creds, transaction, environment):
        self._oprot.writeMessageBegin('insertJson', TMessageType.CALL, self._seqid)
        args = insertJson_args()
        args.json = json
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_insertJson(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = insertJson_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        if result.ex5 is not None:
            raise result.ex5
        raise TApplicationException(TApplicationException.MISSING_RESULT, "insertJson failed: unknown result")

    def insertJsonRecord(self, json, record, creds, transaction, environment):
        """
        Parameters:
         - json
         - record
         - creds
         - transaction
         - environment

        """
        self.send_insertJsonRecord(json, record, creds, transaction, environment)
        return self.recv_insertJsonRecord()

    def send_insertJsonRecord(self, json, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('insertJsonRecord', TMessageType.CALL, self._seqid)
        args = insertJsonRecord_args()
        args.json = json
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_insertJsonRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = insertJsonRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        if result.ex5 is not None:
            raise result.ex5
        raise TApplicationException(TApplicationException.MISSING_RESULT, "insertJsonRecord failed: unknown result")

    def insertJsonRecords(self, json, records, creds, transaction, environment):
        """
        Parameters:
         - json
         - records
         - creds
         - transaction
         - environment

        """
        self.send_insertJsonRecords(json, records, creds, transaction, environment)
        return self.recv_insertJsonRecords()

    def send_insertJsonRecords(self, json, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('insertJsonRecords', TMessageType.CALL, self._seqid)
        args = insertJsonRecords_args()
        args.json = json
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_insertJsonRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = insertJsonRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        if result.ex5 is not None:
            raise result.ex5
        raise TApplicationException(TApplicationException.MISSING_RESULT, "insertJsonRecords failed: unknown result")

    def removeKeyValueRecord(self, key, value, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - record
         - creds
         - transaction
         - environment

        """
        self.send_removeKeyValueRecord(key, value, record, creds, transaction, environment)
        return self.recv_removeKeyValueRecord()

    def send_removeKeyValueRecord(self, key, value, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('removeKeyValueRecord', TMessageType.CALL, self._seqid)
        args = removeKeyValueRecord_args()
        args.key = key
        args.value = value
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeKeyValueRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeKeyValueRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeKeyValueRecord failed: unknown result")

    def removeKeyValueRecords(self, key, value, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - records
         - creds
         - transaction
         - environment

        """
        self.send_removeKeyValueRecords(key, value, records, creds, transaction, environment)
        return self.recv_removeKeyValueRecords()

    def send_removeKeyValueRecords(self, key, value, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('removeKeyValueRecords', TMessageType.CALL, self._seqid)
        args = removeKeyValueRecords_args()
        args.key = key
        args.value = value
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeKeyValueRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeKeyValueRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeKeyValueRecords failed: unknown result")

    def setKeyValueRecord(self, key, value, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - record
         - creds
         - transaction
         - environment

        """
        self.send_setKeyValueRecord(key, value, record, creds, transaction, environment)
        self.recv_setKeyValueRecord()

    def send_setKeyValueRecord(self, key, value, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('setKeyValueRecord', TMessageType.CALL, self._seqid)
        args = setKeyValueRecord_args()
        args.key = key
        args.value = value
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setKeyValueRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setKeyValueRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        return

    def setKeyValue(self, key, value, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - creds
         - transaction
         - environment

        """
        self.send_setKeyValue(key, value, creds, transaction, environment)
        return self.recv_setKeyValue()

    def send_setKeyValue(self, key, value, creds, transaction, environment):
        self._oprot.writeMessageBegin('setKeyValue', TMessageType.CALL, self._seqid)
        args = setKeyValue_args()
        args.key = key
        args.value = value
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setKeyValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setKeyValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setKeyValue failed: unknown result")

    def setKeyValueRecords(self, key, value, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - records
         - creds
         - transaction
         - environment

        """
        self.send_setKeyValueRecords(key, value, records, creds, transaction, environment)
        self.recv_setKeyValueRecords()

    def send_setKeyValueRecords(self, key, value, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('setKeyValueRecords', TMessageType.CALL, self._seqid)
        args = setKeyValueRecords_args()
        args.key = key
        args.value = value
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setKeyValueRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setKeyValueRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        return

    def reconcileKeyRecordValues(self, key, record, values, creds, transaction, environment):
        """
        The {@code value} in {@code key} of {@code record} are added
        and removed to be set as exactly the same as the input values

        @param key the field name
        @param record the record id where an attempt is made to add the data
        @param values collection of values to set
        @param creds the {@link shared.AccessToken} that is used to authenticate
                       the user on behalf of whom the client is connected
        @param transaction the {@link shared.TransactionToken} that the
                             server uses to find the current transaction for the
                             client (optional)
        @param environment the environment to which the client is connected
        @return a bool that indicates if the data was added
        @throws exceptions.SecurityException if the {@code creds} don't
                represent a valid session
        @throws exceptions.TransactionException if the client was in a
                transaction and an error occurred that caused the transaction
                to end itself
        @throws exceptions.InvalidArgumentException if any of provided data
                can't be stored

        Parameters:
         - key
         - record
         - values
         - creds
         - transaction
         - environment

        """
        self.send_reconcileKeyRecordValues(key, record, values, creds, transaction, environment)
        self.recv_reconcileKeyRecordValues()

    def send_reconcileKeyRecordValues(self, key, record, values, creds, transaction, environment):
        self._oprot.writeMessageBegin('reconcileKeyRecordValues', TMessageType.CALL, self._seqid)
        args = reconcileKeyRecordValues_args()
        args.key = key
        args.record = record
        args.values = values
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_reconcileKeyRecordValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = reconcileKeyRecordValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        return

    def inventory(self, creds, transaction, environment):
        """
        Parameters:
         - creds
         - transaction
         - environment

        """
        self.send_inventory(creds, transaction, environment)
        return self.recv_inventory()

    def send_inventory(self, creds, transaction, environment):
        self._oprot.writeMessageBegin('inventory', TMessageType.CALL, self._seqid)
        args = inventory_args()
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_inventory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = inventory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "inventory failed: unknown result")

    def selectRecord(self, record, creds, transaction, environment):
        """
        Parameters:
         - record
         - creds
         - transaction
         - environment

        """
        self.send_selectRecord(record, creds, transaction, environment)
        return self.recv_selectRecord()

    def send_selectRecord(self, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectRecord', TMessageType.CALL, self._seqid)
        args = selectRecord_args()
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecord failed: unknown result")

    def selectRecords(self, records, creds, transaction, environment):
        """
        Parameters:
         - records
         - creds
         - transaction
         - environment

        """
        self.send_selectRecords(records, creds, transaction, environment)
        return self.recv_selectRecords()

    def send_selectRecords(self, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectRecords', TMessageType.CALL, self._seqid)
        args = selectRecords_args()
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecords failed: unknown result")

    def selectRecordTime(self, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectRecordTime(record, timestamp, creds, transaction, environment)
        return self.recv_selectRecordTime()

    def send_selectRecordTime(self, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectRecordTime', TMessageType.CALL, self._seqid)
        args = selectRecordTime_args()
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectRecordTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectRecordTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecordTime failed: unknown result")

    def selectRecordTimestr(self, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectRecordTimestr(record, timestamp, creds, transaction, environment)
        return self.recv_selectRecordTimestr()

    def send_selectRecordTimestr(self, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectRecordTimestr', TMessageType.CALL, self._seqid)
        args = selectRecordTimestr_args()
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectRecordTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectRecordTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecordTimestr failed: unknown result")

    def selectRecordsTime(self, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectRecordsTime(records, timestamp, creds, transaction, environment)
        return self.recv_selectRecordsTime()

    def send_selectRecordsTime(self, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectRecordsTime', TMessageType.CALL, self._seqid)
        args = selectRecordsTime_args()
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectRecordsTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectRecordsTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecordsTime failed: unknown result")

    def selectRecordsTimestr(self, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectRecordsTimestr(records, timestamp, creds, transaction, environment)
        return self.recv_selectRecordsTimestr()

    def send_selectRecordsTimestr(self, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectRecordsTimestr', TMessageType.CALL, self._seqid)
        args = selectRecordsTimestr_args()
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectRecordsTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectRecordsTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecordsTimestr failed: unknown result")

    def selectKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        self.send_selectKeyRecord(key, record, creds, transaction, environment)
        return self.recv_selectKeyRecord()

    def send_selectKeyRecord(self, key, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeyRecord', TMessageType.CALL, self._seqid)
        args = selectKeyRecord_args()
        args.key = key
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeyRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeyRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecord failed: unknown result")

    def selectKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectKeyRecordTime(key, record, timestamp, creds, transaction, environment)
        return self.recv_selectKeyRecordTime()

    def send_selectKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeyRecordTime', TMessageType.CALL, self._seqid)
        args = selectKeyRecordTime_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeyRecordTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeyRecordTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecordTime failed: unknown result")

    def selectKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
        return self.recv_selectKeyRecordTimestr()

    def send_selectKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeyRecordTimestr', TMessageType.CALL, self._seqid)
        args = selectKeyRecordTimestr_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeyRecordTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeyRecordTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecordTimestr failed: unknown result")

    def selectKeysRecord(self, keys, record, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - creds
         - transaction
         - environment

        """
        self.send_selectKeysRecord(keys, record, creds, transaction, environment)
        return self.recv_selectKeysRecord()

    def send_selectKeysRecord(self, keys, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeysRecord', TMessageType.CALL, self._seqid)
        args = selectKeysRecord_args()
        args.keys = keys
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeysRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeysRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecord failed: unknown result")

    def selectKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectKeysRecordTime(keys, record, timestamp, creds, transaction, environment)
        return self.recv_selectKeysRecordTime()

    def send_selectKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeysRecordTime', TMessageType.CALL, self._seqid)
        args = selectKeysRecordTime_args()
        args.keys = keys
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeysRecordTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeysRecordTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecordTime failed: unknown result")

    def selectKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectKeysRecordTimestr(keys, record, timestamp, creds, transaction, environment)
        return self.recv_selectKeysRecordTimestr()

    def send_selectKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeysRecordTimestr', TMessageType.CALL, self._seqid)
        args = selectKeysRecordTimestr_args()
        args.keys = keys
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeysRecordTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeysRecordTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecordTimestr failed: unknown result")

    def selectKeysRecords(self, keys, records, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - creds
         - transaction
         - environment

        """
        self.send_selectKeysRecords(keys, records, creds, transaction, environment)
        return self.recv_selectKeysRecords()

    def send_selectKeysRecords(self, keys, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeysRecords', TMessageType.CALL, self._seqid)
        args = selectKeysRecords_args()
        args.keys = keys
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeysRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeysRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecords failed: unknown result")

    def selectKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        self.send_selectKeyRecords(key, records, creds, transaction, environment)
        return self.recv_selectKeyRecords()

    def send_selectKeyRecords(self, key, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeyRecords', TMessageType.CALL, self._seqid)
        args = selectKeyRecords_args()
        args.key = key
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeyRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeyRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecords failed: unknown result")

    def selectKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
        return self.recv_selectKeyRecordsTime()

    def send_selectKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeyRecordsTime', TMessageType.CALL, self._seqid)
        args = selectKeyRecordsTime_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeyRecordsTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeyRecordsTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecordsTime failed: unknown result")

    def selectKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
        return self.recv_selectKeyRecordsTimestr()

    def send_selectKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeyRecordsTimestr', TMessageType.CALL, self._seqid)
        args = selectKeyRecordsTimestr_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeyRecordsTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeyRecordsTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecordsTimestr failed: unknown result")

    def selectKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectKeysRecordsTime(keys, records, timestamp, creds, transaction, environment)
        return self.recv_selectKeysRecordsTime()

    def send_selectKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeysRecordsTime', TMessageType.CALL, self._seqid)
        args = selectKeysRecordsTime_args()
        args.keys = keys
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeysRecordsTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeysRecordsTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecordsTime failed: unknown result")

    def selectKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectKeysRecordsTimestr(keys, records, timestamp, creds, transaction, environment)
        return self.recv_selectKeysRecordsTimestr()

    def send_selectKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeysRecordsTimestr', TMessageType.CALL, self._seqid)
        args = selectKeysRecordsTimestr_args()
        args.keys = keys
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeysRecordsTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeysRecordsTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecordsTimestr failed: unknown result")

    def selectCriteria(self, criteria, creds, transaction, environment):
        """
        Parameters:
         - criteria
         - creds
         - transaction
         - environment

        """
        self.send_selectCriteria(criteria, creds, transaction, environment)
        return self.recv_selectCriteria()

    def send_selectCriteria(self, criteria, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectCriteria', TMessageType.CALL, self._seqid)
        args = selectCriteria_args()
        args.criteria = criteria
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCriteria failed: unknown result")

    def selectCcl(self, ccl, creds, transaction, environment):
        """
        Parameters:
         - ccl
         - creds
         - transaction
         - environment

        """
        self.send_selectCcl(ccl, creds, transaction, environment)
        return self.recv_selectCcl()

    def send_selectCcl(self, ccl, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectCcl', TMessageType.CALL, self._seqid)
        args = selectCcl_args()
        args.ccl = ccl
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectCcl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectCcl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCcl failed: unknown result")

    def selectCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectCriteriaTime(criteria, timestamp, creds, transaction, environment)
        return self.recv_selectCriteriaTime()

    def send_selectCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectCriteriaTime', TMessageType.CALL, self._seqid)
        args = selectCriteriaTime_args()
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectCriteriaTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectCriteriaTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCriteriaTime failed: unknown result")

    def selectCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectCriteriaTimestr(criteria, timestamp, creds, transaction, environment)
        return self.recv_selectCriteriaTimestr()

    def send_selectCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectCriteriaTimestr', TMessageType.CALL, self._seqid)
        args = selectCriteriaTimestr_args()
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectCriteriaTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectCriteriaTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCriteriaTimestr failed: unknown result")

    def selectCclTime(self, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectCclTime(ccl, timestamp, creds, transaction, environment)
        return self.recv_selectCclTime()

    def send_selectCclTime(self, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectCclTime', TMessageType.CALL, self._seqid)
        args = selectCclTime_args()
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectCclTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectCclTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCclTime failed: unknown result")

    def selectCclTimestr(self, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectCclTimestr(ccl, timestamp, creds, transaction, environment)
        return self.recv_selectCclTimestr()

    def send_selectCclTimestr(self, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectCclTimestr', TMessageType.CALL, self._seqid)
        args = selectCclTimestr_args()
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectCclTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectCclTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCclTimestr failed: unknown result")

    def selectKeyCriteria(self, key, criteria, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - creds
         - transaction
         - environment

        """
        self.send_selectKeyCriteria(key, criteria, creds, transaction, environment)
        return self.recv_selectKeyCriteria()

    def send_selectKeyCriteria(self, key, criteria, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeyCriteria', TMessageType.CALL, self._seqid)
        args = selectKeyCriteria_args()
        args.key = key
        args.criteria = criteria
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeyCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeyCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCriteria failed: unknown result")

    def selectKeyCcl(self, key, ccl, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - creds
         - transaction
         - environment

        """
        self.send_selectKeyCcl(key, ccl, creds, transaction, environment)
        return self.recv_selectKeyCcl()

    def send_selectKeyCcl(self, key, ccl, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeyCcl', TMessageType.CALL, self._seqid)
        args = selectKeyCcl_args()
        args.key = key
        args.ccl = ccl
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeyCcl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeyCcl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCcl failed: unknown result")

    def selectKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
        return self.recv_selectKeyCriteriaTime()

    def send_selectKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeyCriteriaTime', TMessageType.CALL, self._seqid)
        args = selectKeyCriteriaTime_args()
        args.key = key
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeyCriteriaTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeyCriteriaTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCriteriaTime failed: unknown result")

    def selectKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
        return self.recv_selectKeyCriteriaTimestr()

    def send_selectKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
        args = selectKeyCriteriaTimestr_args()
        args.key = key
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeyCriteriaTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeyCriteriaTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCriteriaTimestr failed: unknown result")

    def selectKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
        return self.recv_selectKeyCclTime()

    def send_selectKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeyCclTime', TMessageType.CALL, self._seqid)
        args = selectKeyCclTime_args()
        args.key = key
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeyCclTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeyCclTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCclTime failed: unknown result")

    def selectKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
        return self.recv_selectKeyCclTimestr()

    def send_selectKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeyCclTimestr', TMessageType.CALL, self._seqid)
        args = selectKeyCclTimestr_args()
        args.key = key
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeyCclTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeyCclTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCclTimestr failed: unknown result")

    def selectKeysCriteria(self, keys, criteria, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - creds
         - transaction
         - environment

        """
        self.send_selectKeysCriteria(keys, criteria, creds, transaction, environment)
        return self.recv_selectKeysCriteria()

    def send_selectKeysCriteria(self, keys, criteria, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeysCriteria', TMessageType.CALL, self._seqid)
        args = selectKeysCriteria_args()
        args.keys = keys
        args.criteria = criteria
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeysCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeysCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCriteria failed: unknown result")

    def selectKeysCcl(self, keys, ccl, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - creds
         - transaction
         - environment

        """
        self.send_selectKeysCcl(keys, ccl, creds, transaction, environment)
        return self.recv_selectKeysCcl()

    def send_selectKeysCcl(self, keys, ccl, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeysCcl', TMessageType.CALL, self._seqid)
        args = selectKeysCcl_args()
        args.keys = keys
        args.ccl = ccl
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeysCcl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeysCcl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCcl failed: unknown result")

    def selectKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectKeysCriteriaTime(keys, criteria, timestamp, creds, transaction, environment)
        return self.recv_selectKeysCriteriaTime()

    def send_selectKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeysCriteriaTime', TMessageType.CALL, self._seqid)
        args = selectKeysCriteriaTime_args()
        args.keys = keys
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeysCriteriaTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeysCriteriaTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCriteriaTime failed: unknown result")

    def selectKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectKeysCriteriaTimestr(keys, criteria, timestamp, creds, transaction, environment)
        return self.recv_selectKeysCriteriaTimestr()

    def send_selectKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeysCriteriaTimestr', TMessageType.CALL, self._seqid)
        args = selectKeysCriteriaTimestr_args()
        args.keys = keys
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeysCriteriaTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeysCriteriaTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCriteriaTimestr failed: unknown result")

    def selectKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectKeysCclTime(keys, ccl, timestamp, creds, transaction, environment)
        return self.recv_selectKeysCclTime()

    def send_selectKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeysCclTime', TMessageType.CALL, self._seqid)
        args = selectKeysCclTime_args()
        args.keys = keys
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeysCclTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeysCclTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCclTime failed: unknown result")

    def selectKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_selectKeysCclTimestr(keys, ccl, timestamp, creds, transaction, environment)
        return self.recv_selectKeysCclTimestr()

    def send_selectKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('selectKeysCclTimestr', TMessageType.CALL, self._seqid)
        args = selectKeysCclTimestr_args()
        args.keys = keys
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_selectKeysCclTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = selectKeysCclTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCclTimestr failed: unknown result")

    def getKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        self.send_getKeyRecord(key, record, creds, transaction, environment)
        return self.recv_getKeyRecord()

    def send_getKeyRecord(self, key, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeyRecord', TMessageType.CALL, self._seqid)
        args = getKeyRecord_args()
        args.key = key
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeyRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeyRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecord failed: unknown result")

    def getKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getKeyRecordTime(key, record, timestamp, creds, transaction, environment)
        return self.recv_getKeyRecordTime()

    def send_getKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeyRecordTime', TMessageType.CALL, self._seqid)
        args = getKeyRecordTime_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeyRecordTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeyRecordTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecordTime failed: unknown result")

    def getKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
        return self.recv_getKeyRecordTimestr()

    def send_getKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeyRecordTimestr', TMessageType.CALL, self._seqid)
        args = getKeyRecordTimestr_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeyRecordTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeyRecordTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecordTimestr failed: unknown result")

    def getKeysRecord(self, keys, record, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - creds
         - transaction
         - environment

        """
        self.send_getKeysRecord(keys, record, creds, transaction, environment)
        return self.recv_getKeysRecord()

    def send_getKeysRecord(self, keys, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeysRecord', TMessageType.CALL, self._seqid)
        args = getKeysRecord_args()
        args.keys = keys
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeysRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeysRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecord failed: unknown result")

    def getKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getKeysRecordTime(keys, record, timestamp, creds, transaction, environment)
        return self.recv_getKeysRecordTime()

    def send_getKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeysRecordTime', TMessageType.CALL, self._seqid)
        args = getKeysRecordTime_args()
        args.keys = keys
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeysRecordTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeysRecordTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecordTime failed: unknown result")

    def getKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getKeysRecordTimestr(keys, record, timestamp, creds, transaction, environment)
        return self.recv_getKeysRecordTimestr()

    def send_getKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeysRecordTimestr', TMessageType.CALL, self._seqid)
        args = getKeysRecordTimestr_args()
        args.keys = keys
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeysRecordTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeysRecordTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecordTimestr failed: unknown result")

    def getKeysRecords(self, keys, records, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - creds
         - transaction
         - environment

        """
        self.send_getKeysRecords(keys, records, creds, transaction, environment)
        return self.recv_getKeysRecords()

    def send_getKeysRecords(self, keys, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeysRecords', TMessageType.CALL, self._seqid)
        args = getKeysRecords_args()
        args.keys = keys
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeysRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeysRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecords failed: unknown result")

    def getKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        self.send_getKeyRecords(key, records, creds, transaction, environment)
        return self.recv_getKeyRecords()

    def send_getKeyRecords(self, key, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeyRecords', TMessageType.CALL, self._seqid)
        args = getKeyRecords_args()
        args.key = key
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeyRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeyRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecords failed: unknown result")

    def getKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
        return self.recv_getKeyRecordsTime()

    def send_getKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeyRecordsTime', TMessageType.CALL, self._seqid)
        args = getKeyRecordsTime_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeyRecordsTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeyRecordsTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecordsTime failed: unknown result")

    def getKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
        return self.recv_getKeyRecordsTimestr()

    def send_getKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeyRecordsTimestr', TMessageType.CALL, self._seqid)
        args = getKeyRecordsTimestr_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeyRecordsTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeyRecordsTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecordsTimestr failed: unknown result")

    def getKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getKeysRecordsTime(keys, records, timestamp, creds, transaction, environment)
        return self.recv_getKeysRecordsTime()

    def send_getKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeysRecordsTime', TMessageType.CALL, self._seqid)
        args = getKeysRecordsTime_args()
        args.keys = keys
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeysRecordsTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeysRecordsTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecordsTime failed: unknown result")

    def getKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getKeysRecordsTimestr(keys, records, timestamp, creds, transaction, environment)
        return self.recv_getKeysRecordsTimestr()

    def send_getKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeysRecordsTimestr', TMessageType.CALL, self._seqid)
        args = getKeysRecordsTimestr_args()
        args.keys = keys
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeysRecordsTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeysRecordsTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecordsTimestr failed: unknown result")

    def getKeyCriteria(self, key, criteria, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - creds
         - transaction
         - environment

        """
        self.send_getKeyCriteria(key, criteria, creds, transaction, environment)
        return self.recv_getKeyCriteria()

    def send_getKeyCriteria(self, key, criteria, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeyCriteria', TMessageType.CALL, self._seqid)
        args = getKeyCriteria_args()
        args.key = key
        args.criteria = criteria
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeyCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeyCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCriteria failed: unknown result")

    def getCriteria(self, criteria, creds, transaction, environment):
        """
        Parameters:
         - criteria
         - creds
         - transaction
         - environment

        """
        self.send_getCriteria(criteria, creds, transaction, environment)
        return self.recv_getCriteria()

    def send_getCriteria(self, criteria, creds, transaction, environment):
        self._oprot.writeMessageBegin('getCriteria', TMessageType.CALL, self._seqid)
        args = getCriteria_args()
        args.criteria = criteria
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCriteria failed: unknown result")

    def getCcl(self, ccl, creds, transaction, environment):
        """
        Parameters:
         - ccl
         - creds
         - transaction
         - environment

        """
        self.send_getCcl(ccl, creds, transaction, environment)
        return self.recv_getCcl()

    def send_getCcl(self, ccl, creds, transaction, environment):
        self._oprot.writeMessageBegin('getCcl', TMessageType.CALL, self._seqid)
        args = getCcl_args()
        args.ccl = ccl
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCcl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCcl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCcl failed: unknown result")

    def getCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getCriteriaTime(criteria, timestamp, creds, transaction, environment)
        return self.recv_getCriteriaTime()

    def send_getCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getCriteriaTime', TMessageType.CALL, self._seqid)
        args = getCriteriaTime_args()
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCriteriaTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCriteriaTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCriteriaTime failed: unknown result")

    def getCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getCriteriaTimestr(criteria, timestamp, creds, transaction, environment)
        return self.recv_getCriteriaTimestr()

    def send_getCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getCriteriaTimestr', TMessageType.CALL, self._seqid)
        args = getCriteriaTimestr_args()
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCriteriaTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCriteriaTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCriteriaTimestr failed: unknown result")

    def getCclTime(self, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getCclTime(ccl, timestamp, creds, transaction, environment)
        return self.recv_getCclTime()

    def send_getCclTime(self, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getCclTime', TMessageType.CALL, self._seqid)
        args = getCclTime_args()
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCclTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCclTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCclTime failed: unknown result")

    def getCclTimestr(self, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getCclTimestr(ccl, timestamp, creds, transaction, environment)
        return self.recv_getCclTimestr()

    def send_getCclTimestr(self, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getCclTimestr', TMessageType.CALL, self._seqid)
        args = getCclTimestr_args()
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCclTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCclTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCclTimestr failed: unknown result")

    def getKeyCcl(self, key, ccl, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - creds
         - transaction
         - environment

        """
        self.send_getKeyCcl(key, ccl, creds, transaction, environment)
        return self.recv_getKeyCcl()

    def send_getKeyCcl(self, key, ccl, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeyCcl', TMessageType.CALL, self._seqid)
        args = getKeyCcl_args()
        args.key = key
        args.ccl = ccl
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeyCcl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeyCcl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCcl failed: unknown result")

    def getKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
        return self.recv_getKeyCriteriaTime()

    def send_getKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeyCriteriaTime', TMessageType.CALL, self._seqid)
        args = getKeyCriteriaTime_args()
        args.key = key
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeyCriteriaTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeyCriteriaTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCriteriaTime failed: unknown result")

    def getKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
        return self.recv_getKeyCriteriaTimestr()

    def send_getKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
        args = getKeyCriteriaTimestr_args()
        args.key = key
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeyCriteriaTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeyCriteriaTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCriteriaTimestr failed: unknown result")

    def getKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
        return self.recv_getKeyCclTime()

    def send_getKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeyCclTime', TMessageType.CALL, self._seqid)
        args = getKeyCclTime_args()
        args.key = key
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeyCclTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeyCclTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCclTime failed: unknown result")

    def getKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
        return self.recv_getKeyCclTimestr()

    def send_getKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeyCclTimestr', TMessageType.CALL, self._seqid)
        args = getKeyCclTimestr_args()
        args.key = key
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeyCclTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeyCclTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCclTimestr failed: unknown result")

    def getKeysCriteria(self, keys, criteria, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - creds
         - transaction
         - environment

        """
        self.send_getKeysCriteria(keys, criteria, creds, transaction, environment)
        return self.recv_getKeysCriteria()

    def send_getKeysCriteria(self, keys, criteria, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeysCriteria', TMessageType.CALL, self._seqid)
        args = getKeysCriteria_args()
        args.keys = keys
        args.criteria = criteria
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeysCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeysCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCriteria failed: unknown result")

    def getKeysCcl(self, keys, ccl, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - creds
         - transaction
         - environment

        """
        self.send_getKeysCcl(keys, ccl, creds, transaction, environment)
        return self.recv_getKeysCcl()

    def send_getKeysCcl(self, keys, ccl, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeysCcl', TMessageType.CALL, self._seqid)
        args = getKeysCcl_args()
        args.keys = keys
        args.ccl = ccl
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeysCcl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeysCcl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCcl failed: unknown result")

    def getKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getKeysCriteriaTime(keys, criteria, timestamp, creds, transaction, environment)
        return self.recv_getKeysCriteriaTime()

    def send_getKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeysCriteriaTime', TMessageType.CALL, self._seqid)
        args = getKeysCriteriaTime_args()
        args.keys = keys
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeysCriteriaTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeysCriteriaTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCriteriaTime failed: unknown result")

    def getKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getKeysCriteriaTimestr(keys, criteria, timestamp, creds, transaction, environment)
        return self.recv_getKeysCriteriaTimestr()

    def send_getKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeysCriteriaTimestr', TMessageType.CALL, self._seqid)
        args = getKeysCriteriaTimestr_args()
        args.keys = keys
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeysCriteriaTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeysCriteriaTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCriteriaTimestr failed: unknown result")

    def getKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getKeysCclTime(keys, ccl, timestamp, creds, transaction, environment)
        return self.recv_getKeysCclTime()

    def send_getKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeysCclTime', TMessageType.CALL, self._seqid)
        args = getKeysCclTime_args()
        args.keys = keys
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeysCclTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeysCclTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCclTime failed: unknown result")

    def getKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_getKeysCclTimestr(keys, ccl, timestamp, creds, transaction, environment)
        return self.recv_getKeysCclTimestr()

    def send_getKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('getKeysCclTimestr', TMessageType.CALL, self._seqid)
        args = getKeysCclTimestr_args()
        args.keys = keys
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getKeysCclTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getKeysCclTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCclTimestr failed: unknown result")

    def verifyKeyValueRecord(self, key, value, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - record
         - creds
         - transaction
         - environment

        """
        self.send_verifyKeyValueRecord(key, value, record, creds, transaction, environment)
        return self.recv_verifyKeyValueRecord()

    def send_verifyKeyValueRecord(self, key, value, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('verifyKeyValueRecord', TMessageType.CALL, self._seqid)
        args = verifyKeyValueRecord_args()
        args.key = key
        args.value = value
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_verifyKeyValueRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = verifyKeyValueRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyKeyValueRecord failed: unknown result")

    def verifyKeyValueRecordTime(self, key, value, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_verifyKeyValueRecordTime(key, value, record, timestamp, creds, transaction, environment)
        return self.recv_verifyKeyValueRecordTime()

    def send_verifyKeyValueRecordTime(self, key, value, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('verifyKeyValueRecordTime', TMessageType.CALL, self._seqid)
        args = verifyKeyValueRecordTime_args()
        args.key = key
        args.value = value
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_verifyKeyValueRecordTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = verifyKeyValueRecordTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyKeyValueRecordTime failed: unknown result")

    def verifyKeyValueRecordTimestr(self, key, value, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_verifyKeyValueRecordTimestr(key, value, record, timestamp, creds, transaction, environment)
        return self.recv_verifyKeyValueRecordTimestr()

    def send_verifyKeyValueRecordTimestr(self, key, value, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('verifyKeyValueRecordTimestr', TMessageType.CALL, self._seqid)
        args = verifyKeyValueRecordTimestr_args()
        args.key = key
        args.value = value
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_verifyKeyValueRecordTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = verifyKeyValueRecordTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyKeyValueRecordTimestr failed: unknown result")

    def jsonifyRecords(self, records, identifier, creds, transaction, environment):
        """
        Parameters:
         - records
         - identifier
         - creds
         - transaction
         - environment

        """
        self.send_jsonifyRecords(records, identifier, creds, transaction, environment)
        return self.recv_jsonifyRecords()

    def send_jsonifyRecords(self, records, identifier, creds, transaction, environment):
        self._oprot.writeMessageBegin('jsonifyRecords', TMessageType.CALL, self._seqid)
        args = jsonifyRecords_args()
        args.records = records
        args.identifier = identifier
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_jsonifyRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = jsonifyRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "jsonifyRecords failed: unknown result")

    def jsonifyRecordsTime(self, records, timestamp, identifier, creds, transaction, environment):
        """
        Parameters:
         - records
         - timestamp
         - identifier
         - creds
         - transaction
         - environment

        """
        self.send_jsonifyRecordsTime(records, timestamp, identifier, creds, transaction, environment)
        return self.recv_jsonifyRecordsTime()

    def send_jsonifyRecordsTime(self, records, timestamp, identifier, creds, transaction, environment):
        self._oprot.writeMessageBegin('jsonifyRecordsTime', TMessageType.CALL, self._seqid)
        args = jsonifyRecordsTime_args()
        args.records = records
        args.timestamp = timestamp
        args.identifier = identifier
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_jsonifyRecordsTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = jsonifyRecordsTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "jsonifyRecordsTime failed: unknown result")

    def jsonifyRecordsTimestr(self, records, timestamp, identifier, creds, transaction, environment):
        """
        Parameters:
         - records
         - timestamp
         - identifier
         - creds
         - transaction
         - environment

        """
        self.send_jsonifyRecordsTimestr(records, timestamp, identifier, creds, transaction, environment)
        return self.recv_jsonifyRecordsTimestr()

    def send_jsonifyRecordsTimestr(self, records, timestamp, identifier, creds, transaction, environment):
        self._oprot.writeMessageBegin('jsonifyRecordsTimestr', TMessageType.CALL, self._seqid)
        args = jsonifyRecordsTimestr_args()
        args.records = records
        args.timestamp = timestamp
        args.identifier = identifier
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_jsonifyRecordsTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = jsonifyRecordsTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "jsonifyRecordsTimestr failed: unknown result")

    def findCriteria(self, criteria, creds, transaction, environment):
        """
        Parameters:
         - criteria
         - creds
         - transaction
         - environment

        """
        self.send_findCriteria(criteria, creds, transaction, environment)
        return self.recv_findCriteria()

    def send_findCriteria(self, criteria, creds, transaction, environment):
        self._oprot.writeMessageBegin('findCriteria', TMessageType.CALL, self._seqid)
        args = findCriteria_args()
        args.criteria = criteria
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findCriteria failed: unknown result")

    def findCcl(self, ccl, creds, transaction, environment):
        """
        Parameters:
         - ccl
         - creds
         - transaction
         - environment

        """
        self.send_findCcl(ccl, creds, transaction, environment)
        return self.recv_findCcl()

    def send_findCcl(self, ccl, creds, transaction, environment):
        self._oprot.writeMessageBegin('findCcl', TMessageType.CALL, self._seqid)
        args = findCcl_args()
        args.ccl = ccl
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findCcl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findCcl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findCcl failed: unknown result")

    def findKeyOperatorValues(self, key, operator, values, creds, transaction, environment):
        """
        Parameters:
         - key
         - operator
         - values
         - creds
         - transaction
         - environment

        """
        self.send_findKeyOperatorValues(key, operator, values, creds, transaction, environment)
        return self.recv_findKeyOperatorValues()

    def send_findKeyOperatorValues(self, key, operator, values, creds, transaction, environment):
        self._oprot.writeMessageBegin('findKeyOperatorValues', TMessageType.CALL, self._seqid)
        args = findKeyOperatorValues_args()
        args.key = key
        args.operator = operator
        args.values = values
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findKeyOperatorValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findKeyOperatorValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorValues failed: unknown result")

    def findKeyOperatorValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - operator
         - values
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_findKeyOperatorValuesTime(key, operator, values, timestamp, creds, transaction, environment)
        return self.recv_findKeyOperatorValuesTime()

    def send_findKeyOperatorValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('findKeyOperatorValuesTime', TMessageType.CALL, self._seqid)
        args = findKeyOperatorValuesTime_args()
        args.key = key
        args.operator = operator
        args.values = values
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findKeyOperatorValuesTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findKeyOperatorValuesTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorValuesTime failed: unknown result")

    def findKeyOperatorValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - operator
         - values
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_findKeyOperatorValuesTimestr(key, operator, values, timestamp, creds, transaction, environment)
        return self.recv_findKeyOperatorValuesTimestr()

    def send_findKeyOperatorValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('findKeyOperatorValuesTimestr', TMessageType.CALL, self._seqid)
        args = findKeyOperatorValuesTimestr_args()
        args.key = key
        args.operator = operator
        args.values = values
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findKeyOperatorValuesTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findKeyOperatorValuesTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorValuesTimestr failed: unknown result")

    def findKeyOperatorstrValues(self, key, operator, values, creds, transaction, environment):
        """
        Parameters:
         - key
         - operator
         - values
         - creds
         - transaction
         - environment

        """
        self.send_findKeyOperatorstrValues(key, operator, values, creds, transaction, environment)
        return self.recv_findKeyOperatorstrValues()

    def send_findKeyOperatorstrValues(self, key, operator, values, creds, transaction, environment):
        self._oprot.writeMessageBegin('findKeyOperatorstrValues', TMessageType.CALL, self._seqid)
        args = findKeyOperatorstrValues_args()
        args.key = key
        args.operator = operator
        args.values = values
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findKeyOperatorstrValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findKeyOperatorstrValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorstrValues failed: unknown result")

    def findKeyOperatorstrValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - operator
         - values
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_findKeyOperatorstrValuesTime(key, operator, values, timestamp, creds, transaction, environment)
        return self.recv_findKeyOperatorstrValuesTime()

    def send_findKeyOperatorstrValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('findKeyOperatorstrValuesTime', TMessageType.CALL, self._seqid)
        args = findKeyOperatorstrValuesTime_args()
        args.key = key
        args.operator = operator
        args.values = values
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findKeyOperatorstrValuesTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findKeyOperatorstrValuesTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorstrValuesTime failed: unknown result")

    def findKeyOperatorstrValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - operator
         - values
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_findKeyOperatorstrValuesTimestr(key, operator, values, timestamp, creds, transaction, environment)
        return self.recv_findKeyOperatorstrValuesTimestr()

    def send_findKeyOperatorstrValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('findKeyOperatorstrValuesTimestr', TMessageType.CALL, self._seqid)
        args = findKeyOperatorstrValuesTimestr_args()
        args.key = key
        args.operator = operator
        args.values = values
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findKeyOperatorstrValuesTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findKeyOperatorstrValuesTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorstrValuesTimestr failed: unknown result")

    def search(self, key, query, creds, transaction, environment):
        """
        Parameters:
         - key
         - query
         - creds
         - transaction
         - environment

        """
        self.send_search(key, query, creds, transaction, environment)
        return self.recv_search()

    def send_search(self, key, query, creds, transaction, environment):
        self._oprot.writeMessageBegin('search', TMessageType.CALL, self._seqid)
        args = search_args()
        args.key = key
        args.query = query
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_search(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = search_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "search failed: unknown result")

    def revertKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_revertKeysRecordsTime(keys, records, timestamp, creds, transaction, environment)
        self.recv_revertKeysRecordsTime()

    def send_revertKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('revertKeysRecordsTime', TMessageType.CALL, self._seqid)
        args = revertKeysRecordsTime_args()
        args.keys = keys
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revertKeysRecordsTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revertKeysRecordsTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        return

    def revertKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_revertKeysRecordsTimestr(keys, records, timestamp, creds, transaction, environment)
        self.recv_revertKeysRecordsTimestr()

    def send_revertKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('revertKeysRecordsTimestr', TMessageType.CALL, self._seqid)
        args = revertKeysRecordsTimestr_args()
        args.keys = keys
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revertKeysRecordsTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revertKeysRecordsTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        return

    def revertKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_revertKeysRecordTime(keys, record, timestamp, creds, transaction, environment)
        self.recv_revertKeysRecordTime()

    def send_revertKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('revertKeysRecordTime', TMessageType.CALL, self._seqid)
        args = revertKeysRecordTime_args()
        args.keys = keys
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revertKeysRecordTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revertKeysRecordTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        return

    def revertKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_revertKeysRecordTimestr(keys, record, timestamp, creds, transaction, environment)
        self.recv_revertKeysRecordTimestr()

    def send_revertKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('revertKeysRecordTimestr', TMessageType.CALL, self._seqid)
        args = revertKeysRecordTimestr_args()
        args.keys = keys
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revertKeysRecordTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revertKeysRecordTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        return

    def revertKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_revertKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
        self.recv_revertKeyRecordsTime()

    def send_revertKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('revertKeyRecordsTime', TMessageType.CALL, self._seqid)
        args = revertKeyRecordsTime_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revertKeyRecordsTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revertKeyRecordsTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        return

    def revertKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_revertKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
        self.recv_revertKeyRecordsTimestr()

    def send_revertKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('revertKeyRecordsTimestr', TMessageType.CALL, self._seqid)
        args = revertKeyRecordsTimestr_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revertKeyRecordsTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revertKeyRecordsTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        return

    def revertKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_revertKeyRecordTime(key, record, timestamp, creds, transaction, environment)
        self.recv_revertKeyRecordTime()

    def send_revertKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('revertKeyRecordTime', TMessageType.CALL, self._seqid)
        args = revertKeyRecordTime_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revertKeyRecordTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revertKeyRecordTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        return

    def revertKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_revertKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
        self.recv_revertKeyRecordTimestr()

    def send_revertKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('revertKeyRecordTimestr', TMessageType.CALL, self._seqid)
        args = revertKeyRecordTimestr_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revertKeyRecordTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revertKeyRecordTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        return

    def pingRecords(self, records, creds, transaction, environment):
        """
        Parameters:
         - records
         - creds
         - transaction
         - environment

        """
        self.send_pingRecords(records, creds, transaction, environment)
        return self.recv_pingRecords()

    def send_pingRecords(self, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('pingRecords', TMessageType.CALL, self._seqid)
        args = pingRecords_args()
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pingRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pingRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pingRecords failed: unknown result")

    def pingRecord(self, record, creds, transaction, environment):
        """
        Parameters:
         - record
         - creds
         - transaction
         - environment

        """
        self.send_pingRecord(record, creds, transaction, environment)
        return self.recv_pingRecord()

    def send_pingRecord(self, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('pingRecord', TMessageType.CALL, self._seqid)
        args = pingRecord_args()
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pingRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pingRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pingRecord failed: unknown result")

    def verifyAndSwap(self, key, expected, record, replacement, creds, transaction, environment):
        """
        Parameters:
         - key
         - expected
         - record
         - replacement
         - creds
         - transaction
         - environment

        """
        self.send_verifyAndSwap(key, expected, record, replacement, creds, transaction, environment)
        return self.recv_verifyAndSwap()

    def send_verifyAndSwap(self, key, expected, record, replacement, creds, transaction, environment):
        self._oprot.writeMessageBegin('verifyAndSwap', TMessageType.CALL, self._seqid)
        args = verifyAndSwap_args()
        args.key = key
        args.expected = expected
        args.record = record
        args.replacement = replacement
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_verifyAndSwap(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = verifyAndSwap_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyAndSwap failed: unknown result")

    def verifyOrSet(self, key, value, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - record
         - creds
         - transaction
         - environment

        """
        self.send_verifyOrSet(key, value, record, creds, transaction, environment)
        self.recv_verifyOrSet()

    def send_verifyOrSet(self, key, value, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('verifyOrSet', TMessageType.CALL, self._seqid)
        args = verifyOrSet_args()
        args.key = key
        args.value = value
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_verifyOrSet(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = verifyOrSet_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        return

    def findOrAddKeyValue(self, key, value, creds, transaction, environment):
        """
        Parameters:
         - key
         - value
         - creds
         - transaction
         - environment

        """
        self.send_findOrAddKeyValue(key, value, creds, transaction, environment)
        return self.recv_findOrAddKeyValue()

    def send_findOrAddKeyValue(self, key, value, creds, transaction, environment):
        self._oprot.writeMessageBegin('findOrAddKeyValue', TMessageType.CALL, self._seqid)
        args = findOrAddKeyValue_args()
        args.key = key
        args.value = value
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findOrAddKeyValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findOrAddKeyValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        if result.ex5 is not None:
            raise result.ex5
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findOrAddKeyValue failed: unknown result")

    def findOrInsertCriteriaJson(self, criteria, json, creds, transaction, environment):
        """
        Parameters:
         - criteria
         - json
         - creds
         - transaction
         - environment

        """
        self.send_findOrInsertCriteriaJson(criteria, json, creds, transaction, environment)
        return self.recv_findOrInsertCriteriaJson()

    def send_findOrInsertCriteriaJson(self, criteria, json, creds, transaction, environment):
        self._oprot.writeMessageBegin('findOrInsertCriteriaJson', TMessageType.CALL, self._seqid)
        args = findOrInsertCriteriaJson_args()
        args.criteria = criteria
        args.json = json
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findOrInsertCriteriaJson(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findOrInsertCriteriaJson_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findOrInsertCriteriaJson failed: unknown result")

    def findOrInsertCclJson(self, ccl, json, creds, transaction, environment):
        """
        Parameters:
         - ccl
         - json
         - creds
         - transaction
         - environment

        """
        self.send_findOrInsertCclJson(ccl, json, creds, transaction, environment)
        return self.recv_findOrInsertCclJson()

    def send_findOrInsertCclJson(self, ccl, json, creds, transaction, environment):
        self._oprot.writeMessageBegin('findOrInsertCclJson', TMessageType.CALL, self._seqid)
        args = findOrInsertCclJson_args()
        args.ccl = ccl
        args.json = json
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findOrInsertCclJson(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findOrInsertCclJson_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        if result.ex5 is not None:
            raise result.ex5
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findOrInsertCclJson failed: unknown result")

    def sumKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        self.send_sumKeyRecord(key, record, creds, transaction, environment)
        return self.recv_sumKeyRecord()

    def send_sumKeyRecord(self, key, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('sumKeyRecord', TMessageType.CALL, self._seqid)
        args = sumKeyRecord_args()
        args.key = key
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sumKeyRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sumKeyRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyRecord failed: unknown result")

    def sumKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_sumKeyRecordTime(key, record, timestamp, creds, transaction, environment)
        return self.recv_sumKeyRecordTime()

    def send_sumKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('sumKeyRecordTime', TMessageType.CALL, self._seqid)
        args = sumKeyRecordTime_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sumKeyRecordTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sumKeyRecordTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyRecordTime failed: unknown result")

    def sumKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_sumKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
        return self.recv_sumKeyRecordTimestr()

    def send_sumKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('sumKeyRecordTimestr', TMessageType.CALL, self._seqid)
        args = sumKeyRecordTimestr_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sumKeyRecordTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sumKeyRecordTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyRecordTimestr failed: unknown result")

    def sumKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        self.send_sumKeyRecords(key, records, creds, transaction, environment)
        return self.recv_sumKeyRecords()

    def send_sumKeyRecords(self, key, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('sumKeyRecords', TMessageType.CALL, self._seqid)
        args = sumKeyRecords_args()
        args.key = key
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sumKeyRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sumKeyRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyRecords failed: unknown result")

    def sumKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_sumKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
        return self.recv_sumKeyRecordsTime()

    def send_sumKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('sumKeyRecordsTime', TMessageType.CALL, self._seqid)
        args = sumKeyRecordsTime_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sumKeyRecordsTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sumKeyRecordsTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyRecordsTime failed: unknown result")

    def sumKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_sumKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
        return self.recv_sumKeyRecordsTimestr()

    def send_sumKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('sumKeyRecordsTimestr', TMessageType.CALL, self._seqid)
        args = sumKeyRecordsTimestr_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sumKeyRecordsTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sumKeyRecordsTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyRecordsTimestr failed: unknown result")

    def sumKey(self, key, creds, transaction, environment):
        """
        Parameters:
         - key
         - creds
         - transaction
         - environment

        """
        self.send_sumKey(key, creds, transaction, environment)
        return self.recv_sumKey()

    def send_sumKey(self, key, creds, transaction, environment):
        self._oprot.writeMessageBegin('sumKey', TMessageType.CALL, self._seqid)
        args = sumKey_args()
        args.key = key
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sumKey(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sumKey_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKey failed: unknown result")

    def sumKeyTime(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_sumKeyTime(key, timestamp, creds, transaction, environment)
        return self.recv_sumKeyTime()

    def send_sumKeyTime(self, key, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('sumKeyTime', TMessageType.CALL, self._seqid)
        args = sumKeyTime_args()
        args.key = key
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sumKeyTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sumKeyTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyTime failed: unknown result")

    def sumKeyTimestr(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_sumKeyTimestr(key, timestamp, creds, transaction, environment)
        return self.recv_sumKeyTimestr()

    def send_sumKeyTimestr(self, key, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('sumKeyTimestr', TMessageType.CALL, self._seqid)
        args = sumKeyTimestr_args()
        args.key = key
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sumKeyTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sumKeyTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyTimestr failed: unknown result")

    def sumKeyCriteria(self, key, criteria, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - creds
         - transaction
         - environment

        """
        self.send_sumKeyCriteria(key, criteria, creds, transaction, environment)
        return self.recv_sumKeyCriteria()

    def send_sumKeyCriteria(self, key, criteria, creds, transaction, environment):
        self._oprot.writeMessageBegin('sumKeyCriteria', TMessageType.CALL, self._seqid)
        args = sumKeyCriteria_args()
        args.key = key
        args.criteria = criteria
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sumKeyCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sumKeyCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyCriteria failed: unknown result")

    def sumKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_sumKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
        return self.recv_sumKeyCriteriaTime()

    def send_sumKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('sumKeyCriteriaTime', TMessageType.CALL, self._seqid)
        args = sumKeyCriteriaTime_args()
        args.key = key
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sumKeyCriteriaTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sumKeyCriteriaTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyCriteriaTime failed: unknown result")

    def sumKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_sumKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
        return self.recv_sumKeyCriteriaTimestr()

    def send_sumKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('sumKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
        args = sumKeyCriteriaTimestr_args()
        args.key = key
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sumKeyCriteriaTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sumKeyCriteriaTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyCriteriaTimestr failed: unknown result")

    def sumKeyCcl(self, key, ccl, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - creds
         - transaction
         - environment

        """
        self.send_sumKeyCcl(key, ccl, creds, transaction, environment)
        return self.recv_sumKeyCcl()

    def send_sumKeyCcl(self, key, ccl, creds, transaction, environment):
        self._oprot.writeMessageBegin('sumKeyCcl', TMessageType.CALL, self._seqid)
        args = sumKeyCcl_args()
        args.key = key
        args.ccl = ccl
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sumKeyCcl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sumKeyCcl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyCcl failed: unknown result")

    def sumKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_sumKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
        return self.recv_sumKeyCclTime()

    def send_sumKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('sumKeyCclTime', TMessageType.CALL, self._seqid)
        args = sumKeyCclTime_args()
        args.key = key
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sumKeyCclTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sumKeyCclTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyCclTime failed: unknown result")

    def sumKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_sumKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
        return self.recv_sumKeyCclTimestr()

    def send_sumKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('sumKeyCclTimestr', TMessageType.CALL, self._seqid)
        args = sumKeyCclTimestr_args()
        args.key = key
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sumKeyCclTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sumKeyCclTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyCclTimestr failed: unknown result")

    def averageKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        self.send_averageKeyRecord(key, record, creds, transaction, environment)
        return self.recv_averageKeyRecord()

    def send_averageKeyRecord(self, key, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('averageKeyRecord', TMessageType.CALL, self._seqid)
        args = averageKeyRecord_args()
        args.key = key
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_averageKeyRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = averageKeyRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyRecord failed: unknown result")

    def averageKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_averageKeyRecordTime(key, record, timestamp, creds, transaction, environment)
        return self.recv_averageKeyRecordTime()

    def send_averageKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('averageKeyRecordTime', TMessageType.CALL, self._seqid)
        args = averageKeyRecordTime_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_averageKeyRecordTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = averageKeyRecordTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyRecordTime failed: unknown result")

    def averageKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_averageKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
        return self.recv_averageKeyRecordTimestr()

    def send_averageKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('averageKeyRecordTimestr', TMessageType.CALL, self._seqid)
        args = averageKeyRecordTimestr_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_averageKeyRecordTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = averageKeyRecordTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyRecordTimestr failed: unknown result")

    def averageKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        self.send_averageKeyRecords(key, records, creds, transaction, environment)
        return self.recv_averageKeyRecords()

    def send_averageKeyRecords(self, key, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('averageKeyRecords', TMessageType.CALL, self._seqid)
        args = averageKeyRecords_args()
        args.key = key
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_averageKeyRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = averageKeyRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyRecords failed: unknown result")

    def averageKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_averageKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
        return self.recv_averageKeyRecordsTime()

    def send_averageKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('averageKeyRecordsTime', TMessageType.CALL, self._seqid)
        args = averageKeyRecordsTime_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_averageKeyRecordsTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = averageKeyRecordsTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyRecordsTime failed: unknown result")

    def averageKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_averageKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
        return self.recv_averageKeyRecordsTimestr()

    def send_averageKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('averageKeyRecordsTimestr', TMessageType.CALL, self._seqid)
        args = averageKeyRecordsTimestr_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_averageKeyRecordsTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = averageKeyRecordsTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyRecordsTimestr failed: unknown result")

    def averageKey(self, key, creds, transaction, environment):
        """
        Parameters:
         - key
         - creds
         - transaction
         - environment

        """
        self.send_averageKey(key, creds, transaction, environment)
        return self.recv_averageKey()

    def send_averageKey(self, key, creds, transaction, environment):
        self._oprot.writeMessageBegin('averageKey', TMessageType.CALL, self._seqid)
        args = averageKey_args()
        args.key = key
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_averageKey(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = averageKey_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKey failed: unknown result")

    def averageKeyTime(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_averageKeyTime(key, timestamp, creds, transaction, environment)
        return self.recv_averageKeyTime()

    def send_averageKeyTime(self, key, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('averageKeyTime', TMessageType.CALL, self._seqid)
        args = averageKeyTime_args()
        args.key = key
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_averageKeyTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = averageKeyTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyTime failed: unknown result")

    def averageKeyTimestr(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_averageKeyTimestr(key, timestamp, creds, transaction, environment)
        return self.recv_averageKeyTimestr()

    def send_averageKeyTimestr(self, key, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('averageKeyTimestr', TMessageType.CALL, self._seqid)
        args = averageKeyTimestr_args()
        args.key = key
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_averageKeyTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = averageKeyTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyTimestr failed: unknown result")

    def averageKeyCriteria(self, key, criteria, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - creds
         - transaction
         - environment

        """
        self.send_averageKeyCriteria(key, criteria, creds, transaction, environment)
        return self.recv_averageKeyCriteria()

    def send_averageKeyCriteria(self, key, criteria, creds, transaction, environment):
        self._oprot.writeMessageBegin('averageKeyCriteria', TMessageType.CALL, self._seqid)
        args = averageKeyCriteria_args()
        args.key = key
        args.criteria = criteria
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_averageKeyCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = averageKeyCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyCriteria failed: unknown result")

    def averageKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_averageKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
        return self.recv_averageKeyCriteriaTime()

    def send_averageKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('averageKeyCriteriaTime', TMessageType.CALL, self._seqid)
        args = averageKeyCriteriaTime_args()
        args.key = key
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_averageKeyCriteriaTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = averageKeyCriteriaTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyCriteriaTime failed: unknown result")

    def averageKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_averageKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
        return self.recv_averageKeyCriteriaTimestr()

    def send_averageKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('averageKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
        args = averageKeyCriteriaTimestr_args()
        args.key = key
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_averageKeyCriteriaTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = averageKeyCriteriaTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyCriteriaTimestr failed: unknown result")

    def averageKeyCcl(self, key, ccl, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - creds
         - transaction
         - environment

        """
        self.send_averageKeyCcl(key, ccl, creds, transaction, environment)
        return self.recv_averageKeyCcl()

    def send_averageKeyCcl(self, key, ccl, creds, transaction, environment):
        self._oprot.writeMessageBegin('averageKeyCcl', TMessageType.CALL, self._seqid)
        args = averageKeyCcl_args()
        args.key = key
        args.ccl = ccl
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_averageKeyCcl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = averageKeyCcl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyCcl failed: unknown result")

    def averageKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_averageKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
        return self.recv_averageKeyCclTime()

    def send_averageKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('averageKeyCclTime', TMessageType.CALL, self._seqid)
        args = averageKeyCclTime_args()
        args.key = key
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_averageKeyCclTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = averageKeyCclTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyCclTime failed: unknown result")

    def averageKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_averageKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
        return self.recv_averageKeyCclTimestr()

    def send_averageKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('averageKeyCclTimestr', TMessageType.CALL, self._seqid)
        args = averageKeyCclTimestr_args()
        args.key = key
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_averageKeyCclTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = averageKeyCclTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyCclTimestr failed: unknown result")

    def countKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        self.send_countKeyRecord(key, record, creds, transaction, environment)
        return self.recv_countKeyRecord()

    def send_countKeyRecord(self, key, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('countKeyRecord', TMessageType.CALL, self._seqid)
        args = countKeyRecord_args()
        args.key = key
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_countKeyRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = countKeyRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyRecord failed: unknown result")

    def countKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_countKeyRecordTime(key, record, timestamp, creds, transaction, environment)
        return self.recv_countKeyRecordTime()

    def send_countKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('countKeyRecordTime', TMessageType.CALL, self._seqid)
        args = countKeyRecordTime_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_countKeyRecordTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = countKeyRecordTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyRecordTime failed: unknown result")

    def countKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_countKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
        return self.recv_countKeyRecordTimestr()

    def send_countKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('countKeyRecordTimestr', TMessageType.CALL, self._seqid)
        args = countKeyRecordTimestr_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_countKeyRecordTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = countKeyRecordTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyRecordTimestr failed: unknown result")

    def countKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        self.send_countKeyRecords(key, records, creds, transaction, environment)
        return self.recv_countKeyRecords()

    def send_countKeyRecords(self, key, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('countKeyRecords', TMessageType.CALL, self._seqid)
        args = countKeyRecords_args()
        args.key = key
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_countKeyRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = countKeyRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyRecords failed: unknown result")

    def countKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_countKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
        return self.recv_countKeyRecordsTime()

    def send_countKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('countKeyRecordsTime', TMessageType.CALL, self._seqid)
        args = countKeyRecordsTime_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_countKeyRecordsTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = countKeyRecordsTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyRecordsTime failed: unknown result")

    def countKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_countKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
        return self.recv_countKeyRecordsTimestr()

    def send_countKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('countKeyRecordsTimestr', TMessageType.CALL, self._seqid)
        args = countKeyRecordsTimestr_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_countKeyRecordsTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = countKeyRecordsTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyRecordsTimestr failed: unknown result")

    def countKey(self, key, creds, transaction, environment):
        """
        Parameters:
         - key
         - creds
         - transaction
         - environment

        """
        self.send_countKey(key, creds, transaction, environment)
        return self.recv_countKey()

    def send_countKey(self, key, creds, transaction, environment):
        self._oprot.writeMessageBegin('countKey', TMessageType.CALL, self._seqid)
        args = countKey_args()
        args.key = key
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_countKey(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = countKey_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "countKey failed: unknown result")

    def countKeyTime(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_countKeyTime(key, timestamp, creds, transaction, environment)
        return self.recv_countKeyTime()

    def send_countKeyTime(self, key, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('countKeyTime', TMessageType.CALL, self._seqid)
        args = countKeyTime_args()
        args.key = key
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_countKeyTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = countKeyTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyTime failed: unknown result")

    def countKeyTimestr(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_countKeyTimestr(key, timestamp, creds, transaction, environment)
        return self.recv_countKeyTimestr()

    def send_countKeyTimestr(self, key, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('countKeyTimestr', TMessageType.CALL, self._seqid)
        args = countKeyTimestr_args()
        args.key = key
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_countKeyTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = countKeyTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyTimestr failed: unknown result")

    def countKeyCriteria(self, key, criteria, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - creds
         - transaction
         - environment

        """
        self.send_countKeyCriteria(key, criteria, creds, transaction, environment)
        return self.recv_countKeyCriteria()

    def send_countKeyCriteria(self, key, criteria, creds, transaction, environment):
        self._oprot.writeMessageBegin('countKeyCriteria', TMessageType.CALL, self._seqid)
        args = countKeyCriteria_args()
        args.key = key
        args.criteria = criteria
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_countKeyCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = countKeyCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyCriteria failed: unknown result")

    def countKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_countKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
        return self.recv_countKeyCriteriaTime()

    def send_countKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('countKeyCriteriaTime', TMessageType.CALL, self._seqid)
        args = countKeyCriteriaTime_args()
        args.key = key
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_countKeyCriteriaTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = countKeyCriteriaTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyCriteriaTime failed: unknown result")

    def countKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_countKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
        return self.recv_countKeyCriteriaTimestr()

    def send_countKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('countKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
        args = countKeyCriteriaTimestr_args()
        args.key = key
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_countKeyCriteriaTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = countKeyCriteriaTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyCriteriaTimestr failed: unknown result")

    def countKeyCcl(self, key, ccl, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - creds
         - transaction
         - environment

        """
        self.send_countKeyCcl(key, ccl, creds, transaction, environment)
        return self.recv_countKeyCcl()

    def send_countKeyCcl(self, key, ccl, creds, transaction, environment):
        self._oprot.writeMessageBegin('countKeyCcl', TMessageType.CALL, self._seqid)
        args = countKeyCcl_args()
        args.key = key
        args.ccl = ccl
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_countKeyCcl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = countKeyCcl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyCcl failed: unknown result")

    def countKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_countKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
        return self.recv_countKeyCclTime()

    def send_countKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('countKeyCclTime', TMessageType.CALL, self._seqid)
        args = countKeyCclTime_args()
        args.key = key
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_countKeyCclTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = countKeyCclTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyCclTime failed: unknown result")

    def countKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_countKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
        return self.recv_countKeyCclTimestr()

    def send_countKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('countKeyCclTimestr', TMessageType.CALL, self._seqid)
        args = countKeyCclTimestr_args()
        args.key = key
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_countKeyCclTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = countKeyCclTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyCclTimestr failed: unknown result")

    def maxKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        self.send_maxKeyRecord(key, record, creds, transaction, environment)
        return self.recv_maxKeyRecord()

    def send_maxKeyRecord(self, key, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('maxKeyRecord', TMessageType.CALL, self._seqid)
        args = maxKeyRecord_args()
        args.key = key
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_maxKeyRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = maxKeyRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyRecord failed: unknown result")

    def maxKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_maxKeyRecordTime(key, record, timestamp, creds, transaction, environment)
        return self.recv_maxKeyRecordTime()

    def send_maxKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('maxKeyRecordTime', TMessageType.CALL, self._seqid)
        args = maxKeyRecordTime_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_maxKeyRecordTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = maxKeyRecordTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyRecordTime failed: unknown result")

    def maxKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_maxKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
        return self.recv_maxKeyRecordTimestr()

    def send_maxKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('maxKeyRecordTimestr', TMessageType.CALL, self._seqid)
        args = maxKeyRecordTimestr_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_maxKeyRecordTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = maxKeyRecordTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyRecordTimestr failed: unknown result")

    def maxKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        self.send_maxKeyRecords(key, records, creds, transaction, environment)
        return self.recv_maxKeyRecords()

    def send_maxKeyRecords(self, key, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('maxKeyRecords', TMessageType.CALL, self._seqid)
        args = maxKeyRecords_args()
        args.key = key
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_maxKeyRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = maxKeyRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyRecords failed: unknown result")

    def maxKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_maxKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
        return self.recv_maxKeyRecordsTime()

    def send_maxKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('maxKeyRecordsTime', TMessageType.CALL, self._seqid)
        args = maxKeyRecordsTime_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_maxKeyRecordsTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = maxKeyRecordsTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyRecordsTime failed: unknown result")

    def maxKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_maxKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
        return self.recv_maxKeyRecordsTimestr()

    def send_maxKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('maxKeyRecordsTimestr', TMessageType.CALL, self._seqid)
        args = maxKeyRecordsTimestr_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_maxKeyRecordsTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = maxKeyRecordsTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyRecordsTimestr failed: unknown result")

    def maxKeyCriteria(self, key, criteria, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - creds
         - transaction
         - environment

        """
        self.send_maxKeyCriteria(key, criteria, creds, transaction, environment)
        return self.recv_maxKeyCriteria()

    def send_maxKeyCriteria(self, key, criteria, creds, transaction, environment):
        self._oprot.writeMessageBegin('maxKeyCriteria', TMessageType.CALL, self._seqid)
        args = maxKeyCriteria_args()
        args.key = key
        args.criteria = criteria
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_maxKeyCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = maxKeyCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyCriteria failed: unknown result")

    def maxKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_maxKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
        return self.recv_maxKeyCriteriaTime()

    def send_maxKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('maxKeyCriteriaTime', TMessageType.CALL, self._seqid)
        args = maxKeyCriteriaTime_args()
        args.key = key
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_maxKeyCriteriaTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = maxKeyCriteriaTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyCriteriaTime failed: unknown result")

    def maxKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_maxKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
        return self.recv_maxKeyCriteriaTimestr()

    def send_maxKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('maxKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
        args = maxKeyCriteriaTimestr_args()
        args.key = key
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_maxKeyCriteriaTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = maxKeyCriteriaTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyCriteriaTimestr failed: unknown result")

    def maxKeyCcl(self, key, ccl, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - creds
         - transaction
         - environment

        """
        self.send_maxKeyCcl(key, ccl, creds, transaction, environment)
        return self.recv_maxKeyCcl()

    def send_maxKeyCcl(self, key, ccl, creds, transaction, environment):
        self._oprot.writeMessageBegin('maxKeyCcl', TMessageType.CALL, self._seqid)
        args = maxKeyCcl_args()
        args.key = key
        args.ccl = ccl
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_maxKeyCcl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = maxKeyCcl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyCcl failed: unknown result")

    def maxKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_maxKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
        return self.recv_maxKeyCclTime()

    def send_maxKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('maxKeyCclTime', TMessageType.CALL, self._seqid)
        args = maxKeyCclTime_args()
        args.key = key
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_maxKeyCclTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = maxKeyCclTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyCclTime failed: unknown result")

    def maxKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_maxKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
        return self.recv_maxKeyCclTimestr()

    def send_maxKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('maxKeyCclTimestr', TMessageType.CALL, self._seqid)
        args = maxKeyCclTimestr_args()
        args.key = key
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_maxKeyCclTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = maxKeyCclTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyCclTimestr failed: unknown result")

    def maxKey(self, key, creds, transaction, environment):
        """
        Parameters:
         - key
         - creds
         - transaction
         - environment

        """
        self.send_maxKey(key, creds, transaction, environment)
        return self.recv_maxKey()

    def send_maxKey(self, key, creds, transaction, environment):
        self._oprot.writeMessageBegin('maxKey', TMessageType.CALL, self._seqid)
        args = maxKey_args()
        args.key = key
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_maxKey(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = maxKey_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKey failed: unknown result")

    def maxKeyTime(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_maxKeyTime(key, timestamp, creds, transaction, environment)
        return self.recv_maxKeyTime()

    def send_maxKeyTime(self, key, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('maxKeyTime', TMessageType.CALL, self._seqid)
        args = maxKeyTime_args()
        args.key = key
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_maxKeyTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = maxKeyTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyTime failed: unknown result")

    def maxKeyTimestr(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_maxKeyTimestr(key, timestamp, creds, transaction, environment)
        return self.recv_maxKeyTimestr()

    def send_maxKeyTimestr(self, key, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('maxKeyTimestr', TMessageType.CALL, self._seqid)
        args = maxKeyTimestr_args()
        args.key = key
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_maxKeyTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = maxKeyTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyTimestr failed: unknown result")

    def minKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        self.send_minKeyRecord(key, record, creds, transaction, environment)
        return self.recv_minKeyRecord()

    def send_minKeyRecord(self, key, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('minKeyRecord', TMessageType.CALL, self._seqid)
        args = minKeyRecord_args()
        args.key = key
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_minKeyRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = minKeyRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyRecord failed: unknown result")

    def minKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_minKeyRecordTime(key, record, timestamp, creds, transaction, environment)
        return self.recv_minKeyRecordTime()

    def send_minKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('minKeyRecordTime', TMessageType.CALL, self._seqid)
        args = minKeyRecordTime_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_minKeyRecordTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = minKeyRecordTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyRecordTime failed: unknown result")

    def minKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_minKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
        return self.recv_minKeyRecordTimestr()

    def send_minKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('minKeyRecordTimestr', TMessageType.CALL, self._seqid)
        args = minKeyRecordTimestr_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_minKeyRecordTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = minKeyRecordTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyRecordTimestr failed: unknown result")

    def minKey(self, key, creds, transaction, environment):
        """
        Parameters:
         - key
         - creds
         - transaction
         - environment

        """
        self.send_minKey(key, creds, transaction, environment)
        return self.recv_minKey()

    def send_minKey(self, key, creds, transaction, environment):
        self._oprot.writeMessageBegin('minKey', TMessageType.CALL, self._seqid)
        args = minKey_args()
        args.key = key
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_minKey(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = minKey_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "minKey failed: unknown result")

    def minKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_minKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
        return self.recv_minKeyRecordsTime()

    def send_minKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('minKeyRecordsTime', TMessageType.CALL, self._seqid)
        args = minKeyRecordsTime_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_minKeyRecordsTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = minKeyRecordsTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyRecordsTime failed: unknown result")

    def minKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_minKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
        return self.recv_minKeyRecordsTimestr()

    def send_minKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('minKeyRecordsTimestr', TMessageType.CALL, self._seqid)
        args = minKeyRecordsTimestr_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_minKeyRecordsTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = minKeyRecordsTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyRecordsTimestr failed: unknown result")

    def minKeyCriteria(self, key, criteria, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - creds
         - transaction
         - environment

        """
        self.send_minKeyCriteria(key, criteria, creds, transaction, environment)
        return self.recv_minKeyCriteria()

    def send_minKeyCriteria(self, key, criteria, creds, transaction, environment):
        self._oprot.writeMessageBegin('minKeyCriteria', TMessageType.CALL, self._seqid)
        args = minKeyCriteria_args()
        args.key = key
        args.criteria = criteria
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_minKeyCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = minKeyCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyCriteria failed: unknown result")

    def minKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_minKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
        return self.recv_minKeyCriteriaTime()

    def send_minKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('minKeyCriteriaTime', TMessageType.CALL, self._seqid)
        args = minKeyCriteriaTime_args()
        args.key = key
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_minKeyCriteriaTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = minKeyCriteriaTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyCriteriaTime failed: unknown result")

    def minKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_minKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
        return self.recv_minKeyCriteriaTimestr()

    def send_minKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('minKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
        args = minKeyCriteriaTimestr_args()
        args.key = key
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_minKeyCriteriaTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = minKeyCriteriaTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyCriteriaTimestr failed: unknown result")

    def minKeyCcl(self, key, ccl, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - creds
         - transaction
         - environment

        """
        self.send_minKeyCcl(key, ccl, creds, transaction, environment)
        return self.recv_minKeyCcl()

    def send_minKeyCcl(self, key, ccl, creds, transaction, environment):
        self._oprot.writeMessageBegin('minKeyCcl', TMessageType.CALL, self._seqid)
        args = minKeyCcl_args()
        args.key = key
        args.ccl = ccl
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_minKeyCcl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = minKeyCcl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyCcl failed: unknown result")

    def minKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_minKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
        return self.recv_minKeyCclTime()

    def send_minKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('minKeyCclTime', TMessageType.CALL, self._seqid)
        args = minKeyCclTime_args()
        args.key = key
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_minKeyCclTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = minKeyCclTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyCclTime failed: unknown result")

    def minKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_minKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
        return self.recv_minKeyCclTimestr()

    def send_minKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('minKeyCclTimestr', TMessageType.CALL, self._seqid)
        args = minKeyCclTimestr_args()
        args.key = key
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_minKeyCclTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = minKeyCclTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyCclTimestr failed: unknown result")

    def minKeyTime(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_minKeyTime(key, timestamp, creds, transaction, environment)
        return self.recv_minKeyTime()

    def send_minKeyTime(self, key, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('minKeyTime', TMessageType.CALL, self._seqid)
        args = minKeyTime_args()
        args.key = key
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_minKeyTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = minKeyTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyTime failed: unknown result")

    def minKeyTimestr(self, key, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_minKeyTimestr(key, timestamp, creds, transaction, environment)
        return self.recv_minKeyTimestr()

    def send_minKeyTimestr(self, key, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('minKeyTimestr', TMessageType.CALL, self._seqid)
        args = minKeyTimestr_args()
        args.key = key
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_minKeyTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = minKeyTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyTimestr failed: unknown result")

    def minKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        self.send_minKeyRecords(key, records, creds, transaction, environment)
        return self.recv_minKeyRecords()

    def send_minKeyRecords(self, key, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('minKeyRecords', TMessageType.CALL, self._seqid)
        args = minKeyRecords_args()
        args.key = key
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_minKeyRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = minKeyRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyRecords failed: unknown result")

    def navigateKeyRecord(self, key, record, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeyRecord(key, record, creds, transaction, environment)
        return self.recv_navigateKeyRecord()

    def send_navigateKeyRecord(self, key, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeyRecord', TMessageType.CALL, self._seqid)
        args = navigateKeyRecord_args()
        args.key = key
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeyRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeyRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyRecord failed: unknown result")

    def navigateKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeyRecordTime(key, record, timestamp, creds, transaction, environment)
        return self.recv_navigateKeyRecordTime()

    def send_navigateKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeyRecordTime', TMessageType.CALL, self._seqid)
        args = navigateKeyRecordTime_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeyRecordTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeyRecordTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyRecordTime failed: unknown result")

    def navigateKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
        return self.recv_navigateKeyRecordTimestr()

    def send_navigateKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeyRecordTimestr', TMessageType.CALL, self._seqid)
        args = navigateKeyRecordTimestr_args()
        args.key = key
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeyRecordTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeyRecordTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyRecordTimestr failed: unknown result")

    def navigateKeysRecord(self, keys, record, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeysRecord(keys, record, creds, transaction, environment)
        return self.recv_navigateKeysRecord()

    def send_navigateKeysRecord(self, keys, record, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeysRecord', TMessageType.CALL, self._seqid)
        args = navigateKeysRecord_args()
        args.keys = keys
        args.record = record
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeysRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeysRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysRecord failed: unknown result")

    def navigateKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeysRecordTime(keys, record, timestamp, creds, transaction, environment)
        return self.recv_navigateKeysRecordTime()

    def send_navigateKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeysRecordTime', TMessageType.CALL, self._seqid)
        args = navigateKeysRecordTime_args()
        args.keys = keys
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeysRecordTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeysRecordTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysRecordTime failed: unknown result")

    def navigateKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - record
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeysRecordTimestr(keys, record, timestamp, creds, transaction, environment)
        return self.recv_navigateKeysRecordTimestr()

    def send_navigateKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeysRecordTimestr', TMessageType.CALL, self._seqid)
        args = navigateKeysRecordTimestr_args()
        args.keys = keys
        args.record = record
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeysRecordTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeysRecordTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysRecordTimestr failed: unknown result")

    def navigateKeysRecords(self, keys, records, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeysRecords(keys, records, creds, transaction, environment)
        return self.recv_navigateKeysRecords()

    def send_navigateKeysRecords(self, keys, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeysRecords', TMessageType.CALL, self._seqid)
        args = navigateKeysRecords_args()
        args.keys = keys
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeysRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeysRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysRecords failed: unknown result")

    def navigateKeyRecords(self, key, records, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeyRecords(key, records, creds, transaction, environment)
        return self.recv_navigateKeyRecords()

    def send_navigateKeyRecords(self, key, records, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeyRecords', TMessageType.CALL, self._seqid)
        args = navigateKeyRecords_args()
        args.key = key
        args.records = records
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeyRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeyRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyRecords failed: unknown result")

    def navigateKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
        return self.recv_navigateKeyRecordsTime()

    def send_navigateKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeyRecordsTime', TMessageType.CALL, self._seqid)
        args = navigateKeyRecordsTime_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeyRecordsTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeyRecordsTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyRecordsTime failed: unknown result")

    def navigateKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
        return self.recv_navigateKeyRecordsTimestr()

    def send_navigateKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeyRecordsTimestr', TMessageType.CALL, self._seqid)
        args = navigateKeyRecordsTimestr_args()
        args.key = key
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeyRecordsTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeyRecordsTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyRecordsTimestr failed: unknown result")

    def navigateKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeysRecordsTime(keys, records, timestamp, creds, transaction, environment)
        return self.recv_navigateKeysRecordsTime()

    def send_navigateKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeysRecordsTime', TMessageType.CALL, self._seqid)
        args = navigateKeysRecordsTime_args()
        args.keys = keys
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeysRecordsTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeysRecordsTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysRecordsTime failed: unknown result")

    def navigateKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - records
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeysRecordsTimestr(keys, records, timestamp, creds, transaction, environment)
        return self.recv_navigateKeysRecordsTimestr()

    def send_navigateKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeysRecordsTimestr', TMessageType.CALL, self._seqid)
        args = navigateKeysRecordsTimestr_args()
        args.keys = keys
        args.records = records
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeysRecordsTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeysRecordsTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysRecordsTimestr failed: unknown result")

    def navigateKeyCcl(self, key, ccl, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeyCcl(key, ccl, creds, transaction, environment)
        return self.recv_navigateKeyCcl()

    def send_navigateKeyCcl(self, key, ccl, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeyCcl', TMessageType.CALL, self._seqid)
        args = navigateKeyCcl_args()
        args.key = key
        args.ccl = ccl
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeyCcl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeyCcl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyCcl failed: unknown result")

    def navigateKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
        return self.recv_navigateKeyCclTime()

    def send_navigateKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeyCclTime', TMessageType.CALL, self._seqid)
        args = navigateKeyCclTime_args()
        args.key = key
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeyCclTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeyCclTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyCclTime failed: unknown result")

    def navigateKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
        return self.recv_navigateKeyCclTimestr()

    def send_navigateKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeyCclTimestr', TMessageType.CALL, self._seqid)
        args = navigateKeyCclTimestr_args()
        args.key = key
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeyCclTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeyCclTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyCclTimestr failed: unknown result")

    def navigateKeysCcl(self, keys, ccl, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeysCcl(keys, ccl, creds, transaction, environment)
        return self.recv_navigateKeysCcl()

    def send_navigateKeysCcl(self, keys, ccl, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeysCcl', TMessageType.CALL, self._seqid)
        args = navigateKeysCcl_args()
        args.keys = keys
        args.ccl = ccl
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeysCcl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeysCcl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysCcl failed: unknown result")

    def navigateKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeysCclTime(keys, ccl, timestamp, creds, transaction, environment)
        return self.recv_navigateKeysCclTime()

    def send_navigateKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeysCclTime', TMessageType.CALL, self._seqid)
        args = navigateKeysCclTime_args()
        args.keys = keys
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeysCclTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeysCclTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysCclTime failed: unknown result")

    def navigateKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - ccl
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeysCclTimestr(keys, ccl, timestamp, creds, transaction, environment)
        return self.recv_navigateKeysCclTimestr()

    def send_navigateKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeysCclTimestr', TMessageType.CALL, self._seqid)
        args = navigateKeysCclTimestr_args()
        args.keys = keys
        args.ccl = ccl
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeysCclTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeysCclTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysCclTimestr failed: unknown result")

    def navigateKeyCriteria(self, key, criteria, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeyCriteria(key, criteria, creds, transaction, environment)
        return self.recv_navigateKeyCriteria()

    def send_navigateKeyCriteria(self, key, criteria, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeyCriteria', TMessageType.CALL, self._seqid)
        args = navigateKeyCriteria_args()
        args.key = key
        args.criteria = criteria
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeyCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeyCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyCriteria failed: unknown result")

    def navigateKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
        return self.recv_navigateKeyCriteriaTime()

    def send_navigateKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeyCriteriaTime', TMessageType.CALL, self._seqid)
        args = navigateKeyCriteriaTime_args()
        args.key = key
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeyCriteriaTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeyCriteriaTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyCriteriaTime failed: unknown result")

    def navigateKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - key
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
        return self.recv_navigateKeyCriteriaTimestr()

    def send_navigateKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
        args = navigateKeyCriteriaTimestr_args()
        args.key = key
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeyCriteriaTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeyCriteriaTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyCriteriaTimestr failed: unknown result")

    def navigateKeysCriteria(self, keys, criteria, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeysCriteria(keys, criteria, creds, transaction, environment)
        return self.recv_navigateKeysCriteria()

    def send_navigateKeysCriteria(self, keys, criteria, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeysCriteria', TMessageType.CALL, self._seqid)
        args = navigateKeysCriteria_args()
        args.keys = keys
        args.criteria = criteria
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeysCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeysCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysCriteria failed: unknown result")

    def navigateKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeysCriteriaTime(keys, criteria, timestamp, creds, transaction, environment)
        return self.recv_navigateKeysCriteriaTime()

    def send_navigateKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeysCriteriaTime', TMessageType.CALL, self._seqid)
        args = navigateKeysCriteriaTime_args()
        args.keys = keys
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeysCriteriaTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeysCriteriaTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysCriteriaTime failed: unknown result")

    def navigateKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
        """
        Parameters:
         - keys
         - criteria
         - timestamp
         - creds
         - transaction
         - environment

        """
        self.send_navigateKeysCriteriaTimestr(keys, criteria, timestamp, creds, transaction, environment)
        return self.recv_navigateKeysCriteriaTimestr()

    def send_navigateKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
        self._oprot.writeMessageBegin('navigateKeysCriteriaTimestr', TMessageType.CALL, self._seqid)
        args = navigateKeysCriteriaTimestr_args()
        args.keys = keys
        args.criteria = criteria
        args.timestamp = timestamp
        args.creds = creds
        args.transaction = transaction
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_navigateKeysCriteriaTimestr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = navigateKeysCriteriaTimestr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysCriteriaTimestr failed: unknown result")

    def getServerEnvironment(self, creds, token, environment):
        """
        Parameters:
         - creds
         - token
         - environment

        """
        self.send_getServerEnvironment(creds, token, environment)
        return self.recv_getServerEnvironment()

    def send_getServerEnvironment(self, creds, token, environment):
        self._oprot.writeMessageBegin('getServerEnvironment', TMessageType.CALL, self._seqid)
        args = getServerEnvironment_args()
        args.creds = creds
        args.token = token
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getServerEnvironment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getServerEnvironment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getServerEnvironment failed: unknown result")

    def getServerVersion(self):
        self.send_getServerVersion()
        return self.recv_getServerVersion()

    def send_getServerVersion(self):
        self._oprot.writeMessageBegin('getServerVersion', TMessageType.CALL, self._seqid)
        args = getServerVersion_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getServerVersion(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getServerVersion_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getServerVersion failed: unknown result")

    def time(self, creds, token, environment):
        """
        Parameters:
         - creds
         - token
         - environment

        """
        self.send_time(creds, token, environment)
        return self.recv_time()

    def send_time(self, creds, token, environment):
        self._oprot.writeMessageBegin('time', TMessageType.CALL, self._seqid)
        args = time_args()
        args.creds = creds
        args.token = token
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_time(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = time_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "time failed: unknown result")

    def timePhrase(self, phrase, creds, token, environment):
        """
        Parameters:
         - phrase
         - creds
         - token
         - environment

        """
        self.send_timePhrase(phrase, creds, token, environment)
        return self.recv_timePhrase()

    def send_timePhrase(self, phrase, creds, token, environment):
        self._oprot.writeMessageBegin('timePhrase', TMessageType.CALL, self._seqid)
        args = timePhrase_args()
        args.phrase = phrase
        args.creds = creds
        args.token = token
        args.environment = environment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_timePhrase(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = timePhrase_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        if result.ex3 is not None:
            raise result.ex3
        if result.ex4 is not None:
            raise result.ex4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "timePhrase failed: unknown result")

    def invokeManagement(self, method, params, creds):
        """
        Parameters:
         - method
         - params
         - creds

        """
        self.send_invokeManagement(method, params, creds)
        return self.recv_invokeManagement()

    def send_invokeManagement(self, method, params, creds):
        self._oprot.writeMessageBegin('invokeManagement', TMessageType.CALL, self._seqid)
        args = invokeManagement_args()
        args.method = method
        args.params = params
        args.creds = creds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_invokeManagement(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = invokeManagement_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        if result.ex2 is not None:
            raise result.ex2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "invokeManagement failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["abort"] = Processor.process_abort
        self._processMap["addKeyValue"] = Processor.process_addKeyValue
        self._processMap["addKeyValueRecord"] = Processor.process_addKeyValueRecord
        self._processMap["addKeyValueRecords"] = Processor.process_addKeyValueRecords
        self._processMap["auditRecord"] = Processor.process_auditRecord
        self._processMap["auditRecordStart"] = Processor.process_auditRecordStart
        self._processMap["auditRecordStartstr"] = Processor.process_auditRecordStartstr
        self._processMap["auditRecordStartEnd"] = Processor.process_auditRecordStartEnd
        self._processMap["auditRecordStartstrEndstr"] = Processor.process_auditRecordStartstrEndstr
        self._processMap["auditKeyRecord"] = Processor.process_auditKeyRecord
        self._processMap["auditKeyRecordStart"] = Processor.process_auditKeyRecordStart
        self._processMap["auditKeyRecordStartstr"] = Processor.process_auditKeyRecordStartstr
        self._processMap["auditKeyRecordStartEnd"] = Processor.process_auditKeyRecordStartEnd
        self._processMap["auditKeyRecordStartstrEndstr"] = Processor.process_auditKeyRecordStartstrEndstr
        self._processMap["browseKey"] = Processor.process_browseKey
        self._processMap["browseKeys"] = Processor.process_browseKeys
        self._processMap["browseKeyTime"] = Processor.process_browseKeyTime
        self._processMap["browseKeyTimestr"] = Processor.process_browseKeyTimestr
        self._processMap["browseKeysTime"] = Processor.process_browseKeysTime
        self._processMap["browseKeysTimestr"] = Processor.process_browseKeysTimestr
        self._processMap["chronologizeKeyRecord"] = Processor.process_chronologizeKeyRecord
        self._processMap["chronologizeKeyRecordStart"] = Processor.process_chronologizeKeyRecordStart
        self._processMap["chronologizeKeyRecordStartstr"] = Processor.process_chronologizeKeyRecordStartstr
        self._processMap["chronologizeKeyRecordStartEnd"] = Processor.process_chronologizeKeyRecordStartEnd
        self._processMap["chronologizeKeyRecordStartstrEndstr"] = Processor.process_chronologizeKeyRecordStartstrEndstr
        self._processMap["clearRecord"] = Processor.process_clearRecord
        self._processMap["clearRecords"] = Processor.process_clearRecords
        self._processMap["clearKeyRecord"] = Processor.process_clearKeyRecord
        self._processMap["clearKeysRecord"] = Processor.process_clearKeysRecord
        self._processMap["clearKeyRecords"] = Processor.process_clearKeyRecords
        self._processMap["clearKeysRecords"] = Processor.process_clearKeysRecords
        self._processMap["commit"] = Processor.process_commit
        self._processMap["inspect"] = Processor.process_inspect
        self._processMap["describe"] = Processor.process_describe
        self._processMap["describeTime"] = Processor.process_describeTime
        self._processMap["describeTimestr"] = Processor.process_describeTimestr
        self._processMap["describeRecord"] = Processor.process_describeRecord
        self._processMap["describeRecordTime"] = Processor.process_describeRecordTime
        self._processMap["describeRecordTimestr"] = Processor.process_describeRecordTimestr
        self._processMap["describeRecords"] = Processor.process_describeRecords
        self._processMap["describeRecordsTime"] = Processor.process_describeRecordsTime
        self._processMap["describeRecordsTimestr"] = Processor.process_describeRecordsTimestr
        self._processMap["diffRecordStart"] = Processor.process_diffRecordStart
        self._processMap["diffRecordStartstr"] = Processor.process_diffRecordStartstr
        self._processMap["diffRecordStartEnd"] = Processor.process_diffRecordStartEnd
        self._processMap["diffRecordStartstrEndstr"] = Processor.process_diffRecordStartstrEndstr
        self._processMap["diffKeyRecordStart"] = Processor.process_diffKeyRecordStart
        self._processMap["diffKeyRecordStartstr"] = Processor.process_diffKeyRecordStartstr
        self._processMap["diffKeyRecordStartEnd"] = Processor.process_diffKeyRecordStartEnd
        self._processMap["diffKeyRecordStartstrEndstr"] = Processor.process_diffKeyRecordStartstrEndstr
        self._processMap["diffKeyStart"] = Processor.process_diffKeyStart
        self._processMap["diffKeyStartstr"] = Processor.process_diffKeyStartstr
        self._processMap["diffKeyStartEnd"] = Processor.process_diffKeyStartEnd
        self._processMap["diffKeyStartstrEndstr"] = Processor.process_diffKeyStartstrEndstr
        self._processMap["invokePlugin"] = Processor.process_invokePlugin
        self._processMap["login"] = Processor.process_login
        self._processMap["logout"] = Processor.process_logout
        self._processMap["stage"] = Processor.process_stage
        self._processMap["insertJson"] = Processor.process_insertJson
        self._processMap["insertJsonRecord"] = Processor.process_insertJsonRecord
        self._processMap["insertJsonRecords"] = Processor.process_insertJsonRecords
        self._processMap["removeKeyValueRecord"] = Processor.process_removeKeyValueRecord
        self._processMap["removeKeyValueRecords"] = Processor.process_removeKeyValueRecords
        self._processMap["setKeyValueRecord"] = Processor.process_setKeyValueRecord
        self._processMap["setKeyValue"] = Processor.process_setKeyValue
        self._processMap["setKeyValueRecords"] = Processor.process_setKeyValueRecords
        self._processMap["reconcileKeyRecordValues"] = Processor.process_reconcileKeyRecordValues
        self._processMap["inventory"] = Processor.process_inventory
        self._processMap["selectRecord"] = Processor.process_selectRecord
        self._processMap["selectRecords"] = Processor.process_selectRecords
        self._processMap["selectRecordTime"] = Processor.process_selectRecordTime
        self._processMap["selectRecordTimestr"] = Processor.process_selectRecordTimestr
        self._processMap["selectRecordsTime"] = Processor.process_selectRecordsTime
        self._processMap["selectRecordsTimestr"] = Processor.process_selectRecordsTimestr
        self._processMap["selectKeyRecord"] = Processor.process_selectKeyRecord
        self._processMap["selectKeyRecordTime"] = Processor.process_selectKeyRecordTime
        self._processMap["selectKeyRecordTimestr"] = Processor.process_selectKeyRecordTimestr
        self._processMap["selectKeysRecord"] = Processor.process_selectKeysRecord
        self._processMap["selectKeysRecordTime"] = Processor.process_selectKeysRecordTime
        self._processMap["selectKeysRecordTimestr"] = Processor.process_selectKeysRecordTimestr
        self._processMap["selectKeysRecords"] = Processor.process_selectKeysRecords
        self._processMap["selectKeyRecords"] = Processor.process_selectKeyRecords
        self._processMap["selectKeyRecordsTime"] = Processor.process_selectKeyRecordsTime
        self._processMap["selectKeyRecordsTimestr"] = Processor.process_selectKeyRecordsTimestr
        self._processMap["selectKeysRecordsTime"] = Processor.process_selectKeysRecordsTime
        self._processMap["selectKeysRecordsTimestr"] = Processor.process_selectKeysRecordsTimestr
        self._processMap["selectCriteria"] = Processor.process_selectCriteria
        self._processMap["selectCcl"] = Processor.process_selectCcl
        self._processMap["selectCriteriaTime"] = Processor.process_selectCriteriaTime
        self._processMap["selectCriteriaTimestr"] = Processor.process_selectCriteriaTimestr
        self._processMap["selectCclTime"] = Processor.process_selectCclTime
        self._processMap["selectCclTimestr"] = Processor.process_selectCclTimestr
        self._processMap["selectKeyCriteria"] = Processor.process_selectKeyCriteria
        self._processMap["selectKeyCcl"] = Processor.process_selectKeyCcl
        self._processMap["selectKeyCriteriaTime"] = Processor.process_selectKeyCriteriaTime
        self._processMap["selectKeyCriteriaTimestr"] = Processor.process_selectKeyCriteriaTimestr
        self._processMap["selectKeyCclTime"] = Processor.process_selectKeyCclTime
        self._processMap["selectKeyCclTimestr"] = Processor.process_selectKeyCclTimestr
        self._processMap["selectKeysCriteria"] = Processor.process_selectKeysCriteria
        self._processMap["selectKeysCcl"] = Processor.process_selectKeysCcl
        self._processMap["selectKeysCriteriaTime"] = Processor.process_selectKeysCriteriaTime
        self._processMap["selectKeysCriteriaTimestr"] = Processor.process_selectKeysCriteriaTimestr
        self._processMap["selectKeysCclTime"] = Processor.process_selectKeysCclTime
        self._processMap["selectKeysCclTimestr"] = Processor.process_selectKeysCclTimestr
        self._processMap["getKeyRecord"] = Processor.process_getKeyRecord
        self._processMap["getKeyRecordTime"] = Processor.process_getKeyRecordTime
        self._processMap["getKeyRecordTimestr"] = Processor.process_getKeyRecordTimestr
        self._processMap["getKeysRecord"] = Processor.process_getKeysRecord
        self._processMap["getKeysRecordTime"] = Processor.process_getKeysRecordTime
        self._processMap["getKeysRecordTimestr"] = Processor.process_getKeysRecordTimestr
        self._processMap["getKeysRecords"] = Processor.process_getKeysRecords
        self._processMap["getKeyRecords"] = Processor.process_getKeyRecords
        self._processMap["getKeyRecordsTime"] = Processor.process_getKeyRecordsTime
        self._processMap["getKeyRecordsTimestr"] = Processor.process_getKeyRecordsTimestr
        self._processMap["getKeysRecordsTime"] = Processor.process_getKeysRecordsTime
        self._processMap["getKeysRecordsTimestr"] = Processor.process_getKeysRecordsTimestr
        self._processMap["getKeyCriteria"] = Processor.process_getKeyCriteria
        self._processMap["getCriteria"] = Processor.process_getCriteria
        self._processMap["getCcl"] = Processor.process_getCcl
        self._processMap["getCriteriaTime"] = Processor.process_getCriteriaTime
        self._processMap["getCriteriaTimestr"] = Processor.process_getCriteriaTimestr
        self._processMap["getCclTime"] = Processor.process_getCclTime
        self._processMap["getCclTimestr"] = Processor.process_getCclTimestr
        self._processMap["getKeyCcl"] = Processor.process_getKeyCcl
        self._processMap["getKeyCriteriaTime"] = Processor.process_getKeyCriteriaTime
        self._processMap["getKeyCriteriaTimestr"] = Processor.process_getKeyCriteriaTimestr
        self._processMap["getKeyCclTime"] = Processor.process_getKeyCclTime
        self._processMap["getKeyCclTimestr"] = Processor.process_getKeyCclTimestr
        self._processMap["getKeysCriteria"] = Processor.process_getKeysCriteria
        self._processMap["getKeysCcl"] = Processor.process_getKeysCcl
        self._processMap["getKeysCriteriaTime"] = Processor.process_getKeysCriteriaTime
        self._processMap["getKeysCriteriaTimestr"] = Processor.process_getKeysCriteriaTimestr
        self._processMap["getKeysCclTime"] = Processor.process_getKeysCclTime
        self._processMap["getKeysCclTimestr"] = Processor.process_getKeysCclTimestr
        self._processMap["verifyKeyValueRecord"] = Processor.process_verifyKeyValueRecord
        self._processMap["verifyKeyValueRecordTime"] = Processor.process_verifyKeyValueRecordTime
        self._processMap["verifyKeyValueRecordTimestr"] = Processor.process_verifyKeyValueRecordTimestr
        self._processMap["jsonifyRecords"] = Processor.process_jsonifyRecords
        self._processMap["jsonifyRecordsTime"] = Processor.process_jsonifyRecordsTime
        self._processMap["jsonifyRecordsTimestr"] = Processor.process_jsonifyRecordsTimestr
        self._processMap["findCriteria"] = Processor.process_findCriteria
        self._processMap["findCcl"] = Processor.process_findCcl
        self._processMap["findKeyOperatorValues"] = Processor.process_findKeyOperatorValues
        self._processMap["findKeyOperatorValuesTime"] = Processor.process_findKeyOperatorValuesTime
        self._processMap["findKeyOperatorValuesTimestr"] = Processor.process_findKeyOperatorValuesTimestr
        self._processMap["findKeyOperatorstrValues"] = Processor.process_findKeyOperatorstrValues
        self._processMap["findKeyOperatorstrValuesTime"] = Processor.process_findKeyOperatorstrValuesTime
        self._processMap["findKeyOperatorstrValuesTimestr"] = Processor.process_findKeyOperatorstrValuesTimestr
        self._processMap["search"] = Processor.process_search
        self._processMap["revertKeysRecordsTime"] = Processor.process_revertKeysRecordsTime
        self._processMap["revertKeysRecordsTimestr"] = Processor.process_revertKeysRecordsTimestr
        self._processMap["revertKeysRecordTime"] = Processor.process_revertKeysRecordTime
        self._processMap["revertKeysRecordTimestr"] = Processor.process_revertKeysRecordTimestr
        self._processMap["revertKeyRecordsTime"] = Processor.process_revertKeyRecordsTime
        self._processMap["revertKeyRecordsTimestr"] = Processor.process_revertKeyRecordsTimestr
        self._processMap["revertKeyRecordTime"] = Processor.process_revertKeyRecordTime
        self._processMap["revertKeyRecordTimestr"] = Processor.process_revertKeyRecordTimestr
        self._processMap["pingRecords"] = Processor.process_pingRecords
        self._processMap["pingRecord"] = Processor.process_pingRecord
        self._processMap["verifyAndSwap"] = Processor.process_verifyAndSwap
        self._processMap["verifyOrSet"] = Processor.process_verifyOrSet
        self._processMap["findOrAddKeyValue"] = Processor.process_findOrAddKeyValue
        self._processMap["findOrInsertCriteriaJson"] = Processor.process_findOrInsertCriteriaJson
        self._processMap["findOrInsertCclJson"] = Processor.process_findOrInsertCclJson
        self._processMap["sumKeyRecord"] = Processor.process_sumKeyRecord
        self._processMap["sumKeyRecordTime"] = Processor.process_sumKeyRecordTime
        self._processMap["sumKeyRecordTimestr"] = Processor.process_sumKeyRecordTimestr
        self._processMap["sumKeyRecords"] = Processor.process_sumKeyRecords
        self._processMap["sumKeyRecordsTime"] = Processor.process_sumKeyRecordsTime
        self._processMap["sumKeyRecordsTimestr"] = Processor.process_sumKeyRecordsTimestr
        self._processMap["sumKey"] = Processor.process_sumKey
        self._processMap["sumKeyTime"] = Processor.process_sumKeyTime
        self._processMap["sumKeyTimestr"] = Processor.process_sumKeyTimestr
        self._processMap["sumKeyCriteria"] = Processor.process_sumKeyCriteria
        self._processMap["sumKeyCriteriaTime"] = Processor.process_sumKeyCriteriaTime
        self._processMap["sumKeyCriteriaTimestr"] = Processor.process_sumKeyCriteriaTimestr
        self._processMap["sumKeyCcl"] = Processor.process_sumKeyCcl
        self._processMap["sumKeyCclTime"] = Processor.process_sumKeyCclTime
        self._processMap["sumKeyCclTimestr"] = Processor.process_sumKeyCclTimestr
        self._processMap["averageKeyRecord"] = Processor.process_averageKeyRecord
        self._processMap["averageKeyRecordTime"] = Processor.process_averageKeyRecordTime
        self._processMap["averageKeyRecordTimestr"] = Processor.process_averageKeyRecordTimestr
        self._processMap["averageKeyRecords"] = Processor.process_averageKeyRecords
        self._processMap["averageKeyRecordsTime"] = Processor.process_averageKeyRecordsTime
        self._processMap["averageKeyRecordsTimestr"] = Processor.process_averageKeyRecordsTimestr
        self._processMap["averageKey"] = Processor.process_averageKey
        self._processMap["averageKeyTime"] = Processor.process_averageKeyTime
        self._processMap["averageKeyTimestr"] = Processor.process_averageKeyTimestr
        self._processMap["averageKeyCriteria"] = Processor.process_averageKeyCriteria
        self._processMap["averageKeyCriteriaTime"] = Processor.process_averageKeyCriteriaTime
        self._processMap["averageKeyCriteriaTimestr"] = Processor.process_averageKeyCriteriaTimestr
        self._processMap["averageKeyCcl"] = Processor.process_averageKeyCcl
        self._processMap["averageKeyCclTime"] = Processor.process_averageKeyCclTime
        self._processMap["averageKeyCclTimestr"] = Processor.process_averageKeyCclTimestr
        self._processMap["countKeyRecord"] = Processor.process_countKeyRecord
        self._processMap["countKeyRecordTime"] = Processor.process_countKeyRecordTime
        self._processMap["countKeyRecordTimestr"] = Processor.process_countKeyRecordTimestr
        self._processMap["countKeyRecords"] = Processor.process_countKeyRecords
        self._processMap["countKeyRecordsTime"] = Processor.process_countKeyRecordsTime
        self._processMap["countKeyRecordsTimestr"] = Processor.process_countKeyRecordsTimestr
        self._processMap["countKey"] = Processor.process_countKey
        self._processMap["countKeyTime"] = Processor.process_countKeyTime
        self._processMap["countKeyTimestr"] = Processor.process_countKeyTimestr
        self._processMap["countKeyCriteria"] = Processor.process_countKeyCriteria
        self._processMap["countKeyCriteriaTime"] = Processor.process_countKeyCriteriaTime
        self._processMap["countKeyCriteriaTimestr"] = Processor.process_countKeyCriteriaTimestr
        self._processMap["countKeyCcl"] = Processor.process_countKeyCcl
        self._processMap["countKeyCclTime"] = Processor.process_countKeyCclTime
        self._processMap["countKeyCclTimestr"] = Processor.process_countKeyCclTimestr
        self._processMap["maxKeyRecord"] = Processor.process_maxKeyRecord
        self._processMap["maxKeyRecordTime"] = Processor.process_maxKeyRecordTime
        self._processMap["maxKeyRecordTimestr"] = Processor.process_maxKeyRecordTimestr
        self._processMap["maxKeyRecords"] = Processor.process_maxKeyRecords
        self._processMap["maxKeyRecordsTime"] = Processor.process_maxKeyRecordsTime
        self._processMap["maxKeyRecordsTimestr"] = Processor.process_maxKeyRecordsTimestr
        self._processMap["maxKeyCriteria"] = Processor.process_maxKeyCriteria
        self._processMap["maxKeyCriteriaTime"] = Processor.process_maxKeyCriteriaTime
        self._processMap["maxKeyCriteriaTimestr"] = Processor.process_maxKeyCriteriaTimestr
        self._processMap["maxKeyCcl"] = Processor.process_maxKeyCcl
        self._processMap["maxKeyCclTime"] = Processor.process_maxKeyCclTime
        self._processMap["maxKeyCclTimestr"] = Processor.process_maxKeyCclTimestr
        self._processMap["maxKey"] = Processor.process_maxKey
        self._processMap["maxKeyTime"] = Processor.process_maxKeyTime
        self._processMap["maxKeyTimestr"] = Processor.process_maxKeyTimestr
        self._processMap["minKeyRecord"] = Processor.process_minKeyRecord
        self._processMap["minKeyRecordTime"] = Processor.process_minKeyRecordTime
        self._processMap["minKeyRecordTimestr"] = Processor.process_minKeyRecordTimestr
        self._processMap["minKey"] = Processor.process_minKey
        self._processMap["minKeyRecordsTime"] = Processor.process_minKeyRecordsTime
        self._processMap["minKeyRecordsTimestr"] = Processor.process_minKeyRecordsTimestr
        self._processMap["minKeyCriteria"] = Processor.process_minKeyCriteria
        self._processMap["minKeyCriteriaTime"] = Processor.process_minKeyCriteriaTime
        self._processMap["minKeyCriteriaTimestr"] = Processor.process_minKeyCriteriaTimestr
        self._processMap["minKeyCcl"] = Processor.process_minKeyCcl
        self._processMap["minKeyCclTime"] = Processor.process_minKeyCclTime
        self._processMap["minKeyCclTimestr"] = Processor.process_minKeyCclTimestr
        self._processMap["minKeyTime"] = Processor.process_minKeyTime
        self._processMap["minKeyTimestr"] = Processor.process_minKeyTimestr
        self._processMap["minKeyRecords"] = Processor.process_minKeyRecords
        self._processMap["navigateKeyRecord"] = Processor.process_navigateKeyRecord
        self._processMap["navigateKeyRecordTime"] = Processor.process_navigateKeyRecordTime
        self._processMap["navigateKeyRecordTimestr"] = Processor.process_navigateKeyRecordTimestr
        self._processMap["navigateKeysRecord"] = Processor.process_navigateKeysRecord
        self._processMap["navigateKeysRecordTime"] = Processor.process_navigateKeysRecordTime
        self._processMap["navigateKeysRecordTimestr"] = Processor.process_navigateKeysRecordTimestr
        self._processMap["navigateKeysRecords"] = Processor.process_navigateKeysRecords
        self._processMap["navigateKeyRecords"] = Processor.process_navigateKeyRecords
        self._processMap["navigateKeyRecordsTime"] = Processor.process_navigateKeyRecordsTime
        self._processMap["navigateKeyRecordsTimestr"] = Processor.process_navigateKeyRecordsTimestr
        self._processMap["navigateKeysRecordsTime"] = Processor.process_navigateKeysRecordsTime
        self._processMap["navigateKeysRecordsTimestr"] = Processor.process_navigateKeysRecordsTimestr
        self._processMap["navigateKeyCcl"] = Processor.process_navigateKeyCcl
        self._processMap["navigateKeyCclTime"] = Processor.process_navigateKeyCclTime
        self._processMap["navigateKeyCclTimestr"] = Processor.process_navigateKeyCclTimestr
        self._processMap["navigateKeysCcl"] = Processor.process_navigateKeysCcl
        self._processMap["navigateKeysCclTime"] = Processor.process_navigateKeysCclTime
        self._processMap["navigateKeysCclTimestr"] = Processor.process_navigateKeysCclTimestr
        self._processMap["navigateKeyCriteria"] = Processor.process_navigateKeyCriteria
        self._processMap["navigateKeyCriteriaTime"] = Processor.process_navigateKeyCriteriaTime
        self._processMap["navigateKeyCriteriaTimestr"] = Processor.process_navigateKeyCriteriaTimestr
        self._processMap["navigateKeysCriteria"] = Processor.process_navigateKeysCriteria
        self._processMap["navigateKeysCriteriaTime"] = Processor.process_navigateKeysCriteriaTime
        self._processMap["navigateKeysCriteriaTimestr"] = Processor.process_navigateKeysCriteriaTimestr
        self._processMap["getServerEnvironment"] = Processor.process_getServerEnvironment
        self._processMap["getServerVersion"] = Processor.process_getServerVersion
        self._processMap["time"] = Processor.process_time
        self._processMap["timePhrase"] = Processor.process_timePhrase
        self._processMap["invokeManagement"] = Processor.process_invokeManagement

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_abort(self, seqid, iprot, oprot):
        args = abort_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = abort_result()
        try:
            self._handler.abort(args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("abort", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addKeyValue(self, seqid, iprot, oprot):
        args = addKeyValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addKeyValue_result()
        try:
            result.success = self._handler.addKeyValue(args.key, args.value, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except InvalidArgumentException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addKeyValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addKeyValueRecord(self, seqid, iprot, oprot):
        args = addKeyValueRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addKeyValueRecord_result()
        try:
            result.success = self._handler.addKeyValueRecord(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except InvalidArgumentException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addKeyValueRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addKeyValueRecords(self, seqid, iprot, oprot):
        args = addKeyValueRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addKeyValueRecords_result()
        try:
            result.success = self._handler.addKeyValueRecords(args.key, args.value, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except InvalidArgumentException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addKeyValueRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_auditRecord(self, seqid, iprot, oprot):
        args = auditRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = auditRecord_result()
        try:
            result.success = self._handler.auditRecord(args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("auditRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_auditRecordStart(self, seqid, iprot, oprot):
        args = auditRecordStart_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = auditRecordStart_result()
        try:
            result.success = self._handler.auditRecordStart(args.record, args.start, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("auditRecordStart", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_auditRecordStartstr(self, seqid, iprot, oprot):
        args = auditRecordStartstr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = auditRecordStartstr_result()
        try:
            result.success = self._handler.auditRecordStartstr(args.record, args.start, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("auditRecordStartstr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_auditRecordStartEnd(self, seqid, iprot, oprot):
        args = auditRecordStartEnd_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = auditRecordStartEnd_result()
        try:
            result.success = self._handler.auditRecordStartEnd(args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("auditRecordStartEnd", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_auditRecordStartstrEndstr(self, seqid, iprot, oprot):
        args = auditRecordStartstrEndstr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = auditRecordStartstrEndstr_result()
        try:
            result.success = self._handler.auditRecordStartstrEndstr(args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("auditRecordStartstrEndstr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_auditKeyRecord(self, seqid, iprot, oprot):
        args = auditKeyRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = auditKeyRecord_result()
        try:
            result.success = self._handler.auditKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("auditKeyRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_auditKeyRecordStart(self, seqid, iprot, oprot):
        args = auditKeyRecordStart_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = auditKeyRecordStart_result()
        try:
            result.success = self._handler.auditKeyRecordStart(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("auditKeyRecordStart", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_auditKeyRecordStartstr(self, seqid, iprot, oprot):
        args = auditKeyRecordStartstr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = auditKeyRecordStartstr_result()
        try:
            result.success = self._handler.auditKeyRecordStartstr(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("auditKeyRecordStartstr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_auditKeyRecordStartEnd(self, seqid, iprot, oprot):
        args = auditKeyRecordStartEnd_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = auditKeyRecordStartEnd_result()
        try:
            result.success = self._handler.auditKeyRecordStartEnd(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("auditKeyRecordStartEnd", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_auditKeyRecordStartstrEndstr(self, seqid, iprot, oprot):
        args = auditKeyRecordStartstrEndstr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = auditKeyRecordStartstrEndstr_result()
        try:
            result.success = self._handler.auditKeyRecordStartstrEndstr(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("auditKeyRecordStartstrEndstr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_browseKey(self, seqid, iprot, oprot):
        args = browseKey_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = browseKey_result()
        try:
            result.success = self._handler.browseKey(args.key, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("browseKey", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_browseKeys(self, seqid, iprot, oprot):
        args = browseKeys_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = browseKeys_result()
        try:
            result.success = self._handler.browseKeys(args.keys, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("browseKeys", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_browseKeyTime(self, seqid, iprot, oprot):
        args = browseKeyTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = browseKeyTime_result()
        try:
            result.success = self._handler.browseKeyTime(args.key, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("browseKeyTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_browseKeyTimestr(self, seqid, iprot, oprot):
        args = browseKeyTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = browseKeyTimestr_result()
        try:
            result.success = self._handler.browseKeyTimestr(args.key, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("browseKeyTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_browseKeysTime(self, seqid, iprot, oprot):
        args = browseKeysTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = browseKeysTime_result()
        try:
            result.success = self._handler.browseKeysTime(args.keys, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("browseKeysTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_browseKeysTimestr(self, seqid, iprot, oprot):
        args = browseKeysTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = browseKeysTimestr_result()
        try:
            result.success = self._handler.browseKeysTimestr(args.keys, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("browseKeysTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_chronologizeKeyRecord(self, seqid, iprot, oprot):
        args = chronologizeKeyRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = chronologizeKeyRecord_result()
        try:
            result.success = self._handler.chronologizeKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("chronologizeKeyRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_chronologizeKeyRecordStart(self, seqid, iprot, oprot):
        args = chronologizeKeyRecordStart_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = chronologizeKeyRecordStart_result()
        try:
            result.success = self._handler.chronologizeKeyRecordStart(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("chronologizeKeyRecordStart", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_chronologizeKeyRecordStartstr(self, seqid, iprot, oprot):
        args = chronologizeKeyRecordStartstr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = chronologizeKeyRecordStartstr_result()
        try:
            result.success = self._handler.chronologizeKeyRecordStartstr(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("chronologizeKeyRecordStartstr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_chronologizeKeyRecordStartEnd(self, seqid, iprot, oprot):
        args = chronologizeKeyRecordStartEnd_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = chronologizeKeyRecordStartEnd_result()
        try:
            result.success = self._handler.chronologizeKeyRecordStartEnd(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("chronologizeKeyRecordStartEnd", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_chronologizeKeyRecordStartstrEndstr(self, seqid, iprot, oprot):
        args = chronologizeKeyRecordStartstrEndstr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = chronologizeKeyRecordStartstrEndstr_result()
        try:
            result.success = self._handler.chronologizeKeyRecordStartstrEndstr(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("chronologizeKeyRecordStartstrEndstr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_clearRecord(self, seqid, iprot, oprot):
        args = clearRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clearRecord_result()
        try:
            self._handler.clearRecord(args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("clearRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_clearRecords(self, seqid, iprot, oprot):
        args = clearRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clearRecords_result()
        try:
            self._handler.clearRecords(args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("clearRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_clearKeyRecord(self, seqid, iprot, oprot):
        args = clearKeyRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clearKeyRecord_result()
        try:
            self._handler.clearKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("clearKeyRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_clearKeysRecord(self, seqid, iprot, oprot):
        args = clearKeysRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clearKeysRecord_result()
        try:
            self._handler.clearKeysRecord(args.keys, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("clearKeysRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_clearKeyRecords(self, seqid, iprot, oprot):
        args = clearKeyRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clearKeyRecords_result()
        try:
            self._handler.clearKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("clearKeyRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_clearKeysRecords(self, seqid, iprot, oprot):
        args = clearKeysRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clearKeysRecords_result()
        try:
            self._handler.clearKeysRecords(args.keys, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("clearKeysRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_commit(self, seqid, iprot, oprot):
        args = commit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = commit_result()
        try:
            result.success = self._handler.commit(args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("commit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_inspect(self, seqid, iprot, oprot):
        args = inspect_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = inspect_result()
        try:
            result.success = self._handler.inspect()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("inspect", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_describe(self, seqid, iprot, oprot):
        args = describe_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = describe_result()
        try:
            result.success = self._handler.describe(args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("describe", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_describeTime(self, seqid, iprot, oprot):
        args = describeTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = describeTime_result()
        try:
            result.success = self._handler.describeTime(args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("describeTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_describeTimestr(self, seqid, iprot, oprot):
        args = describeTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = describeTimestr_result()
        try:
            result.success = self._handler.describeTimestr(args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("describeTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_describeRecord(self, seqid, iprot, oprot):
        args = describeRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = describeRecord_result()
        try:
            result.success = self._handler.describeRecord(args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("describeRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_describeRecordTime(self, seqid, iprot, oprot):
        args = describeRecordTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = describeRecordTime_result()
        try:
            result.success = self._handler.describeRecordTime(args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("describeRecordTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_describeRecordTimestr(self, seqid, iprot, oprot):
        args = describeRecordTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = describeRecordTimestr_result()
        try:
            result.success = self._handler.describeRecordTimestr(args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("describeRecordTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_describeRecords(self, seqid, iprot, oprot):
        args = describeRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = describeRecords_result()
        try:
            result.success = self._handler.describeRecords(args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("describeRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_describeRecordsTime(self, seqid, iprot, oprot):
        args = describeRecordsTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = describeRecordsTime_result()
        try:
            result.success = self._handler.describeRecordsTime(args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("describeRecordsTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_describeRecordsTimestr(self, seqid, iprot, oprot):
        args = describeRecordsTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = describeRecordsTimestr_result()
        try:
            result.success = self._handler.describeRecordsTimestr(args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("describeRecordsTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_diffRecordStart(self, seqid, iprot, oprot):
        args = diffRecordStart_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = diffRecordStart_result()
        try:
            result.success = self._handler.diffRecordStart(args.record, args.start, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("diffRecordStart", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_diffRecordStartstr(self, seqid, iprot, oprot):
        args = diffRecordStartstr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = diffRecordStartstr_result()
        try:
            result.success = self._handler.diffRecordStartstr(args.record, args.start, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("diffRecordStartstr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_diffRecordStartEnd(self, seqid, iprot, oprot):
        args = diffRecordStartEnd_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = diffRecordStartEnd_result()
        try:
            result.success = self._handler.diffRecordStartEnd(args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("diffRecordStartEnd", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_diffRecordStartstrEndstr(self, seqid, iprot, oprot):
        args = diffRecordStartstrEndstr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = diffRecordStartstrEndstr_result()
        try:
            result.success = self._handler.diffRecordStartstrEndstr(args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("diffRecordStartstrEndstr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_diffKeyRecordStart(self, seqid, iprot, oprot):
        args = diffKeyRecordStart_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = diffKeyRecordStart_result()
        try:
            result.success = self._handler.diffKeyRecordStart(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("diffKeyRecordStart", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_diffKeyRecordStartstr(self, seqid, iprot, oprot):
        args = diffKeyRecordStartstr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = diffKeyRecordStartstr_result()
        try:
            result.success = self._handler.diffKeyRecordStartstr(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("diffKeyRecordStartstr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_diffKeyRecordStartEnd(self, seqid, iprot, oprot):
        args = diffKeyRecordStartEnd_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = diffKeyRecordStartEnd_result()
        try:
            result.success = self._handler.diffKeyRecordStartEnd(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("diffKeyRecordStartEnd", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_diffKeyRecordStartstrEndstr(self, seqid, iprot, oprot):
        args = diffKeyRecordStartstrEndstr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = diffKeyRecordStartstrEndstr_result()
        try:
            result.success = self._handler.diffKeyRecordStartstrEndstr(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("diffKeyRecordStartstrEndstr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_diffKeyStart(self, seqid, iprot, oprot):
        args = diffKeyStart_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = diffKeyStart_result()
        try:
            result.success = self._handler.diffKeyStart(args.key, args.start, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("diffKeyStart", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_diffKeyStartstr(self, seqid, iprot, oprot):
        args = diffKeyStartstr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = diffKeyStartstr_result()
        try:
            result.success = self._handler.diffKeyStartstr(args.key, args.start, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("diffKeyStartstr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_diffKeyStartEnd(self, seqid, iprot, oprot):
        args = diffKeyStartEnd_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = diffKeyStartEnd_result()
        try:
            result.success = self._handler.diffKeyStartEnd(args.key, args.start, args.tend, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("diffKeyStartEnd", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_diffKeyStartstrEndstr(self, seqid, iprot, oprot):
        args = diffKeyStartstrEndstr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = diffKeyStartstrEndstr_result()
        try:
            result.success = self._handler.diffKeyStartstrEndstr(args.key, args.start, args.tend, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("diffKeyStartstrEndstr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_invokePlugin(self, seqid, iprot, oprot):
        args = invokePlugin_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = invokePlugin_result()
        try:
            result.success = self._handler.invokePlugin(args.id, args.method, args.params, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except InvalidArgumentException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("invokePlugin", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_login(self, seqid, iprot, oprot):
        args = login_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = login_result()
        try:
            result.success = self._handler.login(args.username, args.password, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except PermissionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("login", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_logout(self, seqid, iprot, oprot):
        args = logout_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = logout_result()
        try:
            self._handler.logout(args.token, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except PermissionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("logout", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stage(self, seqid, iprot, oprot):
        args = stage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stage_result()
        try:
            result.success = self._handler.stage(args.token, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except PermissionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stage", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_insertJson(self, seqid, iprot, oprot):
        args = insertJson_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = insertJson_result()
        try:
            result.success = self._handler.insertJson(args.json, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except InvalidArgumentException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except PermissionException as ex5:
            msg_type = TMessageType.REPLY
            result.ex5 = ex5
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("insertJson", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_insertJsonRecord(self, seqid, iprot, oprot):
        args = insertJsonRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = insertJsonRecord_result()
        try:
            result.success = self._handler.insertJsonRecord(args.json, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except InvalidArgumentException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except PermissionException as ex5:
            msg_type = TMessageType.REPLY
            result.ex5 = ex5
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("insertJsonRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_insertJsonRecords(self, seqid, iprot, oprot):
        args = insertJsonRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = insertJsonRecords_result()
        try:
            result.success = self._handler.insertJsonRecords(args.json, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except InvalidArgumentException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except PermissionException as ex5:
            msg_type = TMessageType.REPLY
            result.ex5 = ex5
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("insertJsonRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeKeyValueRecord(self, seqid, iprot, oprot):
        args = removeKeyValueRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeKeyValueRecord_result()
        try:
            result.success = self._handler.removeKeyValueRecord(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except InvalidArgumentException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeKeyValueRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeKeyValueRecords(self, seqid, iprot, oprot):
        args = removeKeyValueRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeKeyValueRecords_result()
        try:
            result.success = self._handler.removeKeyValueRecords(args.key, args.value, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except InvalidArgumentException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeKeyValueRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setKeyValueRecord(self, seqid, iprot, oprot):
        args = setKeyValueRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setKeyValueRecord_result()
        try:
            self._handler.setKeyValueRecord(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except InvalidArgumentException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setKeyValueRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setKeyValue(self, seqid, iprot, oprot):
        args = setKeyValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setKeyValue_result()
        try:
            result.success = self._handler.setKeyValue(args.key, args.value, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except InvalidArgumentException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setKeyValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setKeyValueRecords(self, seqid, iprot, oprot):
        args = setKeyValueRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setKeyValueRecords_result()
        try:
            self._handler.setKeyValueRecords(args.key, args.value, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except InvalidArgumentException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setKeyValueRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_reconcileKeyRecordValues(self, seqid, iprot, oprot):
        args = reconcileKeyRecordValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reconcileKeyRecordValues_result()
        try:
            self._handler.reconcileKeyRecordValues(args.key, args.record, args.values, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except InvalidArgumentException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("reconcileKeyRecordValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_inventory(self, seqid, iprot, oprot):
        args = inventory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = inventory_result()
        try:
            result.success = self._handler.inventory(args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("inventory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectRecord(self, seqid, iprot, oprot):
        args = selectRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectRecord_result()
        try:
            result.success = self._handler.selectRecord(args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectRecords(self, seqid, iprot, oprot):
        args = selectRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectRecords_result()
        try:
            result.success = self._handler.selectRecords(args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectRecordTime(self, seqid, iprot, oprot):
        args = selectRecordTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectRecordTime_result()
        try:
            result.success = self._handler.selectRecordTime(args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectRecordTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectRecordTimestr(self, seqid, iprot, oprot):
        args = selectRecordTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectRecordTimestr_result()
        try:
            result.success = self._handler.selectRecordTimestr(args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectRecordTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectRecordsTime(self, seqid, iprot, oprot):
        args = selectRecordsTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectRecordsTime_result()
        try:
            result.success = self._handler.selectRecordsTime(args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectRecordsTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectRecordsTimestr(self, seqid, iprot, oprot):
        args = selectRecordsTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectRecordsTimestr_result()
        try:
            result.success = self._handler.selectRecordsTimestr(args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectRecordsTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeyRecord(self, seqid, iprot, oprot):
        args = selectKeyRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeyRecord_result()
        try:
            result.success = self._handler.selectKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeyRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeyRecordTime(self, seqid, iprot, oprot):
        args = selectKeyRecordTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeyRecordTime_result()
        try:
            result.success = self._handler.selectKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeyRecordTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeyRecordTimestr(self, seqid, iprot, oprot):
        args = selectKeyRecordTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeyRecordTimestr_result()
        try:
            result.success = self._handler.selectKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeyRecordTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeysRecord(self, seqid, iprot, oprot):
        args = selectKeysRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeysRecord_result()
        try:
            result.success = self._handler.selectKeysRecord(args.keys, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeysRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeysRecordTime(self, seqid, iprot, oprot):
        args = selectKeysRecordTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeysRecordTime_result()
        try:
            result.success = self._handler.selectKeysRecordTime(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeysRecordTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeysRecordTimestr(self, seqid, iprot, oprot):
        args = selectKeysRecordTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeysRecordTimestr_result()
        try:
            result.success = self._handler.selectKeysRecordTimestr(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeysRecordTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeysRecords(self, seqid, iprot, oprot):
        args = selectKeysRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeysRecords_result()
        try:
            result.success = self._handler.selectKeysRecords(args.keys, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeysRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeyRecords(self, seqid, iprot, oprot):
        args = selectKeyRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeyRecords_result()
        try:
            result.success = self._handler.selectKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeyRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeyRecordsTime(self, seqid, iprot, oprot):
        args = selectKeyRecordsTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeyRecordsTime_result()
        try:
            result.success = self._handler.selectKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeyRecordsTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeyRecordsTimestr(self, seqid, iprot, oprot):
        args = selectKeyRecordsTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeyRecordsTimestr_result()
        try:
            result.success = self._handler.selectKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeyRecordsTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeysRecordsTime(self, seqid, iprot, oprot):
        args = selectKeysRecordsTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeysRecordsTime_result()
        try:
            result.success = self._handler.selectKeysRecordsTime(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeysRecordsTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeysRecordsTimestr(self, seqid, iprot, oprot):
        args = selectKeysRecordsTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeysRecordsTimestr_result()
        try:
            result.success = self._handler.selectKeysRecordsTimestr(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeysRecordsTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectCriteria(self, seqid, iprot, oprot):
        args = selectCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectCriteria_result()
        try:
            result.success = self._handler.selectCriteria(args.criteria, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectCcl(self, seqid, iprot, oprot):
        args = selectCcl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectCcl_result()
        try:
            result.success = self._handler.selectCcl(args.ccl, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectCcl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectCriteriaTime(self, seqid, iprot, oprot):
        args = selectCriteriaTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectCriteriaTime_result()
        try:
            result.success = self._handler.selectCriteriaTime(args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectCriteriaTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectCriteriaTimestr(self, seqid, iprot, oprot):
        args = selectCriteriaTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectCriteriaTimestr_result()
        try:
            result.success = self._handler.selectCriteriaTimestr(args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectCriteriaTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectCclTime(self, seqid, iprot, oprot):
        args = selectCclTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectCclTime_result()
        try:
            result.success = self._handler.selectCclTime(args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectCclTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectCclTimestr(self, seqid, iprot, oprot):
        args = selectCclTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectCclTimestr_result()
        try:
            result.success = self._handler.selectCclTimestr(args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectCclTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeyCriteria(self, seqid, iprot, oprot):
        args = selectKeyCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeyCriteria_result()
        try:
            result.success = self._handler.selectKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeyCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeyCcl(self, seqid, iprot, oprot):
        args = selectKeyCcl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeyCcl_result()
        try:
            result.success = self._handler.selectKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeyCcl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeyCriteriaTime(self, seqid, iprot, oprot):
        args = selectKeyCriteriaTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeyCriteriaTime_result()
        try:
            result.success = self._handler.selectKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeyCriteriaTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeyCriteriaTimestr(self, seqid, iprot, oprot):
        args = selectKeyCriteriaTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeyCriteriaTimestr_result()
        try:
            result.success = self._handler.selectKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeyCriteriaTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeyCclTime(self, seqid, iprot, oprot):
        args = selectKeyCclTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeyCclTime_result()
        try:
            result.success = self._handler.selectKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeyCclTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeyCclTimestr(self, seqid, iprot, oprot):
        args = selectKeyCclTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeyCclTimestr_result()
        try:
            result.success = self._handler.selectKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeyCclTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeysCriteria(self, seqid, iprot, oprot):
        args = selectKeysCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeysCriteria_result()
        try:
            result.success = self._handler.selectKeysCriteria(args.keys, args.criteria, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeysCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeysCcl(self, seqid, iprot, oprot):
        args = selectKeysCcl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeysCcl_result()
        try:
            result.success = self._handler.selectKeysCcl(args.keys, args.ccl, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeysCcl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeysCriteriaTime(self, seqid, iprot, oprot):
        args = selectKeysCriteriaTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeysCriteriaTime_result()
        try:
            result.success = self._handler.selectKeysCriteriaTime(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeysCriteriaTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeysCriteriaTimestr(self, seqid, iprot, oprot):
        args = selectKeysCriteriaTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeysCriteriaTimestr_result()
        try:
            result.success = self._handler.selectKeysCriteriaTimestr(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeysCriteriaTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeysCclTime(self, seqid, iprot, oprot):
        args = selectKeysCclTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeysCclTime_result()
        try:
            result.success = self._handler.selectKeysCclTime(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeysCclTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_selectKeysCclTimestr(self, seqid, iprot, oprot):
        args = selectKeysCclTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = selectKeysCclTimestr_result()
        try:
            result.success = self._handler.selectKeysCclTimestr(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("selectKeysCclTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeyRecord(self, seqid, iprot, oprot):
        args = getKeyRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeyRecord_result()
        try:
            result.success = self._handler.getKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeyRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeyRecordTime(self, seqid, iprot, oprot):
        args = getKeyRecordTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeyRecordTime_result()
        try:
            result.success = self._handler.getKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeyRecordTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeyRecordTimestr(self, seqid, iprot, oprot):
        args = getKeyRecordTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeyRecordTimestr_result()
        try:
            result.success = self._handler.getKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeyRecordTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeysRecord(self, seqid, iprot, oprot):
        args = getKeysRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeysRecord_result()
        try:
            result.success = self._handler.getKeysRecord(args.keys, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeysRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeysRecordTime(self, seqid, iprot, oprot):
        args = getKeysRecordTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeysRecordTime_result()
        try:
            result.success = self._handler.getKeysRecordTime(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeysRecordTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeysRecordTimestr(self, seqid, iprot, oprot):
        args = getKeysRecordTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeysRecordTimestr_result()
        try:
            result.success = self._handler.getKeysRecordTimestr(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeysRecordTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeysRecords(self, seqid, iprot, oprot):
        args = getKeysRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeysRecords_result()
        try:
            result.success = self._handler.getKeysRecords(args.keys, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeysRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeyRecords(self, seqid, iprot, oprot):
        args = getKeyRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeyRecords_result()
        try:
            result.success = self._handler.getKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeyRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeyRecordsTime(self, seqid, iprot, oprot):
        args = getKeyRecordsTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeyRecordsTime_result()
        try:
            result.success = self._handler.getKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeyRecordsTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeyRecordsTimestr(self, seqid, iprot, oprot):
        args = getKeyRecordsTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeyRecordsTimestr_result()
        try:
            result.success = self._handler.getKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeyRecordsTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeysRecordsTime(self, seqid, iprot, oprot):
        args = getKeysRecordsTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeysRecordsTime_result()
        try:
            result.success = self._handler.getKeysRecordsTime(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeysRecordsTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeysRecordsTimestr(self, seqid, iprot, oprot):
        args = getKeysRecordsTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeysRecordsTimestr_result()
        try:
            result.success = self._handler.getKeysRecordsTimestr(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeysRecordsTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeyCriteria(self, seqid, iprot, oprot):
        args = getKeyCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeyCriteria_result()
        try:
            result.success = self._handler.getKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeyCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCriteria(self, seqid, iprot, oprot):
        args = getCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCriteria_result()
        try:
            result.success = self._handler.getCriteria(args.criteria, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCcl(self, seqid, iprot, oprot):
        args = getCcl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCcl_result()
        try:
            result.success = self._handler.getCcl(args.ccl, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCcl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCriteriaTime(self, seqid, iprot, oprot):
        args = getCriteriaTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCriteriaTime_result()
        try:
            result.success = self._handler.getCriteriaTime(args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCriteriaTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCriteriaTimestr(self, seqid, iprot, oprot):
        args = getCriteriaTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCriteriaTimestr_result()
        try:
            result.success = self._handler.getCriteriaTimestr(args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCriteriaTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCclTime(self, seqid, iprot, oprot):
        args = getCclTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCclTime_result()
        try:
            result.success = self._handler.getCclTime(args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCclTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCclTimestr(self, seqid, iprot, oprot):
        args = getCclTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCclTimestr_result()
        try:
            result.success = self._handler.getCclTimestr(args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCclTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeyCcl(self, seqid, iprot, oprot):
        args = getKeyCcl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeyCcl_result()
        try:
            result.success = self._handler.getKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeyCcl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeyCriteriaTime(self, seqid, iprot, oprot):
        args = getKeyCriteriaTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeyCriteriaTime_result()
        try:
            result.success = self._handler.getKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeyCriteriaTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeyCriteriaTimestr(self, seqid, iprot, oprot):
        args = getKeyCriteriaTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeyCriteriaTimestr_result()
        try:
            result.success = self._handler.getKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeyCriteriaTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeyCclTime(self, seqid, iprot, oprot):
        args = getKeyCclTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeyCclTime_result()
        try:
            result.success = self._handler.getKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeyCclTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeyCclTimestr(self, seqid, iprot, oprot):
        args = getKeyCclTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeyCclTimestr_result()
        try:
            result.success = self._handler.getKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeyCclTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeysCriteria(self, seqid, iprot, oprot):
        args = getKeysCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeysCriteria_result()
        try:
            result.success = self._handler.getKeysCriteria(args.keys, args.criteria, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeysCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeysCcl(self, seqid, iprot, oprot):
        args = getKeysCcl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeysCcl_result()
        try:
            result.success = self._handler.getKeysCcl(args.keys, args.ccl, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeysCcl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeysCriteriaTime(self, seqid, iprot, oprot):
        args = getKeysCriteriaTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeysCriteriaTime_result()
        try:
            result.success = self._handler.getKeysCriteriaTime(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeysCriteriaTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeysCriteriaTimestr(self, seqid, iprot, oprot):
        args = getKeysCriteriaTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeysCriteriaTimestr_result()
        try:
            result.success = self._handler.getKeysCriteriaTimestr(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeysCriteriaTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeysCclTime(self, seqid, iprot, oprot):
        args = getKeysCclTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeysCclTime_result()
        try:
            result.success = self._handler.getKeysCclTime(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeysCclTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getKeysCclTimestr(self, seqid, iprot, oprot):
        args = getKeysCclTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getKeysCclTimestr_result()
        try:
            result.success = self._handler.getKeysCclTimestr(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getKeysCclTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_verifyKeyValueRecord(self, seqid, iprot, oprot):
        args = verifyKeyValueRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verifyKeyValueRecord_result()
        try:
            result.success = self._handler.verifyKeyValueRecord(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("verifyKeyValueRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_verifyKeyValueRecordTime(self, seqid, iprot, oprot):
        args = verifyKeyValueRecordTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verifyKeyValueRecordTime_result()
        try:
            result.success = self._handler.verifyKeyValueRecordTime(args.key, args.value, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("verifyKeyValueRecordTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_verifyKeyValueRecordTimestr(self, seqid, iprot, oprot):
        args = verifyKeyValueRecordTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verifyKeyValueRecordTimestr_result()
        try:
            result.success = self._handler.verifyKeyValueRecordTimestr(args.key, args.value, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("verifyKeyValueRecordTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_jsonifyRecords(self, seqid, iprot, oprot):
        args = jsonifyRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = jsonifyRecords_result()
        try:
            result.success = self._handler.jsonifyRecords(args.records, args.identifier, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("jsonifyRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_jsonifyRecordsTime(self, seqid, iprot, oprot):
        args = jsonifyRecordsTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = jsonifyRecordsTime_result()
        try:
            result.success = self._handler.jsonifyRecordsTime(args.records, args.timestamp, args.identifier, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("jsonifyRecordsTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_jsonifyRecordsTimestr(self, seqid, iprot, oprot):
        args = jsonifyRecordsTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = jsonifyRecordsTimestr_result()
        try:
            result.success = self._handler.jsonifyRecordsTimestr(args.records, args.timestamp, args.identifier, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("jsonifyRecordsTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findCriteria(self, seqid, iprot, oprot):
        args = findCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findCriteria_result()
        try:
            result.success = self._handler.findCriteria(args.criteria, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findCcl(self, seqid, iprot, oprot):
        args = findCcl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findCcl_result()
        try:
            result.success = self._handler.findCcl(args.ccl, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findCcl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findKeyOperatorValues(self, seqid, iprot, oprot):
        args = findKeyOperatorValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findKeyOperatorValues_result()
        try:
            result.success = self._handler.findKeyOperatorValues(args.key, args.operator, args.values, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findKeyOperatorValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findKeyOperatorValuesTime(self, seqid, iprot, oprot):
        args = findKeyOperatorValuesTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findKeyOperatorValuesTime_result()
        try:
            result.success = self._handler.findKeyOperatorValuesTime(args.key, args.operator, args.values, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findKeyOperatorValuesTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findKeyOperatorValuesTimestr(self, seqid, iprot, oprot):
        args = findKeyOperatorValuesTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findKeyOperatorValuesTimestr_result()
        try:
            result.success = self._handler.findKeyOperatorValuesTimestr(args.key, args.operator, args.values, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findKeyOperatorValuesTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findKeyOperatorstrValues(self, seqid, iprot, oprot):
        args = findKeyOperatorstrValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findKeyOperatorstrValues_result()
        try:
            result.success = self._handler.findKeyOperatorstrValues(args.key, args.operator, args.values, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findKeyOperatorstrValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findKeyOperatorstrValuesTime(self, seqid, iprot, oprot):
        args = findKeyOperatorstrValuesTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findKeyOperatorstrValuesTime_result()
        try:
            result.success = self._handler.findKeyOperatorstrValuesTime(args.key, args.operator, args.values, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findKeyOperatorstrValuesTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findKeyOperatorstrValuesTimestr(self, seqid, iprot, oprot):
        args = findKeyOperatorstrValuesTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findKeyOperatorstrValuesTimestr_result()
        try:
            result.success = self._handler.findKeyOperatorstrValuesTimestr(args.key, args.operator, args.values, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findKeyOperatorstrValuesTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_search(self, seqid, iprot, oprot):
        args = search_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = search_result()
        try:
            result.success = self._handler.search(args.key, args.query, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("search", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revertKeysRecordsTime(self, seqid, iprot, oprot):
        args = revertKeysRecordsTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revertKeysRecordsTime_result()
        try:
            self._handler.revertKeysRecordsTime(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revertKeysRecordsTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revertKeysRecordsTimestr(self, seqid, iprot, oprot):
        args = revertKeysRecordsTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revertKeysRecordsTimestr_result()
        try:
            self._handler.revertKeysRecordsTimestr(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revertKeysRecordsTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revertKeysRecordTime(self, seqid, iprot, oprot):
        args = revertKeysRecordTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revertKeysRecordTime_result()
        try:
            self._handler.revertKeysRecordTime(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revertKeysRecordTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revertKeysRecordTimestr(self, seqid, iprot, oprot):
        args = revertKeysRecordTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revertKeysRecordTimestr_result()
        try:
            self._handler.revertKeysRecordTimestr(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revertKeysRecordTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revertKeyRecordsTime(self, seqid, iprot, oprot):
        args = revertKeyRecordsTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revertKeyRecordsTime_result()
        try:
            self._handler.revertKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revertKeyRecordsTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revertKeyRecordsTimestr(self, seqid, iprot, oprot):
        args = revertKeyRecordsTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revertKeyRecordsTimestr_result()
        try:
            self._handler.revertKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revertKeyRecordsTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revertKeyRecordTime(self, seqid, iprot, oprot):
        args = revertKeyRecordTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revertKeyRecordTime_result()
        try:
            self._handler.revertKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revertKeyRecordTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revertKeyRecordTimestr(self, seqid, iprot, oprot):
        args = revertKeyRecordTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revertKeyRecordTimestr_result()
        try:
            self._handler.revertKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revertKeyRecordTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pingRecords(self, seqid, iprot, oprot):
        args = pingRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pingRecords_result()
        try:
            result.success = self._handler.pingRecords(args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pingRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pingRecord(self, seqid, iprot, oprot):
        args = pingRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pingRecord_result()
        try:
            result.success = self._handler.pingRecord(args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pingRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_verifyAndSwap(self, seqid, iprot, oprot):
        args = verifyAndSwap_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verifyAndSwap_result()
        try:
            result.success = self._handler.verifyAndSwap(args.key, args.expected, args.record, args.replacement, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("verifyAndSwap", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_verifyOrSet(self, seqid, iprot, oprot):
        args = verifyOrSet_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verifyOrSet_result()
        try:
            self._handler.verifyOrSet(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except InvalidArgumentException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("verifyOrSet", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findOrAddKeyValue(self, seqid, iprot, oprot):
        args = findOrAddKeyValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findOrAddKeyValue_result()
        try:
            result.success = self._handler.findOrAddKeyValue(args.key, args.value, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except DuplicateEntryException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except InvalidArgumentException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except PermissionException as ex5:
            msg_type = TMessageType.REPLY
            result.ex5 = ex5
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findOrAddKeyValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findOrInsertCriteriaJson(self, seqid, iprot, oprot):
        args = findOrInsertCriteriaJson_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findOrInsertCriteriaJson_result()
        try:
            result.success = self._handler.findOrInsertCriteriaJson(args.criteria, args.json, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except DuplicateEntryException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findOrInsertCriteriaJson", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findOrInsertCclJson(self, seqid, iprot, oprot):
        args = findOrInsertCclJson_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findOrInsertCclJson_result()
        try:
            result.success = self._handler.findOrInsertCclJson(args.ccl, args.json, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except DuplicateEntryException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except PermissionException as ex5:
            msg_type = TMessageType.REPLY
            result.ex5 = ex5
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findOrInsertCclJson", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sumKeyRecord(self, seqid, iprot, oprot):
        args = sumKeyRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sumKeyRecord_result()
        try:
            result.success = self._handler.sumKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sumKeyRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sumKeyRecordTime(self, seqid, iprot, oprot):
        args = sumKeyRecordTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sumKeyRecordTime_result()
        try:
            result.success = self._handler.sumKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sumKeyRecordTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sumKeyRecordTimestr(self, seqid, iprot, oprot):
        args = sumKeyRecordTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sumKeyRecordTimestr_result()
        try:
            result.success = self._handler.sumKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sumKeyRecordTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sumKeyRecords(self, seqid, iprot, oprot):
        args = sumKeyRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sumKeyRecords_result()
        try:
            result.success = self._handler.sumKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sumKeyRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sumKeyRecordsTime(self, seqid, iprot, oprot):
        args = sumKeyRecordsTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sumKeyRecordsTime_result()
        try:
            result.success = self._handler.sumKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sumKeyRecordsTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sumKeyRecordsTimestr(self, seqid, iprot, oprot):
        args = sumKeyRecordsTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sumKeyRecordsTimestr_result()
        try:
            result.success = self._handler.sumKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sumKeyRecordsTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sumKey(self, seqid, iprot, oprot):
        args = sumKey_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sumKey_result()
        try:
            result.success = self._handler.sumKey(args.key, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sumKey", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sumKeyTime(self, seqid, iprot, oprot):
        args = sumKeyTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sumKeyTime_result()
        try:
            result.success = self._handler.sumKeyTime(args.key, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sumKeyTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sumKeyTimestr(self, seqid, iprot, oprot):
        args = sumKeyTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sumKeyTimestr_result()
        try:
            result.success = self._handler.sumKeyTimestr(args.key, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sumKeyTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sumKeyCriteria(self, seqid, iprot, oprot):
        args = sumKeyCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sumKeyCriteria_result()
        try:
            result.success = self._handler.sumKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sumKeyCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sumKeyCriteriaTime(self, seqid, iprot, oprot):
        args = sumKeyCriteriaTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sumKeyCriteriaTime_result()
        try:
            result.success = self._handler.sumKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sumKeyCriteriaTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sumKeyCriteriaTimestr(self, seqid, iprot, oprot):
        args = sumKeyCriteriaTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sumKeyCriteriaTimestr_result()
        try:
            result.success = self._handler.sumKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sumKeyCriteriaTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sumKeyCcl(self, seqid, iprot, oprot):
        args = sumKeyCcl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sumKeyCcl_result()
        try:
            result.success = self._handler.sumKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sumKeyCcl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sumKeyCclTime(self, seqid, iprot, oprot):
        args = sumKeyCclTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sumKeyCclTime_result()
        try:
            result.success = self._handler.sumKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sumKeyCclTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sumKeyCclTimestr(self, seqid, iprot, oprot):
        args = sumKeyCclTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sumKeyCclTimestr_result()
        try:
            result.success = self._handler.sumKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sumKeyCclTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_averageKeyRecord(self, seqid, iprot, oprot):
        args = averageKeyRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = averageKeyRecord_result()
        try:
            result.success = self._handler.averageKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("averageKeyRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_averageKeyRecordTime(self, seqid, iprot, oprot):
        args = averageKeyRecordTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = averageKeyRecordTime_result()
        try:
            result.success = self._handler.averageKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("averageKeyRecordTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_averageKeyRecordTimestr(self, seqid, iprot, oprot):
        args = averageKeyRecordTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = averageKeyRecordTimestr_result()
        try:
            result.success = self._handler.averageKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("averageKeyRecordTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_averageKeyRecords(self, seqid, iprot, oprot):
        args = averageKeyRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = averageKeyRecords_result()
        try:
            result.success = self._handler.averageKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("averageKeyRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_averageKeyRecordsTime(self, seqid, iprot, oprot):
        args = averageKeyRecordsTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = averageKeyRecordsTime_result()
        try:
            result.success = self._handler.averageKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("averageKeyRecordsTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_averageKeyRecordsTimestr(self, seqid, iprot, oprot):
        args = averageKeyRecordsTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = averageKeyRecordsTimestr_result()
        try:
            result.success = self._handler.averageKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("averageKeyRecordsTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_averageKey(self, seqid, iprot, oprot):
        args = averageKey_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = averageKey_result()
        try:
            result.success = self._handler.averageKey(args.key, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("averageKey", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_averageKeyTime(self, seqid, iprot, oprot):
        args = averageKeyTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = averageKeyTime_result()
        try:
            result.success = self._handler.averageKeyTime(args.key, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("averageKeyTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_averageKeyTimestr(self, seqid, iprot, oprot):
        args = averageKeyTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = averageKeyTimestr_result()
        try:
            result.success = self._handler.averageKeyTimestr(args.key, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("averageKeyTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_averageKeyCriteria(self, seqid, iprot, oprot):
        args = averageKeyCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = averageKeyCriteria_result()
        try:
            result.success = self._handler.averageKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("averageKeyCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_averageKeyCriteriaTime(self, seqid, iprot, oprot):
        args = averageKeyCriteriaTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = averageKeyCriteriaTime_result()
        try:
            result.success = self._handler.averageKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("averageKeyCriteriaTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_averageKeyCriteriaTimestr(self, seqid, iprot, oprot):
        args = averageKeyCriteriaTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = averageKeyCriteriaTimestr_result()
        try:
            result.success = self._handler.averageKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("averageKeyCriteriaTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_averageKeyCcl(self, seqid, iprot, oprot):
        args = averageKeyCcl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = averageKeyCcl_result()
        try:
            result.success = self._handler.averageKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("averageKeyCcl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_averageKeyCclTime(self, seqid, iprot, oprot):
        args = averageKeyCclTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = averageKeyCclTime_result()
        try:
            result.success = self._handler.averageKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("averageKeyCclTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_averageKeyCclTimestr(self, seqid, iprot, oprot):
        args = averageKeyCclTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = averageKeyCclTimestr_result()
        try:
            result.success = self._handler.averageKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("averageKeyCclTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_countKeyRecord(self, seqid, iprot, oprot):
        args = countKeyRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = countKeyRecord_result()
        try:
            result.success = self._handler.countKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("countKeyRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_countKeyRecordTime(self, seqid, iprot, oprot):
        args = countKeyRecordTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = countKeyRecordTime_result()
        try:
            result.success = self._handler.countKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("countKeyRecordTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_countKeyRecordTimestr(self, seqid, iprot, oprot):
        args = countKeyRecordTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = countKeyRecordTimestr_result()
        try:
            result.success = self._handler.countKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("countKeyRecordTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_countKeyRecords(self, seqid, iprot, oprot):
        args = countKeyRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = countKeyRecords_result()
        try:
            result.success = self._handler.countKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("countKeyRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_countKeyRecordsTime(self, seqid, iprot, oprot):
        args = countKeyRecordsTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = countKeyRecordsTime_result()
        try:
            result.success = self._handler.countKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("countKeyRecordsTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_countKeyRecordsTimestr(self, seqid, iprot, oprot):
        args = countKeyRecordsTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = countKeyRecordsTimestr_result()
        try:
            result.success = self._handler.countKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("countKeyRecordsTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_countKey(self, seqid, iprot, oprot):
        args = countKey_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = countKey_result()
        try:
            result.success = self._handler.countKey(args.key, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("countKey", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_countKeyTime(self, seqid, iprot, oprot):
        args = countKeyTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = countKeyTime_result()
        try:
            result.success = self._handler.countKeyTime(args.key, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("countKeyTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_countKeyTimestr(self, seqid, iprot, oprot):
        args = countKeyTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = countKeyTimestr_result()
        try:
            result.success = self._handler.countKeyTimestr(args.key, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("countKeyTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_countKeyCriteria(self, seqid, iprot, oprot):
        args = countKeyCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = countKeyCriteria_result()
        try:
            result.success = self._handler.countKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("countKeyCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_countKeyCriteriaTime(self, seqid, iprot, oprot):
        args = countKeyCriteriaTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = countKeyCriteriaTime_result()
        try:
            result.success = self._handler.countKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("countKeyCriteriaTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_countKeyCriteriaTimestr(self, seqid, iprot, oprot):
        args = countKeyCriteriaTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = countKeyCriteriaTimestr_result()
        try:
            result.success = self._handler.countKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("countKeyCriteriaTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_countKeyCcl(self, seqid, iprot, oprot):
        args = countKeyCcl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = countKeyCcl_result()
        try:
            result.success = self._handler.countKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("countKeyCcl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_countKeyCclTime(self, seqid, iprot, oprot):
        args = countKeyCclTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = countKeyCclTime_result()
        try:
            result.success = self._handler.countKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("countKeyCclTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_countKeyCclTimestr(self, seqid, iprot, oprot):
        args = countKeyCclTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = countKeyCclTimestr_result()
        try:
            result.success = self._handler.countKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("countKeyCclTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_maxKeyRecord(self, seqid, iprot, oprot):
        args = maxKeyRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = maxKeyRecord_result()
        try:
            result.success = self._handler.maxKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("maxKeyRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_maxKeyRecordTime(self, seqid, iprot, oprot):
        args = maxKeyRecordTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = maxKeyRecordTime_result()
        try:
            result.success = self._handler.maxKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("maxKeyRecordTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_maxKeyRecordTimestr(self, seqid, iprot, oprot):
        args = maxKeyRecordTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = maxKeyRecordTimestr_result()
        try:
            result.success = self._handler.maxKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("maxKeyRecordTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_maxKeyRecords(self, seqid, iprot, oprot):
        args = maxKeyRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = maxKeyRecords_result()
        try:
            result.success = self._handler.maxKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("maxKeyRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_maxKeyRecordsTime(self, seqid, iprot, oprot):
        args = maxKeyRecordsTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = maxKeyRecordsTime_result()
        try:
            result.success = self._handler.maxKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("maxKeyRecordsTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_maxKeyRecordsTimestr(self, seqid, iprot, oprot):
        args = maxKeyRecordsTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = maxKeyRecordsTimestr_result()
        try:
            result.success = self._handler.maxKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("maxKeyRecordsTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_maxKeyCriteria(self, seqid, iprot, oprot):
        args = maxKeyCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = maxKeyCriteria_result()
        try:
            result.success = self._handler.maxKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("maxKeyCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_maxKeyCriteriaTime(self, seqid, iprot, oprot):
        args = maxKeyCriteriaTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = maxKeyCriteriaTime_result()
        try:
            result.success = self._handler.maxKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("maxKeyCriteriaTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_maxKeyCriteriaTimestr(self, seqid, iprot, oprot):
        args = maxKeyCriteriaTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = maxKeyCriteriaTimestr_result()
        try:
            result.success = self._handler.maxKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("maxKeyCriteriaTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_maxKeyCcl(self, seqid, iprot, oprot):
        args = maxKeyCcl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = maxKeyCcl_result()
        try:
            result.success = self._handler.maxKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("maxKeyCcl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_maxKeyCclTime(self, seqid, iprot, oprot):
        args = maxKeyCclTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = maxKeyCclTime_result()
        try:
            result.success = self._handler.maxKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("maxKeyCclTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_maxKeyCclTimestr(self, seqid, iprot, oprot):
        args = maxKeyCclTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = maxKeyCclTimestr_result()
        try:
            result.success = self._handler.maxKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("maxKeyCclTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_maxKey(self, seqid, iprot, oprot):
        args = maxKey_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = maxKey_result()
        try:
            result.success = self._handler.maxKey(args.key, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("maxKey", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_maxKeyTime(self, seqid, iprot, oprot):
        args = maxKeyTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = maxKeyTime_result()
        try:
            result.success = self._handler.maxKeyTime(args.key, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("maxKeyTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_maxKeyTimestr(self, seqid, iprot, oprot):
        args = maxKeyTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = maxKeyTimestr_result()
        try:
            result.success = self._handler.maxKeyTimestr(args.key, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("maxKeyTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_minKeyRecord(self, seqid, iprot, oprot):
        args = minKeyRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = minKeyRecord_result()
        try:
            result.success = self._handler.minKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("minKeyRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_minKeyRecordTime(self, seqid, iprot, oprot):
        args = minKeyRecordTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = minKeyRecordTime_result()
        try:
            result.success = self._handler.minKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("minKeyRecordTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_minKeyRecordTimestr(self, seqid, iprot, oprot):
        args = minKeyRecordTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = minKeyRecordTimestr_result()
        try:
            result.success = self._handler.minKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("minKeyRecordTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_minKey(self, seqid, iprot, oprot):
        args = minKey_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = minKey_result()
        try:
            result.success = self._handler.minKey(args.key, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("minKey", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_minKeyRecordsTime(self, seqid, iprot, oprot):
        args = minKeyRecordsTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = minKeyRecordsTime_result()
        try:
            result.success = self._handler.minKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("minKeyRecordsTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_minKeyRecordsTimestr(self, seqid, iprot, oprot):
        args = minKeyRecordsTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = minKeyRecordsTimestr_result()
        try:
            result.success = self._handler.minKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("minKeyRecordsTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_minKeyCriteria(self, seqid, iprot, oprot):
        args = minKeyCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = minKeyCriteria_result()
        try:
            result.success = self._handler.minKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("minKeyCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_minKeyCriteriaTime(self, seqid, iprot, oprot):
        args = minKeyCriteriaTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = minKeyCriteriaTime_result()
        try:
            result.success = self._handler.minKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("minKeyCriteriaTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_minKeyCriteriaTimestr(self, seqid, iprot, oprot):
        args = minKeyCriteriaTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = minKeyCriteriaTimestr_result()
        try:
            result.success = self._handler.minKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("minKeyCriteriaTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_minKeyCcl(self, seqid, iprot, oprot):
        args = minKeyCcl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = minKeyCcl_result()
        try:
            result.success = self._handler.minKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("minKeyCcl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_minKeyCclTime(self, seqid, iprot, oprot):
        args = minKeyCclTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = minKeyCclTime_result()
        try:
            result.success = self._handler.minKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("minKeyCclTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_minKeyCclTimestr(self, seqid, iprot, oprot):
        args = minKeyCclTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = minKeyCclTimestr_result()
        try:
            result.success = self._handler.minKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("minKeyCclTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_minKeyTime(self, seqid, iprot, oprot):
        args = minKeyTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = minKeyTime_result()
        try:
            result.success = self._handler.minKeyTime(args.key, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("minKeyTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_minKeyTimestr(self, seqid, iprot, oprot):
        args = minKeyTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = minKeyTimestr_result()
        try:
            result.success = self._handler.minKeyTimestr(args.key, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("minKeyTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_minKeyRecords(self, seqid, iprot, oprot):
        args = minKeyRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = minKeyRecords_result()
        try:
            result.success = self._handler.minKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("minKeyRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeyRecord(self, seqid, iprot, oprot):
        args = navigateKeyRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeyRecord_result()
        try:
            result.success = self._handler.navigateKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeyRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeyRecordTime(self, seqid, iprot, oprot):
        args = navigateKeyRecordTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeyRecordTime_result()
        try:
            result.success = self._handler.navigateKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeyRecordTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeyRecordTimestr(self, seqid, iprot, oprot):
        args = navigateKeyRecordTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeyRecordTimestr_result()
        try:
            result.success = self._handler.navigateKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeyRecordTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeysRecord(self, seqid, iprot, oprot):
        args = navigateKeysRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeysRecord_result()
        try:
            result.success = self._handler.navigateKeysRecord(args.keys, args.record, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeysRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeysRecordTime(self, seqid, iprot, oprot):
        args = navigateKeysRecordTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeysRecordTime_result()
        try:
            result.success = self._handler.navigateKeysRecordTime(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeysRecordTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeysRecordTimestr(self, seqid, iprot, oprot):
        args = navigateKeysRecordTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeysRecordTimestr_result()
        try:
            result.success = self._handler.navigateKeysRecordTimestr(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeysRecordTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeysRecords(self, seqid, iprot, oprot):
        args = navigateKeysRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeysRecords_result()
        try:
            result.success = self._handler.navigateKeysRecords(args.keys, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeysRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeyRecords(self, seqid, iprot, oprot):
        args = navigateKeyRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeyRecords_result()
        try:
            result.success = self._handler.navigateKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeyRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeyRecordsTime(self, seqid, iprot, oprot):
        args = navigateKeyRecordsTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeyRecordsTime_result()
        try:
            result.success = self._handler.navigateKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeyRecordsTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeyRecordsTimestr(self, seqid, iprot, oprot):
        args = navigateKeyRecordsTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeyRecordsTimestr_result()
        try:
            result.success = self._handler.navigateKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeyRecordsTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeysRecordsTime(self, seqid, iprot, oprot):
        args = navigateKeysRecordsTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeysRecordsTime_result()
        try:
            result.success = self._handler.navigateKeysRecordsTime(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeysRecordsTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeysRecordsTimestr(self, seqid, iprot, oprot):
        args = navigateKeysRecordsTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeysRecordsTimestr_result()
        try:
            result.success = self._handler.navigateKeysRecordsTimestr(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeysRecordsTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeyCcl(self, seqid, iprot, oprot):
        args = navigateKeyCcl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeyCcl_result()
        try:
            result.success = self._handler.navigateKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeyCcl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeyCclTime(self, seqid, iprot, oprot):
        args = navigateKeyCclTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeyCclTime_result()
        try:
            result.success = self._handler.navigateKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeyCclTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeyCclTimestr(self, seqid, iprot, oprot):
        args = navigateKeyCclTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeyCclTimestr_result()
        try:
            result.success = self._handler.navigateKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeyCclTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeysCcl(self, seqid, iprot, oprot):
        args = navigateKeysCcl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeysCcl_result()
        try:
            result.success = self._handler.navigateKeysCcl(args.keys, args.ccl, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeysCcl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeysCclTime(self, seqid, iprot, oprot):
        args = navigateKeysCclTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeysCclTime_result()
        try:
            result.success = self._handler.navigateKeysCclTime(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeysCclTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeysCclTimestr(self, seqid, iprot, oprot):
        args = navigateKeysCclTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeysCclTimestr_result()
        try:
            result.success = self._handler.navigateKeysCclTimestr(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeysCclTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeyCriteria(self, seqid, iprot, oprot):
        args = navigateKeyCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeyCriteria_result()
        try:
            result.success = self._handler.navigateKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeyCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeyCriteriaTime(self, seqid, iprot, oprot):
        args = navigateKeyCriteriaTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeyCriteriaTime_result()
        try:
            result.success = self._handler.navigateKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeyCriteriaTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeyCriteriaTimestr(self, seqid, iprot, oprot):
        args = navigateKeyCriteriaTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeyCriteriaTimestr_result()
        try:
            result.success = self._handler.navigateKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeyCriteriaTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeysCriteria(self, seqid, iprot, oprot):
        args = navigateKeysCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeysCriteria_result()
        try:
            result.success = self._handler.navigateKeysCriteria(args.keys, args.criteria, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeysCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeysCriteriaTime(self, seqid, iprot, oprot):
        args = navigateKeysCriteriaTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeysCriteriaTime_result()
        try:
            result.success = self._handler.navigateKeysCriteriaTime(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeysCriteriaTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_navigateKeysCriteriaTimestr(self, seqid, iprot, oprot):
        args = navigateKeysCriteriaTimestr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = navigateKeysCriteriaTimestr_result()
        try:
            result.success = self._handler.navigateKeysCriteriaTimestr(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("navigateKeysCriteriaTimestr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getServerEnvironment(self, seqid, iprot, oprot):
        args = getServerEnvironment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getServerEnvironment_result()
        try:
            result.success = self._handler.getServerEnvironment(args.creds, args.token, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getServerEnvironment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getServerVersion(self, seqid, iprot, oprot):
        args = getServerVersion_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getServerVersion_result()
        try:
            result.success = self._handler.getServerVersion()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getServerVersion", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_time(self, seqid, iprot, oprot):
        args = time_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = time_result()
        try:
            result.success = self._handler.time(args.creds, args.token, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except PermissionException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("time", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_timePhrase(self, seqid, iprot, oprot):
        args = timePhrase_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = timePhrase_result()
        try:
            result.success = self._handler.timePhrase(args.phrase, args.creds, args.token, args.environment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TransactionException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except ParseException as ex3:
            msg_type = TMessageType.REPLY
            result.ex3 = ex3
        except PermissionException as ex4:
            msg_type = TMessageType.REPLY
            result.ex4 = ex4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("timePhrase", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_invokeManagement(self, seqid, iprot, oprot):
        args = invokeManagement_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = invokeManagement_result()
        try:
            result.success = self._handler.invokeManagement(args.method, args.params, args.creds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except ManagementException as ex2:
            msg_type = TMessageType.REPLY
            result.ex2 = ex2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("invokeManagement", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class abort_args(object):
    """
    Attributes:
     - creds
     - transaction
     - environment

    """


    def __init__(self, creds=None, transaction=None, environment=None,):
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abort_args')
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 1)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 2)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 3)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abort_args)
abort_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 1
    (2, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 2
    (3, TType.STRING, 'environment', 'UTF8', None, ),  # 3
)


class abort_result(object):
    """
    Attributes:
     - ex

    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abort_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abort_result)
abort_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
)


class addKeyValue_args(object):
    """
    Attributes:
     - key
     - value
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, value=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.value = value
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.value = TObject()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addKeyValue_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 2)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addKeyValue_args)
addKeyValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'value', [TObject, None], None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class addKeyValue_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = InvalidArgumentException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addKeyValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addKeyValue_result)
addKeyValue_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [InvalidArgumentException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class addKeyValueRecord_args(object):
    """
    Attributes:
     - key
     - value
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.value = value
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.value = TObject()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addKeyValueRecord_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 2)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 3)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addKeyValueRecord_args)
addKeyValueRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'value', [TObject, None], None, ),  # 2
    (3, TType.I64, 'record', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class addKeyValueRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = InvalidArgumentException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addKeyValueRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addKeyValueRecord_result)
addKeyValueRecord_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [InvalidArgumentException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class addKeyValueRecords_args(object):
    """
    Attributes:
     - key
     - value
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, value=None, records=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.value = value
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.value = TObject()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI64()
                        self.records.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addKeyValueRecords_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 2)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter6 in self.records:
                oprot.writeI64(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addKeyValueRecords_args)
addKeyValueRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'value', [TObject, None], None, ),  # 2
    (3, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class addKeyValueRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype8, _vtype9, _size7) = iprot.readMapBegin()
                    for _i11 in range(_size7):
                        _key12 = iprot.readI64()
                        _val13 = iprot.readBool()
                        self.success[_key12] = _val13
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = InvalidArgumentException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addKeyValueRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.BOOL, len(self.success))
            for kiter14, viter15 in list(self.success.items()):
                oprot.writeI64(kiter14)
                oprot.writeBool(viter15)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addKeyValueRecords_result)
addKeyValueRecords_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.BOOL, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [InvalidArgumentException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class auditRecord_args(object):
    """
    Attributes:
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditRecord_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditRecord_args)
auditRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class auditRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype17, _vtype18, _size16) = iprot.readMapBegin()
                    for _i20 in range(_size16):
                        _key21 = iprot.readI64()
                        _val22 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key21] = _val22
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
            for kiter23, viter24 in list(self.success.items()):
                oprot.writeI64(kiter23)
                oprot.writeString(viter24.encode('utf-8') if sys.version_info[0] == 2 else viter24)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditRecord_result)
auditRecord_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class auditRecordStart_args(object):
    """
    Attributes:
     - record
     - start
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, start=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.start = start
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.start = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditRecordStart_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 2)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditRecordStart_args)
auditRecordStart_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.I64, 'start', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class auditRecordStart_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype26, _vtype27, _size25) = iprot.readMapBegin()
                    for _i29 in range(_size25):
                        _key30 = iprot.readI64()
                        _val31 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key30] = _val31
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditRecordStart_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
            for kiter32, viter33 in list(self.success.items()):
                oprot.writeI64(kiter32)
                oprot.writeString(viter33.encode('utf-8') if sys.version_info[0] == 2 else viter33)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditRecordStart_result)
auditRecordStart_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class auditRecordStartstr_args(object):
    """
    Attributes:
     - record
     - start
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, start=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.start = start
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.start = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditRecordStartstr_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.STRING, 2)
            oprot.writeString(self.start.encode('utf-8') if sys.version_info[0] == 2 else self.start)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditRecordStartstr_args)
auditRecordStartstr_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.STRING, 'start', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class auditRecordStartstr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype35, _vtype36, _size34) = iprot.readMapBegin()
                    for _i38 in range(_size34):
                        _key39 = iprot.readI64()
                        _val40 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key39] = _val40
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditRecordStartstr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
            for kiter41, viter42 in list(self.success.items()):
                oprot.writeI64(kiter41)
                oprot.writeString(viter42.encode('utf-8') if sys.version_info[0] == 2 else viter42)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditRecordStartstr_result)
auditRecordStartstr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class auditRecordStartEnd_args(object):
    """
    Attributes:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.start = start
        self.tend = tend
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.start = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.tend = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditRecordStartEnd_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 2)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.tend is not None:
            oprot.writeFieldBegin('tend', TType.I64, 3)
            oprot.writeI64(self.tend)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditRecordStartEnd_args)
auditRecordStartEnd_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.I64, 'start', None, None, ),  # 2
    (3, TType.I64, 'tend', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class auditRecordStartEnd_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype44, _vtype45, _size43) = iprot.readMapBegin()
                    for _i47 in range(_size43):
                        _key48 = iprot.readI64()
                        _val49 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key48] = _val49
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditRecordStartEnd_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
            for kiter50, viter51 in list(self.success.items()):
                oprot.writeI64(kiter50)
                oprot.writeString(viter51.encode('utf-8') if sys.version_info[0] == 2 else viter51)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditRecordStartEnd_result)
auditRecordStartEnd_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class auditRecordStartstrEndstr_args(object):
    """
    Attributes:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.start = start
        self.tend = tend
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.start = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tend = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditRecordStartstrEndstr_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.STRING, 2)
            oprot.writeString(self.start.encode('utf-8') if sys.version_info[0] == 2 else self.start)
            oprot.writeFieldEnd()
        if self.tend is not None:
            oprot.writeFieldBegin('tend', TType.STRING, 3)
            oprot.writeString(self.tend.encode('utf-8') if sys.version_info[0] == 2 else self.tend)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditRecordStartstrEndstr_args)
auditRecordStartstrEndstr_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.STRING, 'start', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'tend', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class auditRecordStartstrEndstr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype53, _vtype54, _size52) = iprot.readMapBegin()
                    for _i56 in range(_size52):
                        _key57 = iprot.readI64()
                        _val58 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key57] = _val58
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditRecordStartstrEndstr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
            for kiter59, viter60 in list(self.success.items()):
                oprot.writeI64(kiter59)
                oprot.writeString(viter60.encode('utf-8') if sys.version_info[0] == 2 else viter60)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditRecordStartstrEndstr_result)
auditRecordStartstrEndstr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class auditKeyRecord_args(object):
    """
    Attributes:
     - key
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditKeyRecord_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditKeyRecord_args)
auditKeyRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class auditKeyRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype62, _vtype63, _size61) = iprot.readMapBegin()
                    for _i65 in range(_size61):
                        _key66 = iprot.readI64()
                        _val67 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key66] = _val67
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditKeyRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
            for kiter68, viter69 in list(self.success.items()):
                oprot.writeI64(kiter68)
                oprot.writeString(viter69.encode('utf-8') if sys.version_info[0] == 2 else viter69)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditKeyRecord_result)
auditKeyRecord_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class auditKeyRecordStart_args(object):
    """
    Attributes:
     - key
     - record
     - start
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.start = start
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.start = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditKeyRecordStart_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 3)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditKeyRecordStart_args)
auditKeyRecordStart_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'start', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class auditKeyRecordStart_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype71, _vtype72, _size70) = iprot.readMapBegin()
                    for _i74 in range(_size70):
                        _key75 = iprot.readI64()
                        _val76 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key75] = _val76
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditKeyRecordStart_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
            for kiter77, viter78 in list(self.success.items()):
                oprot.writeI64(kiter77)
                oprot.writeString(viter78.encode('utf-8') if sys.version_info[0] == 2 else viter78)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditKeyRecordStart_result)
auditKeyRecordStart_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class auditKeyRecordStartstr_args(object):
    """
    Attributes:
     - key
     - record
     - start
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.start = start
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.start = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditKeyRecordStartstr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.STRING, 3)
            oprot.writeString(self.start.encode('utf-8') if sys.version_info[0] == 2 else self.start)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditKeyRecordStartstr_args)
auditKeyRecordStartstr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'start', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class auditKeyRecordStartstr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype80, _vtype81, _size79) = iprot.readMapBegin()
                    for _i83 in range(_size79):
                        _key84 = iprot.readI64()
                        _val85 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key84] = _val85
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditKeyRecordStartstr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
            for kiter86, viter87 in list(self.success.items()):
                oprot.writeI64(kiter86)
                oprot.writeString(viter87.encode('utf-8') if sys.version_info[0] == 2 else viter87)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditKeyRecordStartstr_result)
auditKeyRecordStartstr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class auditKeyRecordStartEnd_args(object):
    """
    Attributes:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.start = start
        self.tend = tend
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.start = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.tend = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditKeyRecordStartEnd_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 3)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.tend is not None:
            oprot.writeFieldBegin('tend', TType.I64, 4)
            oprot.writeI64(self.tend)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 5)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 7)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditKeyRecordStartEnd_args)
auditKeyRecordStartEnd_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'start', None, None, ),  # 3
    (4, TType.I64, 'tend', None, None, ),  # 4
    (5, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 5
    (6, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 6
    (7, TType.STRING, 'environment', 'UTF8', None, ),  # 7
)


class auditKeyRecordStartEnd_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype89, _vtype90, _size88) = iprot.readMapBegin()
                    for _i92 in range(_size88):
                        _key93 = iprot.readI64()
                        _val94 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key93] = _val94
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditKeyRecordStartEnd_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
            for kiter95, viter96 in list(self.success.items()):
                oprot.writeI64(kiter95)
                oprot.writeString(viter96.encode('utf-8') if sys.version_info[0] == 2 else viter96)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditKeyRecordStartEnd_result)
auditKeyRecordStartEnd_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class auditKeyRecordStartstrEndstr_args(object):
    """
    Attributes:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.start = start
        self.tend = tend
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.start = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.tend = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditKeyRecordStartstrEndstr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.STRING, 3)
            oprot.writeString(self.start.encode('utf-8') if sys.version_info[0] == 2 else self.start)
            oprot.writeFieldEnd()
        if self.tend is not None:
            oprot.writeFieldBegin('tend', TType.STRING, 4)
            oprot.writeString(self.tend.encode('utf-8') if sys.version_info[0] == 2 else self.tend)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 5)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 7)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditKeyRecordStartstrEndstr_args)
auditKeyRecordStartstrEndstr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'start', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'tend', 'UTF8', None, ),  # 4
    (5, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 5
    (6, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 6
    (7, TType.STRING, 'environment', 'UTF8', None, ),  # 7
)


class auditKeyRecordStartstrEndstr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype98, _vtype99, _size97) = iprot.readMapBegin()
                    for _i101 in range(_size97):
                        _key102 = iprot.readI64()
                        _val103 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key102] = _val103
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('auditKeyRecordStartstrEndstr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
            for kiter104, viter105 in list(self.success.items()):
                oprot.writeI64(kiter104)
                oprot.writeString(viter105.encode('utf-8') if sys.version_info[0] == 2 else viter105)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(auditKeyRecordStartstrEndstr_result)
auditKeyRecordStartstrEndstr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class browseKey_args(object):
    """
    Attributes:
     - key
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('browseKey_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(browseKey_args)
browseKey_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class browseKey_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype107, _vtype108, _size106) = iprot.readMapBegin()
                    for _i110 in range(_size106):
                        _key111 = TObject()
                        _key111.read(iprot)
                        _val112 = []
                        (_etype116, _size113) = iprot.readSetBegin()
                        for _i117 in range(_size113):
                            _elem118 = iprot.readI64()
                            _val112.append(_elem118)
                        iprot.readSetEnd()
                        self.success[_key111] = _val112
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('browseKey_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRUCT, TType.SET, len(self.success))
            for kiter119, viter120 in list(self.success.items()):
                kiter119.write(oprot)
                oprot.writeSetBegin(TType.I64, len(viter120))
                for iter121 in viter120:
                    oprot.writeI64(iter121)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(browseKey_result)
browseKey_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT, [TObject, None], TType.SET, (TType.I64, None, False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class browseKeys_args(object):
    """
    Attributes:
     - keys
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype125, _size122) = iprot.readListBegin()
                    for _i126 in range(_size122):
                        _elem127 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem127)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('browseKeys_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter128 in self.keys:
                oprot.writeString(iter128.encode('utf-8') if sys.version_info[0] == 2 else iter128)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(browseKeys_args)
browseKeys_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class browseKeys_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype130, _vtype131, _size129) = iprot.readMapBegin()
                    for _i133 in range(_size129):
                        _key134 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val135 = {}
                        (_ktype137, _vtype138, _size136) = iprot.readMapBegin()
                        for _i140 in range(_size136):
                            _key141 = TObject()
                            _key141.read(iprot)
                            _val142 = []
                            (_etype146, _size143) = iprot.readSetBegin()
                            for _i147 in range(_size143):
                                _elem148 = iprot.readI64()
                                _val142.append(_elem148)
                            iprot.readSetEnd()
                            _val135[_key141] = _val142
                        iprot.readMapEnd()
                        self.success[_key134] = _val135
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('browseKeys_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
            for kiter149, viter150 in list(self.success.items()):
                oprot.writeString(kiter149.encode('utf-8') if sys.version_info[0] == 2 else kiter149)
                oprot.writeMapBegin(TType.STRUCT, TType.SET, len(viter150))
                for kiter151, viter152 in list(viter150.items()):
                    kiter151.write(oprot)
                    oprot.writeSetBegin(TType.I64, len(viter152))
                    for iter153 in viter152:
                        oprot.writeI64(iter153)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(browseKeys_result)
browseKeys_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.MAP, (TType.STRUCT, [TObject, None], TType.SET, (TType.I64, None, False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class browseKeyTime_args(object):
    """
    Attributes:
     - key
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('browseKeyTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(browseKeyTime_args)
browseKeyTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class browseKeyTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype155, _vtype156, _size154) = iprot.readMapBegin()
                    for _i158 in range(_size154):
                        _key159 = TObject()
                        _key159.read(iprot)
                        _val160 = []
                        (_etype164, _size161) = iprot.readSetBegin()
                        for _i165 in range(_size161):
                            _elem166 = iprot.readI64()
                            _val160.append(_elem166)
                        iprot.readSetEnd()
                        self.success[_key159] = _val160
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('browseKeyTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRUCT, TType.SET, len(self.success))
            for kiter167, viter168 in list(self.success.items()):
                kiter167.write(oprot)
                oprot.writeSetBegin(TType.I64, len(viter168))
                for iter169 in viter168:
                    oprot.writeI64(iter169)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(browseKeyTime_result)
browseKeyTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT, [TObject, None], TType.SET, (TType.I64, None, False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class browseKeyTimestr_args(object):
    """
    Attributes:
     - key
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('browseKeyTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 2)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(browseKeyTimestr_args)
browseKeyTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'timestamp', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class browseKeyTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype171, _vtype172, _size170) = iprot.readMapBegin()
                    for _i174 in range(_size170):
                        _key175 = TObject()
                        _key175.read(iprot)
                        _val176 = []
                        (_etype180, _size177) = iprot.readSetBegin()
                        for _i181 in range(_size177):
                            _elem182 = iprot.readI64()
                            _val176.append(_elem182)
                        iprot.readSetEnd()
                        self.success[_key175] = _val176
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('browseKeyTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRUCT, TType.SET, len(self.success))
            for kiter183, viter184 in list(self.success.items()):
                kiter183.write(oprot)
                oprot.writeSetBegin(TType.I64, len(viter184))
                for iter185 in viter184:
                    oprot.writeI64(iter185)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(browseKeyTimestr_result)
browseKeyTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT, [TObject, None], TType.SET, (TType.I64, None, False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class browseKeysTime_args(object):
    """
    Attributes:
     - keys
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype189, _size186) = iprot.readListBegin()
                    for _i190 in range(_size186):
                        _elem191 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem191)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('browseKeysTime_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter192 in self.keys:
                oprot.writeString(iter192.encode('utf-8') if sys.version_info[0] == 2 else iter192)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(browseKeysTime_args)
browseKeysTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class browseKeysTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype194, _vtype195, _size193) = iprot.readMapBegin()
                    for _i197 in range(_size193):
                        _key198 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val199 = {}
                        (_ktype201, _vtype202, _size200) = iprot.readMapBegin()
                        for _i204 in range(_size200):
                            _key205 = TObject()
                            _key205.read(iprot)
                            _val206 = []
                            (_etype210, _size207) = iprot.readSetBegin()
                            for _i211 in range(_size207):
                                _elem212 = iprot.readI64()
                                _val206.append(_elem212)
                            iprot.readSetEnd()
                            _val199[_key205] = _val206
                        iprot.readMapEnd()
                        self.success[_key198] = _val199
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('browseKeysTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
            for kiter213, viter214 in list(self.success.items()):
                oprot.writeString(kiter213.encode('utf-8') if sys.version_info[0] == 2 else kiter213)
                oprot.writeMapBegin(TType.STRUCT, TType.SET, len(viter214))
                for kiter215, viter216 in list(viter214.items()):
                    kiter215.write(oprot)
                    oprot.writeSetBegin(TType.I64, len(viter216))
                    for iter217 in viter216:
                        oprot.writeI64(iter217)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(browseKeysTime_result)
browseKeysTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.MAP, (TType.STRUCT, [TObject, None], TType.SET, (TType.I64, None, False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class browseKeysTimestr_args(object):
    """
    Attributes:
     - keys
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype221, _size218) = iprot.readListBegin()
                    for _i222 in range(_size218):
                        _elem223 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem223)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('browseKeysTimestr_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter224 in self.keys:
                oprot.writeString(iter224.encode('utf-8') if sys.version_info[0] == 2 else iter224)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 2)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(browseKeysTimestr_args)
browseKeysTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'timestamp', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class browseKeysTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype226, _vtype227, _size225) = iprot.readMapBegin()
                    for _i229 in range(_size225):
                        _key230 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val231 = {}
                        (_ktype233, _vtype234, _size232) = iprot.readMapBegin()
                        for _i236 in range(_size232):
                            _key237 = TObject()
                            _key237.read(iprot)
                            _val238 = []
                            (_etype242, _size239) = iprot.readSetBegin()
                            for _i243 in range(_size239):
                                _elem244 = iprot.readI64()
                                _val238.append(_elem244)
                            iprot.readSetEnd()
                            _val231[_key237] = _val238
                        iprot.readMapEnd()
                        self.success[_key230] = _val231
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('browseKeysTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
            for kiter245, viter246 in list(self.success.items()):
                oprot.writeString(kiter245.encode('utf-8') if sys.version_info[0] == 2 else kiter245)
                oprot.writeMapBegin(TType.STRUCT, TType.SET, len(viter246))
                for kiter247, viter248 in list(viter246.items()):
                    kiter247.write(oprot)
                    oprot.writeSetBegin(TType.I64, len(viter248))
                    for iter249 in viter248:
                        oprot.writeI64(iter249)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(browseKeysTimestr_result)
browseKeysTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.MAP, (TType.STRUCT, [TObject, None], TType.SET, (TType.I64, None, False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class chronologizeKeyRecord_args(object):
    """
    Attributes:
     - key
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('chronologizeKeyRecord_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(chronologizeKeyRecord_args)
chronologizeKeyRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class chronologizeKeyRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype251, _vtype252, _size250) = iprot.readMapBegin()
                    for _i254 in range(_size250):
                        _key255 = iprot.readI64()
                        _val256 = []
                        (_etype260, _size257) = iprot.readSetBegin()
                        for _i261 in range(_size257):
                            _elem262 = TObject()
                            _elem262.read(iprot)
                            _val256.append(_elem262)
                        iprot.readSetEnd()
                        self.success[_key255] = _val256
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('chronologizeKeyRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter263, viter264 in list(self.success.items()):
                oprot.writeI64(kiter263)
                oprot.writeSetBegin(TType.STRUCT, len(viter264))
                for iter265 in viter264:
                    iter265.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(chronologizeKeyRecord_result)
chronologizeKeyRecord_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class chronologizeKeyRecordStart_args(object):
    """
    Attributes:
     - key
     - record
     - start
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.start = start
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.start = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('chronologizeKeyRecordStart_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 3)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(chronologizeKeyRecordStart_args)
chronologizeKeyRecordStart_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'start', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class chronologizeKeyRecordStart_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype267, _vtype268, _size266) = iprot.readMapBegin()
                    for _i270 in range(_size266):
                        _key271 = iprot.readI64()
                        _val272 = []
                        (_etype276, _size273) = iprot.readSetBegin()
                        for _i277 in range(_size273):
                            _elem278 = TObject()
                            _elem278.read(iprot)
                            _val272.append(_elem278)
                        iprot.readSetEnd()
                        self.success[_key271] = _val272
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('chronologizeKeyRecordStart_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter279, viter280 in list(self.success.items()):
                oprot.writeI64(kiter279)
                oprot.writeSetBegin(TType.STRUCT, len(viter280))
                for iter281 in viter280:
                    iter281.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(chronologizeKeyRecordStart_result)
chronologizeKeyRecordStart_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class chronologizeKeyRecordStartstr_args(object):
    """
    Attributes:
     - key
     - record
     - start
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.start = start
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.start = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('chronologizeKeyRecordStartstr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.STRING, 3)
            oprot.writeString(self.start.encode('utf-8') if sys.version_info[0] == 2 else self.start)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(chronologizeKeyRecordStartstr_args)
chronologizeKeyRecordStartstr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'start', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class chronologizeKeyRecordStartstr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype283, _vtype284, _size282) = iprot.readMapBegin()
                    for _i286 in range(_size282):
                        _key287 = iprot.readI64()
                        _val288 = []
                        (_etype292, _size289) = iprot.readSetBegin()
                        for _i293 in range(_size289):
                            _elem294 = TObject()
                            _elem294.read(iprot)
                            _val288.append(_elem294)
                        iprot.readSetEnd()
                        self.success[_key287] = _val288
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('chronologizeKeyRecordStartstr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter295, viter296 in list(self.success.items()):
                oprot.writeI64(kiter295)
                oprot.writeSetBegin(TType.STRUCT, len(viter296))
                for iter297 in viter296:
                    iter297.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(chronologizeKeyRecordStartstr_result)
chronologizeKeyRecordStartstr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class chronologizeKeyRecordStartEnd_args(object):
    """
    Attributes:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.start = start
        self.tend = tend
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.start = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.tend = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('chronologizeKeyRecordStartEnd_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 3)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.tend is not None:
            oprot.writeFieldBegin('tend', TType.I64, 4)
            oprot.writeI64(self.tend)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 5)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 7)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(chronologizeKeyRecordStartEnd_args)
chronologizeKeyRecordStartEnd_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'start', None, None, ),  # 3
    (4, TType.I64, 'tend', None, None, ),  # 4
    (5, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 5
    (6, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 6
    (7, TType.STRING, 'environment', 'UTF8', None, ),  # 7
)


class chronologizeKeyRecordStartEnd_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype299, _vtype300, _size298) = iprot.readMapBegin()
                    for _i302 in range(_size298):
                        _key303 = iprot.readI64()
                        _val304 = []
                        (_etype308, _size305) = iprot.readSetBegin()
                        for _i309 in range(_size305):
                            _elem310 = TObject()
                            _elem310.read(iprot)
                            _val304.append(_elem310)
                        iprot.readSetEnd()
                        self.success[_key303] = _val304
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('chronologizeKeyRecordStartEnd_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter311, viter312 in list(self.success.items()):
                oprot.writeI64(kiter311)
                oprot.writeSetBegin(TType.STRUCT, len(viter312))
                for iter313 in viter312:
                    iter313.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(chronologizeKeyRecordStartEnd_result)
chronologizeKeyRecordStartEnd_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class chronologizeKeyRecordStartstrEndstr_args(object):
    """
    Attributes:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.start = start
        self.tend = tend
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.start = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.tend = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('chronologizeKeyRecordStartstrEndstr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.STRING, 3)
            oprot.writeString(self.start.encode('utf-8') if sys.version_info[0] == 2 else self.start)
            oprot.writeFieldEnd()
        if self.tend is not None:
            oprot.writeFieldBegin('tend', TType.STRING, 4)
            oprot.writeString(self.tend.encode('utf-8') if sys.version_info[0] == 2 else self.tend)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 5)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 7)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(chronologizeKeyRecordStartstrEndstr_args)
chronologizeKeyRecordStartstrEndstr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'start', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'tend', 'UTF8', None, ),  # 4
    (5, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 5
    (6, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 6
    (7, TType.STRING, 'environment', 'UTF8', None, ),  # 7
)


class chronologizeKeyRecordStartstrEndstr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype315, _vtype316, _size314) = iprot.readMapBegin()
                    for _i318 in range(_size314):
                        _key319 = iprot.readI64()
                        _val320 = []
                        (_etype324, _size321) = iprot.readSetBegin()
                        for _i325 in range(_size321):
                            _elem326 = TObject()
                            _elem326.read(iprot)
                            _val320.append(_elem326)
                        iprot.readSetEnd()
                        self.success[_key319] = _val320
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('chronologizeKeyRecordStartstrEndstr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter327, viter328 in list(self.success.items()):
                oprot.writeI64(kiter327)
                oprot.writeSetBegin(TType.STRUCT, len(viter328))
                for iter329 in viter328:
                    iter329.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(chronologizeKeyRecordStartstrEndstr_result)
chronologizeKeyRecordStartstrEndstr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class clearRecord_args(object):
    """
    Attributes:
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clearRecord_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clearRecord_args)
clearRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class clearRecord_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3

    """


    def __init__(self, ex=None, ex2=None, ex3=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clearRecord_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clearRecord_result)
clearRecord_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class clearRecords_args(object):
    """
    Attributes:
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, records=None, creds=None, transaction=None, environment=None,):
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype333, _size330) = iprot.readListBegin()
                    for _i334 in range(_size330):
                        _elem335 = iprot.readI64()
                        self.records.append(_elem335)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clearRecords_args')
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter336 in self.records:
                oprot.writeI64(iter336)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clearRecords_args)
clearRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class clearRecords_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3

    """


    def __init__(self, ex=None, ex2=None, ex3=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clearRecords_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clearRecords_result)
clearRecords_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class clearKeyRecord_args(object):
    """
    Attributes:
     - key
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clearKeyRecord_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clearKeyRecord_args)
clearKeyRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class clearKeyRecord_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3

    """


    def __init__(self, ex=None, ex2=None, ex3=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clearKeyRecord_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clearKeyRecord_result)
clearKeyRecord_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class clearKeysRecord_args(object):
    """
    Attributes:
     - keys
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, record=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype340, _size337) = iprot.readListBegin()
                    for _i341 in range(_size337):
                        _elem342 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem342)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clearKeysRecord_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter343 in self.keys:
                oprot.writeString(iter343.encode('utf-8') if sys.version_info[0] == 2 else iter343)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clearKeysRecord_args)
clearKeysRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class clearKeysRecord_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3

    """


    def __init__(self, ex=None, ex2=None, ex3=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clearKeysRecord_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clearKeysRecord_result)
clearKeysRecord_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class clearKeyRecords_args(object):
    """
    Attributes:
     - key
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype347, _size344) = iprot.readListBegin()
                    for _i348 in range(_size344):
                        _elem349 = iprot.readI64()
                        self.records.append(_elem349)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clearKeyRecords_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter350 in self.records:
                oprot.writeI64(iter350)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clearKeyRecords_args)
clearKeyRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class clearKeyRecords_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3

    """


    def __init__(self, ex=None, ex2=None, ex3=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clearKeyRecords_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clearKeyRecords_result)
clearKeyRecords_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class clearKeysRecords_args(object):
    """
    Attributes:
     - keys
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, records=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype354, _size351) = iprot.readListBegin()
                    for _i355 in range(_size351):
                        _elem356 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem356)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype360, _size357) = iprot.readListBegin()
                    for _i361 in range(_size357):
                        _elem362 = iprot.readI64()
                        self.records.append(_elem362)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clearKeysRecords_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter363 in self.keys:
                oprot.writeString(iter363.encode('utf-8') if sys.version_info[0] == 2 else iter363)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter364 in self.records:
                oprot.writeI64(iter364)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clearKeysRecords_args)
clearKeysRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class clearKeysRecords_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3

    """


    def __init__(self, ex=None, ex2=None, ex3=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clearKeysRecords_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clearKeysRecords_result)
clearKeysRecords_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class commit_args(object):
    """
    Attributes:
     - creds
     - transaction
     - environment

    """


    def __init__(self, creds=None, transaction=None, environment=None,):
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commit_args')
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 1)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 2)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 3)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commit_args)
commit_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 1
    (2, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 2
    (3, TType.STRING, 'environment', 'UTF8', None, ),  # 3
)


class commit_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commit_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commit_result)
commit_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class inspect_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('inspect_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(inspect_args)
inspect_args.thrift_spec = (
)


class inspect_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype368, _size365) = iprot.readSetBegin()
                    for _i369 in range(_size365):
                        _elem370 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem370)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('inspect_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.STRING, len(self.success))
            for iter371 in self.success:
                oprot.writeString(iter371.encode('utf-8') if sys.version_info[0] == 2 else iter371)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(inspect_result)
inspect_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class describe_args(object):
    """
    Attributes:
     - creds
     - transaction
     - environment

    """


    def __init__(self, creds=None, transaction=None, environment=None,):
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describe_args')
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 1)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 2)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 3)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describe_args)
describe_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 1
    (2, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 2
    (3, TType.STRING, 'environment', 'UTF8', None, ),  # 3
)


class describe_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype375, _size372) = iprot.readSetBegin()
                    for _i376 in range(_size372):
                        _elem377 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem377)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describe_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.STRING, len(self.success))
            for iter378 in self.success:
                oprot.writeString(iter378.encode('utf-8') if sys.version_info[0] == 2 else iter378)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describe_result)
describe_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class describeTime_args(object):
    """
    Attributes:
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, timestamp=None, creds=None, transaction=None, environment=None,):
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describeTime_args')
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 1)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describeTime_args)
describeTime_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'timestamp', None, None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class describeTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype382, _size379) = iprot.readSetBegin()
                    for _i383 in range(_size379):
                        _elem384 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem384)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describeTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.STRING, len(self.success))
            for iter385 in self.success:
                oprot.writeString(iter385.encode('utf-8') if sys.version_info[0] == 2 else iter385)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describeTime_result)
describeTime_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class describeTimestr_args(object):
    """
    Attributes:
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, timestamp=None, creds=None, transaction=None, environment=None,):
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describeTimestr_args')
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 1)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describeTimestr_args)
describeTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'timestamp', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class describeTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype389, _size386) = iprot.readSetBegin()
                    for _i390 in range(_size386):
                        _elem391 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem391)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describeTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.STRING, len(self.success))
            for iter392 in self.success:
                oprot.writeString(iter392.encode('utf-8') if sys.version_info[0] == 2 else iter392)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describeTimestr_result)
describeTimestr_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class describeRecord_args(object):
    """
    Attributes:
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describeRecord_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describeRecord_args)
describeRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class describeRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype396, _size393) = iprot.readSetBegin()
                    for _i397 in range(_size393):
                        _elem398 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem398)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describeRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.STRING, len(self.success))
            for iter399 in self.success:
                oprot.writeString(iter399.encode('utf-8') if sys.version_info[0] == 2 else iter399)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describeRecord_result)
describeRecord_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class describeRecordTime_args(object):
    """
    Attributes:
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describeRecordTime_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describeRecordTime_args)
describeRecordTime_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class describeRecordTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype403, _size400) = iprot.readSetBegin()
                    for _i404 in range(_size400):
                        _elem405 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem405)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describeRecordTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.STRING, len(self.success))
            for iter406 in self.success:
                oprot.writeString(iter406.encode('utf-8') if sys.version_info[0] == 2 else iter406)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describeRecordTime_result)
describeRecordTime_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class describeRecordTimestr_args(object):
    """
    Attributes:
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describeRecordTimestr_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 2)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describeRecordTimestr_args)
describeRecordTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.STRING, 'timestamp', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class describeRecordTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype410, _size407) = iprot.readSetBegin()
                    for _i411 in range(_size407):
                        _elem412 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem412)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describeRecordTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.STRING, len(self.success))
            for iter413 in self.success:
                oprot.writeString(iter413.encode('utf-8') if sys.version_info[0] == 2 else iter413)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describeRecordTimestr_result)
describeRecordTimestr_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class describeRecords_args(object):
    """
    Attributes:
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, records=None, creds=None, transaction=None, environment=None,):
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype417, _size414) = iprot.readListBegin()
                    for _i418 in range(_size414):
                        _elem419 = iprot.readI64()
                        self.records.append(_elem419)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describeRecords_args')
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter420 in self.records:
                oprot.writeI64(iter420)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describeRecords_args)
describeRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class describeRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype422, _vtype423, _size421) = iprot.readMapBegin()
                    for _i425 in range(_size421):
                        _key426 = iprot.readI64()
                        _val427 = []
                        (_etype431, _size428) = iprot.readSetBegin()
                        for _i432 in range(_size428):
                            _elem433 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val427.append(_elem433)
                        iprot.readSetEnd()
                        self.success[_key426] = _val427
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describeRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter434, viter435 in list(self.success.items()):
                oprot.writeI64(kiter434)
                oprot.writeSetBegin(TType.STRING, len(viter435))
                for iter436 in viter435:
                    oprot.writeString(iter436.encode('utf-8') if sys.version_info[0] == 2 else iter436)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describeRecords_result)
describeRecords_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRING, 'UTF8', False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class describeRecordsTime_args(object):
    """
    Attributes:
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype440, _size437) = iprot.readListBegin()
                    for _i441 in range(_size437):
                        _elem442 = iprot.readI64()
                        self.records.append(_elem442)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describeRecordsTime_args')
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter443 in self.records:
                oprot.writeI64(iter443)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describeRecordsTime_args)
describeRecordsTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class describeRecordsTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype445, _vtype446, _size444) = iprot.readMapBegin()
                    for _i448 in range(_size444):
                        _key449 = iprot.readI64()
                        _val450 = []
                        (_etype454, _size451) = iprot.readSetBegin()
                        for _i455 in range(_size451):
                            _elem456 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val450.append(_elem456)
                        iprot.readSetEnd()
                        self.success[_key449] = _val450
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describeRecordsTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter457, viter458 in list(self.success.items()):
                oprot.writeI64(kiter457)
                oprot.writeSetBegin(TType.STRING, len(viter458))
                for iter459 in viter458:
                    oprot.writeString(iter459.encode('utf-8') if sys.version_info[0] == 2 else iter459)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describeRecordsTime_result)
describeRecordsTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRING, 'UTF8', False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class describeRecordsTimestr_args(object):
    """
    Attributes:
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype463, _size460) = iprot.readListBegin()
                    for _i464 in range(_size460):
                        _elem465 = iprot.readI64()
                        self.records.append(_elem465)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describeRecordsTimestr_args')
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter466 in self.records:
                oprot.writeI64(iter466)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 2)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describeRecordsTimestr_args)
describeRecordsTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRING, 'timestamp', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class describeRecordsTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype468, _vtype469, _size467) = iprot.readMapBegin()
                    for _i471 in range(_size467):
                        _key472 = iprot.readI64()
                        _val473 = []
                        (_etype477, _size474) = iprot.readSetBegin()
                        for _i478 in range(_size474):
                            _elem479 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val473.append(_elem479)
                        iprot.readSetEnd()
                        self.success[_key472] = _val473
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('describeRecordsTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter480, viter481 in list(self.success.items()):
                oprot.writeI64(kiter480)
                oprot.writeSetBegin(TType.STRING, len(viter481))
                for iter482 in viter481:
                    oprot.writeString(iter482.encode('utf-8') if sys.version_info[0] == 2 else iter482)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(describeRecordsTimestr_result)
describeRecordsTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRING, 'UTF8', False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class diffRecordStart_args(object):
    """
    Attributes:
     - record
     - start
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, start=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.start = start
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.start = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffRecordStart_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 2)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffRecordStart_args)
diffRecordStart_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.I64, 'start', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class diffRecordStart_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype484, _vtype485, _size483) = iprot.readMapBegin()
                    for _i487 in range(_size483):
                        _key488 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val489 = {}
                        (_ktype491, _vtype492, _size490) = iprot.readMapBegin()
                        for _i494 in range(_size490):
                            _key495 = iprot.readI32()
                            _val496 = []
                            (_etype500, _size497) = iprot.readSetBegin()
                            for _i501 in range(_size497):
                                _elem502 = TObject()
                                _elem502.read(iprot)
                                _val496.append(_elem502)
                            iprot.readSetEnd()
                            _val489[_key495] = _val496
                        iprot.readMapEnd()
                        self.success[_key488] = _val489
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffRecordStart_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
            for kiter503, viter504 in list(self.success.items()):
                oprot.writeString(kiter503.encode('utf-8') if sys.version_info[0] == 2 else kiter503)
                oprot.writeMapBegin(TType.I32, TType.SET, len(viter504))
                for kiter505, viter506 in list(viter504.items()):
                    oprot.writeI32(kiter505)
                    oprot.writeSetBegin(TType.STRUCT, len(viter506))
                    for iter507 in viter506:
                        iter507.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffRecordStart_result)
diffRecordStart_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.MAP, (TType.I32, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class diffRecordStartstr_args(object):
    """
    Attributes:
     - record
     - start
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, start=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.start = start
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.start = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffRecordStartstr_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.STRING, 2)
            oprot.writeString(self.start.encode('utf-8') if sys.version_info[0] == 2 else self.start)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffRecordStartstr_args)
diffRecordStartstr_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.STRING, 'start', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class diffRecordStartstr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype509, _vtype510, _size508) = iprot.readMapBegin()
                    for _i512 in range(_size508):
                        _key513 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val514 = {}
                        (_ktype516, _vtype517, _size515) = iprot.readMapBegin()
                        for _i519 in range(_size515):
                            _key520 = iprot.readI32()
                            _val521 = []
                            (_etype525, _size522) = iprot.readSetBegin()
                            for _i526 in range(_size522):
                                _elem527 = TObject()
                                _elem527.read(iprot)
                                _val521.append(_elem527)
                            iprot.readSetEnd()
                            _val514[_key520] = _val521
                        iprot.readMapEnd()
                        self.success[_key513] = _val514
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffRecordStartstr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
            for kiter528, viter529 in list(self.success.items()):
                oprot.writeString(kiter528.encode('utf-8') if sys.version_info[0] == 2 else kiter528)
                oprot.writeMapBegin(TType.I32, TType.SET, len(viter529))
                for kiter530, viter531 in list(viter529.items()):
                    oprot.writeI32(kiter530)
                    oprot.writeSetBegin(TType.STRUCT, len(viter531))
                    for iter532 in viter531:
                        iter532.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffRecordStartstr_result)
diffRecordStartstr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.MAP, (TType.I32, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class diffRecordStartEnd_args(object):
    """
    Attributes:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.start = start
        self.tend = tend
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.start = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.tend = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffRecordStartEnd_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 2)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.tend is not None:
            oprot.writeFieldBegin('tend', TType.I64, 3)
            oprot.writeI64(self.tend)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffRecordStartEnd_args)
diffRecordStartEnd_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.I64, 'start', None, None, ),  # 2
    (3, TType.I64, 'tend', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class diffRecordStartEnd_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype534, _vtype535, _size533) = iprot.readMapBegin()
                    for _i537 in range(_size533):
                        _key538 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val539 = {}
                        (_ktype541, _vtype542, _size540) = iprot.readMapBegin()
                        for _i544 in range(_size540):
                            _key545 = iprot.readI32()
                            _val546 = []
                            (_etype550, _size547) = iprot.readSetBegin()
                            for _i551 in range(_size547):
                                _elem552 = TObject()
                                _elem552.read(iprot)
                                _val546.append(_elem552)
                            iprot.readSetEnd()
                            _val539[_key545] = _val546
                        iprot.readMapEnd()
                        self.success[_key538] = _val539
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffRecordStartEnd_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
            for kiter553, viter554 in list(self.success.items()):
                oprot.writeString(kiter553.encode('utf-8') if sys.version_info[0] == 2 else kiter553)
                oprot.writeMapBegin(TType.I32, TType.SET, len(viter554))
                for kiter555, viter556 in list(viter554.items()):
                    oprot.writeI32(kiter555)
                    oprot.writeSetBegin(TType.STRUCT, len(viter556))
                    for iter557 in viter556:
                        iter557.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffRecordStartEnd_result)
diffRecordStartEnd_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.MAP, (TType.I32, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class diffRecordStartstrEndstr_args(object):
    """
    Attributes:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.start = start
        self.tend = tend
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.start = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tend = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffRecordStartstrEndstr_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.STRING, 2)
            oprot.writeString(self.start.encode('utf-8') if sys.version_info[0] == 2 else self.start)
            oprot.writeFieldEnd()
        if self.tend is not None:
            oprot.writeFieldBegin('tend', TType.STRING, 3)
            oprot.writeString(self.tend.encode('utf-8') if sys.version_info[0] == 2 else self.tend)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffRecordStartstrEndstr_args)
diffRecordStartstrEndstr_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.STRING, 'start', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'tend', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class diffRecordStartstrEndstr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype559, _vtype560, _size558) = iprot.readMapBegin()
                    for _i562 in range(_size558):
                        _key563 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val564 = {}
                        (_ktype566, _vtype567, _size565) = iprot.readMapBegin()
                        for _i569 in range(_size565):
                            _key570 = iprot.readI32()
                            _val571 = []
                            (_etype575, _size572) = iprot.readSetBegin()
                            for _i576 in range(_size572):
                                _elem577 = TObject()
                                _elem577.read(iprot)
                                _val571.append(_elem577)
                            iprot.readSetEnd()
                            _val564[_key570] = _val571
                        iprot.readMapEnd()
                        self.success[_key563] = _val564
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffRecordStartstrEndstr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
            for kiter578, viter579 in list(self.success.items()):
                oprot.writeString(kiter578.encode('utf-8') if sys.version_info[0] == 2 else kiter578)
                oprot.writeMapBegin(TType.I32, TType.SET, len(viter579))
                for kiter580, viter581 in list(viter579.items()):
                    oprot.writeI32(kiter580)
                    oprot.writeSetBegin(TType.STRUCT, len(viter581))
                    for iter582 in viter581:
                        iter582.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffRecordStartstrEndstr_result)
diffRecordStartstrEndstr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.MAP, (TType.I32, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class diffKeyRecordStart_args(object):
    """
    Attributes:
     - key
     - record
     - start
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.start = start
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.start = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffKeyRecordStart_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 3)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffKeyRecordStart_args)
diffKeyRecordStart_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'start', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class diffKeyRecordStart_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype584, _vtype585, _size583) = iprot.readMapBegin()
                    for _i587 in range(_size583):
                        _key588 = iprot.readI32()
                        _val589 = []
                        (_etype593, _size590) = iprot.readSetBegin()
                        for _i594 in range(_size590):
                            _elem595 = TObject()
                            _elem595.read(iprot)
                            _val589.append(_elem595)
                        iprot.readSetEnd()
                        self.success[_key588] = _val589
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffKeyRecordStart_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.SET, len(self.success))
            for kiter596, viter597 in list(self.success.items()):
                oprot.writeI32(kiter596)
                oprot.writeSetBegin(TType.STRUCT, len(viter597))
                for iter598 in viter597:
                    iter598.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffKeyRecordStart_result)
diffKeyRecordStart_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class diffKeyRecordStartstr_args(object):
    """
    Attributes:
     - key
     - record
     - start
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.start = start
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.start = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffKeyRecordStartstr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.STRING, 3)
            oprot.writeString(self.start.encode('utf-8') if sys.version_info[0] == 2 else self.start)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffKeyRecordStartstr_args)
diffKeyRecordStartstr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'start', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class diffKeyRecordStartstr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype600, _vtype601, _size599) = iprot.readMapBegin()
                    for _i603 in range(_size599):
                        _key604 = iprot.readI32()
                        _val605 = []
                        (_etype609, _size606) = iprot.readSetBegin()
                        for _i610 in range(_size606):
                            _elem611 = TObject()
                            _elem611.read(iprot)
                            _val605.append(_elem611)
                        iprot.readSetEnd()
                        self.success[_key604] = _val605
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffKeyRecordStartstr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.SET, len(self.success))
            for kiter612, viter613 in list(self.success.items()):
                oprot.writeI32(kiter612)
                oprot.writeSetBegin(TType.STRUCT, len(viter613))
                for iter614 in viter613:
                    iter614.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffKeyRecordStartstr_result)
diffKeyRecordStartstr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class diffKeyRecordStartEnd_args(object):
    """
    Attributes:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.start = start
        self.tend = tend
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.start = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.tend = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffKeyRecordStartEnd_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 3)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.tend is not None:
            oprot.writeFieldBegin('tend', TType.I64, 4)
            oprot.writeI64(self.tend)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 5)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 7)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffKeyRecordStartEnd_args)
diffKeyRecordStartEnd_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'start', None, None, ),  # 3
    (4, TType.I64, 'tend', None, None, ),  # 4
    (5, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 5
    (6, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 6
    (7, TType.STRING, 'environment', 'UTF8', None, ),  # 7
)


class diffKeyRecordStartEnd_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype616, _vtype617, _size615) = iprot.readMapBegin()
                    for _i619 in range(_size615):
                        _key620 = iprot.readI32()
                        _val621 = []
                        (_etype625, _size622) = iprot.readSetBegin()
                        for _i626 in range(_size622):
                            _elem627 = TObject()
                            _elem627.read(iprot)
                            _val621.append(_elem627)
                        iprot.readSetEnd()
                        self.success[_key620] = _val621
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffKeyRecordStartEnd_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.SET, len(self.success))
            for kiter628, viter629 in list(self.success.items()):
                oprot.writeI32(kiter628)
                oprot.writeSetBegin(TType.STRUCT, len(viter629))
                for iter630 in viter629:
                    iter630.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffKeyRecordStartEnd_result)
diffKeyRecordStartEnd_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class diffKeyRecordStartstrEndstr_args(object):
    """
    Attributes:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.start = start
        self.tend = tend
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.start = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.tend = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffKeyRecordStartstrEndstr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.STRING, 3)
            oprot.writeString(self.start.encode('utf-8') if sys.version_info[0] == 2 else self.start)
            oprot.writeFieldEnd()
        if self.tend is not None:
            oprot.writeFieldBegin('tend', TType.STRING, 4)
            oprot.writeString(self.tend.encode('utf-8') if sys.version_info[0] == 2 else self.tend)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 5)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 7)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffKeyRecordStartstrEndstr_args)
diffKeyRecordStartstrEndstr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'start', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'tend', 'UTF8', None, ),  # 4
    (5, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 5
    (6, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 6
    (7, TType.STRING, 'environment', 'UTF8', None, ),  # 7
)


class diffKeyRecordStartstrEndstr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype632, _vtype633, _size631) = iprot.readMapBegin()
                    for _i635 in range(_size631):
                        _key636 = iprot.readI32()
                        _val637 = []
                        (_etype641, _size638) = iprot.readSetBegin()
                        for _i642 in range(_size638):
                            _elem643 = TObject()
                            _elem643.read(iprot)
                            _val637.append(_elem643)
                        iprot.readSetEnd()
                        self.success[_key636] = _val637
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffKeyRecordStartstrEndstr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.SET, len(self.success))
            for kiter644, viter645 in list(self.success.items()):
                oprot.writeI32(kiter644)
                oprot.writeSetBegin(TType.STRUCT, len(viter645))
                for iter646 in viter645:
                    iter646.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffKeyRecordStartstrEndstr_result)
diffKeyRecordStartstrEndstr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class diffKeyStart_args(object):
    """
    Attributes:
     - key
     - start
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, start=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.start = start
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.start = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffKeyStart_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 2)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffKeyStart_args)
diffKeyStart_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'start', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class diffKeyStart_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype648, _vtype649, _size647) = iprot.readMapBegin()
                    for _i651 in range(_size647):
                        _key652 = TObject()
                        _key652.read(iprot)
                        _val653 = {}
                        (_ktype655, _vtype656, _size654) = iprot.readMapBegin()
                        for _i658 in range(_size654):
                            _key659 = iprot.readI32()
                            _val660 = []
                            (_etype664, _size661) = iprot.readSetBegin()
                            for _i665 in range(_size661):
                                _elem666 = iprot.readI64()
                                _val660.append(_elem666)
                            iprot.readSetEnd()
                            _val653[_key659] = _val660
                        iprot.readMapEnd()
                        self.success[_key652] = _val653
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffKeyStart_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.success))
            for kiter667, viter668 in list(self.success.items()):
                kiter667.write(oprot)
                oprot.writeMapBegin(TType.I32, TType.SET, len(viter668))
                for kiter669, viter670 in list(viter668.items()):
                    oprot.writeI32(kiter669)
                    oprot.writeSetBegin(TType.I64, len(viter670))
                    for iter671 in viter670:
                        oprot.writeI64(iter671)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffKeyStart_result)
diffKeyStart_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT, [TObject, None], TType.MAP, (TType.I32, None, TType.SET, (TType.I64, None, False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class diffKeyStartstr_args(object):
    """
    Attributes:
     - key
     - start
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, start=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.start = start
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.start = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffKeyStartstr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.STRING, 2)
            oprot.writeString(self.start.encode('utf-8') if sys.version_info[0] == 2 else self.start)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffKeyStartstr_args)
diffKeyStartstr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'start', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class diffKeyStartstr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype673, _vtype674, _size672) = iprot.readMapBegin()
                    for _i676 in range(_size672):
                        _key677 = TObject()
                        _key677.read(iprot)
                        _val678 = {}
                        (_ktype680, _vtype681, _size679) = iprot.readMapBegin()
                        for _i683 in range(_size679):
                            _key684 = iprot.readI32()
                            _val685 = []
                            (_etype689, _size686) = iprot.readSetBegin()
                            for _i690 in range(_size686):
                                _elem691 = iprot.readI64()
                                _val685.append(_elem691)
                            iprot.readSetEnd()
                            _val678[_key684] = _val685
                        iprot.readMapEnd()
                        self.success[_key677] = _val678
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffKeyStartstr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.success))
            for kiter692, viter693 in list(self.success.items()):
                kiter692.write(oprot)
                oprot.writeMapBegin(TType.I32, TType.SET, len(viter693))
                for kiter694, viter695 in list(viter693.items()):
                    oprot.writeI32(kiter694)
                    oprot.writeSetBegin(TType.I64, len(viter695))
                    for iter696 in viter695:
                        oprot.writeI64(iter696)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffKeyStartstr_result)
diffKeyStartstr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT, [TObject, None], TType.MAP, (TType.I32, None, TType.SET, (TType.I64, None, False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class diffKeyStartEnd_args(object):
    """
    Attributes:
     - key
     - start
     - tend
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.start = start
        self.tend = tend
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.start = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.tend = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffKeyStartEnd_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 2)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.tend is not None:
            oprot.writeFieldBegin('tend', TType.I64, 3)
            oprot.writeI64(self.tend)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffKeyStartEnd_args)
diffKeyStartEnd_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'start', None, None, ),  # 2
    (3, TType.I64, 'tend', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class diffKeyStartEnd_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype698, _vtype699, _size697) = iprot.readMapBegin()
                    for _i701 in range(_size697):
                        _key702 = TObject()
                        _key702.read(iprot)
                        _val703 = {}
                        (_ktype705, _vtype706, _size704) = iprot.readMapBegin()
                        for _i708 in range(_size704):
                            _key709 = iprot.readI32()
                            _val710 = []
                            (_etype714, _size711) = iprot.readSetBegin()
                            for _i715 in range(_size711):
                                _elem716 = iprot.readI64()
                                _val710.append(_elem716)
                            iprot.readSetEnd()
                            _val703[_key709] = _val710
                        iprot.readMapEnd()
                        self.success[_key702] = _val703
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffKeyStartEnd_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.success))
            for kiter717, viter718 in list(self.success.items()):
                kiter717.write(oprot)
                oprot.writeMapBegin(TType.I32, TType.SET, len(viter718))
                for kiter719, viter720 in list(viter718.items()):
                    oprot.writeI32(kiter719)
                    oprot.writeSetBegin(TType.I64, len(viter720))
                    for iter721 in viter720:
                        oprot.writeI64(iter721)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffKeyStartEnd_result)
diffKeyStartEnd_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT, [TObject, None], TType.MAP, (TType.I32, None, TType.SET, (TType.I64, None, False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class diffKeyStartstrEndstr_args(object):
    """
    Attributes:
     - key
     - start
     - tend
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.start = start
        self.tend = tend
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.start = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tend = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffKeyStartstrEndstr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.STRING, 2)
            oprot.writeString(self.start.encode('utf-8') if sys.version_info[0] == 2 else self.start)
            oprot.writeFieldEnd()
        if self.tend is not None:
            oprot.writeFieldBegin('tend', TType.STRING, 3)
            oprot.writeString(self.tend.encode('utf-8') if sys.version_info[0] == 2 else self.tend)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffKeyStartstrEndstr_args)
diffKeyStartstrEndstr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'start', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'tend', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class diffKeyStartstrEndstr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype723, _vtype724, _size722) = iprot.readMapBegin()
                    for _i726 in range(_size722):
                        _key727 = TObject()
                        _key727.read(iprot)
                        _val728 = {}
                        (_ktype730, _vtype731, _size729) = iprot.readMapBegin()
                        for _i733 in range(_size729):
                            _key734 = iprot.readI32()
                            _val735 = []
                            (_etype739, _size736) = iprot.readSetBegin()
                            for _i740 in range(_size736):
                                _elem741 = iprot.readI64()
                                _val735.append(_elem741)
                            iprot.readSetEnd()
                            _val728[_key734] = _val735
                        iprot.readMapEnd()
                        self.success[_key727] = _val728
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('diffKeyStartstrEndstr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.success))
            for kiter742, viter743 in list(self.success.items()):
                kiter742.write(oprot)
                oprot.writeMapBegin(TType.I32, TType.SET, len(viter743))
                for kiter744, viter745 in list(viter743.items()):
                    oprot.writeI32(kiter744)
                    oprot.writeSetBegin(TType.I64, len(viter745))
                    for iter746 in viter745:
                        oprot.writeI64(iter746)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(diffKeyStartstrEndstr_result)
diffKeyStartstrEndstr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT, [TObject, None], TType.MAP, (TType.I32, None, TType.SET, (TType.I64, None, False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class invokePlugin_args(object):
    """
    Attributes:
     - id
     - method
     - params
     - creds
     - transaction
     - environment

    """


    def __init__(self, id=None, method=None, params=None, creds=None, transaction=None, environment=None,):
        self.id = id
        self.method = method
        self.params = params
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.method = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.params = []
                    (_etype750, _size747) = iprot.readListBegin()
                    for _i751 in range(_size747):
                        _elem752 = ComplexTObject()
                        _elem752.read(iprot)
                        self.params.append(_elem752)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('invokePlugin_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.method is not None:
            oprot.writeFieldBegin('method', TType.STRING, 2)
            oprot.writeString(self.method.encode('utf-8') if sys.version_info[0] == 2 else self.method)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.params))
            for iter753 in self.params:
                iter753.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(invokePlugin_args)
invokePlugin_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'method', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'params', (TType.STRUCT, [ComplexTObject, None], False), None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class invokePlugin_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ComplexTObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = InvalidArgumentException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('invokePlugin_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(invokePlugin_result)
invokePlugin_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ComplexTObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [InvalidArgumentException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class login_args(object):
    """
    Attributes:
     - username
     - password
     - environment

    """


    def __init__(self, username=None, password=None, environment=None,):
        self.username = username
        self.password = password
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('login_args')
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 1)
            oprot.writeBinary(self.username)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 2)
            oprot.writeBinary(self.password)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 3)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(login_args)
login_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'username', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'password', 'BINARY', None, ),  # 2
    (3, TType.STRING, 'environment', 'UTF8', None, ),  # 3
)


class login_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2

    """


    def __init__(self, success=None, ex=None, ex2=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AccessToken()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = PermissionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('login_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(login_result)
login_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [AccessToken, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [PermissionException, None], None, ),  # 2
)


class logout_args(object):
    """
    Attributes:
     - token
     - environment

    """


    def __init__(self, token=None, environment=None,):
        self.token = token
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.token = AccessToken()
                    self.token.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('logout_args')
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRUCT, 1)
            self.token.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 2)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(logout_args)
logout_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'token', [AccessToken, None], None, ),  # 1
    (2, TType.STRING, 'environment', 'UTF8', None, ),  # 2
)


class logout_result(object):
    """
    Attributes:
     - ex
     - ex2

    """


    def __init__(self, ex=None, ex2=None,):
        self.ex = ex
        self.ex2 = ex2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = PermissionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('logout_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(logout_result)
logout_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [PermissionException, None], None, ),  # 2
)


class stage_args(object):
    """
    Attributes:
     - token
     - environment

    """


    def __init__(self, token=None, environment=None,):
        self.token = token
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.token = AccessToken()
                    self.token.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stage_args')
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRUCT, 1)
            self.token.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 2)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stage_args)
stage_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'token', [AccessToken, None], None, ),  # 1
    (2, TType.STRING, 'environment', 'UTF8', None, ),  # 2
)


class stage_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2

    """


    def __init__(self, success=None, ex=None, ex2=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TransactionToken()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = PermissionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stage_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stage_result)
stage_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TransactionToken, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [PermissionException, None], None, ),  # 2
)


class insertJson_args(object):
    """
    Attributes:
     - json
     - creds
     - transaction
     - environment

    """


    def __init__(self, json=None, creds=None, transaction=None, environment=None,):
        self.json = json
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.json = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('insertJson_args')
        if self.json is not None:
            oprot.writeFieldBegin('json', TType.STRING, 1)
            oprot.writeString(self.json.encode('utf-8') if sys.version_info[0] == 2 else self.json)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(insertJson_args)
insertJson_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'json', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class insertJson_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4
     - ex5

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None, ex5=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4
        self.ex5 = ex5

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype757, _size754) = iprot.readSetBegin()
                    for _i758 in range(_size754):
                        _elem759 = iprot.readI64()
                        self.success.append(_elem759)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = InvalidArgumentException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.ex5 = PermissionException()
                    self.ex5.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('insertJson_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I64, len(self.success))
            for iter760 in self.success:
                oprot.writeI64(iter760)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        if self.ex5 is not None:
            oprot.writeFieldBegin('ex5', TType.STRUCT, 5)
            self.ex5.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(insertJson_result)
insertJson_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [InvalidArgumentException, None], None, ),  # 4
    (5, TType.STRUCT, 'ex5', [PermissionException, None], None, ),  # 5
)


class insertJsonRecord_args(object):
    """
    Attributes:
     - json
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, json=None, record=None, creds=None, transaction=None, environment=None,):
        self.json = json
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.json = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('insertJsonRecord_args')
        if self.json is not None:
            oprot.writeFieldBegin('json', TType.STRING, 1)
            oprot.writeString(self.json.encode('utf-8') if sys.version_info[0] == 2 else self.json)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(insertJsonRecord_args)
insertJsonRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'json', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class insertJsonRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4
     - ex5

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None, ex5=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4
        self.ex5 = ex5

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = InvalidArgumentException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.ex5 = PermissionException()
                    self.ex5.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('insertJsonRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        if self.ex5 is not None:
            oprot.writeFieldBegin('ex5', TType.STRUCT, 5)
            self.ex5.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(insertJsonRecord_result)
insertJsonRecord_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [InvalidArgumentException, None], None, ),  # 4
    (5, TType.STRUCT, 'ex5', [PermissionException, None], None, ),  # 5
)


class insertJsonRecords_args(object):
    """
    Attributes:
     - json
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, json=None, records=None, creds=None, transaction=None, environment=None,):
        self.json = json
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.json = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype764, _size761) = iprot.readListBegin()
                    for _i765 in range(_size761):
                        _elem766 = iprot.readI64()
                        self.records.append(_elem766)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('insertJsonRecords_args')
        if self.json is not None:
            oprot.writeFieldBegin('json', TType.STRING, 1)
            oprot.writeString(self.json.encode('utf-8') if sys.version_info[0] == 2 else self.json)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter767 in self.records:
                oprot.writeI64(iter767)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(insertJsonRecords_args)
insertJsonRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'json', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class insertJsonRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4
     - ex5

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None, ex5=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4
        self.ex5 = ex5

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype769, _vtype770, _size768) = iprot.readMapBegin()
                    for _i772 in range(_size768):
                        _key773 = iprot.readI64()
                        _val774 = iprot.readBool()
                        self.success[_key773] = _val774
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = InvalidArgumentException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.ex5 = PermissionException()
                    self.ex5.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('insertJsonRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.BOOL, len(self.success))
            for kiter775, viter776 in list(self.success.items()):
                oprot.writeI64(kiter775)
                oprot.writeBool(viter776)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        if self.ex5 is not None:
            oprot.writeFieldBegin('ex5', TType.STRUCT, 5)
            self.ex5.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(insertJsonRecords_result)
insertJsonRecords_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.BOOL, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [InvalidArgumentException, None], None, ),  # 4
    (5, TType.STRUCT, 'ex5', [PermissionException, None], None, ),  # 5
)


class removeKeyValueRecord_args(object):
    """
    Attributes:
     - key
     - value
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.value = value
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.value = TObject()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeKeyValueRecord_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 2)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 3)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeKeyValueRecord_args)
removeKeyValueRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'value', [TObject, None], None, ),  # 2
    (3, TType.I64, 'record', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class removeKeyValueRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = InvalidArgumentException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeKeyValueRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeKeyValueRecord_result)
removeKeyValueRecord_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [InvalidArgumentException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class removeKeyValueRecords_args(object):
    """
    Attributes:
     - key
     - value
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, value=None, records=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.value = value
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.value = TObject()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype780, _size777) = iprot.readListBegin()
                    for _i781 in range(_size777):
                        _elem782 = iprot.readI64()
                        self.records.append(_elem782)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeKeyValueRecords_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 2)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter783 in self.records:
                oprot.writeI64(iter783)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeKeyValueRecords_args)
removeKeyValueRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'value', [TObject, None], None, ),  # 2
    (3, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class removeKeyValueRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype785, _vtype786, _size784) = iprot.readMapBegin()
                    for _i788 in range(_size784):
                        _key789 = iprot.readI64()
                        _val790 = iprot.readBool()
                        self.success[_key789] = _val790
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = InvalidArgumentException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeKeyValueRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.BOOL, len(self.success))
            for kiter791, viter792 in list(self.success.items()):
                oprot.writeI64(kiter791)
                oprot.writeBool(viter792)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeKeyValueRecords_result)
removeKeyValueRecords_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.BOOL, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [InvalidArgumentException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class setKeyValueRecord_args(object):
    """
    Attributes:
     - key
     - value
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.value = value
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.value = TObject()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setKeyValueRecord_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 2)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 3)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setKeyValueRecord_args)
setKeyValueRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'value', [TObject, None], None, ),  # 2
    (3, TType.I64, 'record', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class setKeyValueRecord_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, ex=None, ex2=None, ex3=None, ex4=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = InvalidArgumentException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setKeyValueRecord_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setKeyValueRecord_result)
setKeyValueRecord_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [InvalidArgumentException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class setKeyValue_args(object):
    """
    Attributes:
     - key
     - value
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, value=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.value = value
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.value = TObject()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setKeyValue_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 2)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setKeyValue_args)
setKeyValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'value', [TObject, None], None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class setKeyValue_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = InvalidArgumentException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setKeyValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setKeyValue_result)
setKeyValue_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [InvalidArgumentException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class setKeyValueRecords_args(object):
    """
    Attributes:
     - key
     - value
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, value=None, records=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.value = value
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.value = TObject()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype796, _size793) = iprot.readListBegin()
                    for _i797 in range(_size793):
                        _elem798 = iprot.readI64()
                        self.records.append(_elem798)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setKeyValueRecords_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 2)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter799 in self.records:
                oprot.writeI64(iter799)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setKeyValueRecords_args)
setKeyValueRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'value', [TObject, None], None, ),  # 2
    (3, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class setKeyValueRecords_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, ex=None, ex2=None, ex3=None, ex4=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = InvalidArgumentException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setKeyValueRecords_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setKeyValueRecords_result)
setKeyValueRecords_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [InvalidArgumentException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class reconcileKeyRecordValues_args(object):
    """
    Attributes:
     - key
     - record
     - values
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, values=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.values = values
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.values = []
                    (_etype803, _size800) = iprot.readSetBegin()
                    for _i804 in range(_size800):
                        _elem805 = TObject()
                        _elem805.read(iprot)
                        self.values.append(_elem805)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reconcileKeyRecordValues_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.SET, 3)
            oprot.writeSetBegin(TType.STRUCT, len(self.values))
            for iter806 in self.values:
                iter806.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reconcileKeyRecordValues_args)
reconcileKeyRecordValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.SET, 'values', (TType.STRUCT, [TObject, None], False), None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class reconcileKeyRecordValues_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, ex=None, ex2=None, ex3=None, ex4=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = InvalidArgumentException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reconcileKeyRecordValues_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reconcileKeyRecordValues_result)
reconcileKeyRecordValues_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [InvalidArgumentException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class inventory_args(object):
    """
    Attributes:
     - creds
     - transaction
     - environment

    """


    def __init__(self, creds=None, transaction=None, environment=None,):
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('inventory_args')
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 1)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 2)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 3)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(inventory_args)
inventory_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 1
    (2, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 2
    (3, TType.STRING, 'environment', 'UTF8', None, ),  # 3
)


class inventory_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype810, _size807) = iprot.readSetBegin()
                    for _i811 in range(_size807):
                        _elem812 = iprot.readI64()
                        self.success.append(_elem812)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('inventory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I64, len(self.success))
            for iter813 in self.success:
                oprot.writeI64(iter813)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(inventory_result)
inventory_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectRecord_args(object):
    """
    Attributes:
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectRecord_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectRecord_args)
selectRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class selectRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype815, _vtype816, _size814) = iprot.readMapBegin()
                    for _i818 in range(_size814):
                        _key819 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val820 = []
                        (_etype824, _size821) = iprot.readSetBegin()
                        for _i825 in range(_size821):
                            _elem826 = TObject()
                            _elem826.read(iprot)
                            _val820.append(_elem826)
                        iprot.readSetEnd()
                        self.success[_key819] = _val820
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
            for kiter827, viter828 in list(self.success.items()):
                oprot.writeString(kiter827.encode('utf-8') if sys.version_info[0] == 2 else kiter827)
                oprot.writeSetBegin(TType.STRUCT, len(viter828))
                for iter829 in viter828:
                    iter829.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectRecord_result)
selectRecord_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectRecords_args(object):
    """
    Attributes:
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, records=None, creds=None, transaction=None, environment=None,):
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype833, _size830) = iprot.readListBegin()
                    for _i834 in range(_size830):
                        _elem835 = iprot.readI64()
                        self.records.append(_elem835)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectRecords_args')
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter836 in self.records:
                oprot.writeI64(iter836)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectRecords_args)
selectRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class selectRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype838, _vtype839, _size837) = iprot.readMapBegin()
                    for _i841 in range(_size837):
                        _key842 = iprot.readI64()
                        _val843 = {}
                        (_ktype845, _vtype846, _size844) = iprot.readMapBegin()
                        for _i848 in range(_size844):
                            _key849 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val850 = []
                            (_etype854, _size851) = iprot.readSetBegin()
                            for _i855 in range(_size851):
                                _elem856 = TObject()
                                _elem856.read(iprot)
                                _val850.append(_elem856)
                            iprot.readSetEnd()
                            _val843[_key849] = _val850
                        iprot.readMapEnd()
                        self.success[_key842] = _val843
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter857, viter858 in list(self.success.items()):
                oprot.writeI64(kiter857)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter858))
                for kiter859, viter860 in list(viter858.items()):
                    oprot.writeString(kiter859.encode('utf-8') if sys.version_info[0] == 2 else kiter859)
                    oprot.writeSetBegin(TType.STRUCT, len(viter860))
                    for iter861 in viter860:
                        iter861.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectRecords_result)
selectRecords_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectRecordTime_args(object):
    """
    Attributes:
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectRecordTime_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectRecordTime_args)
selectRecordTime_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class selectRecordTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype863, _vtype864, _size862) = iprot.readMapBegin()
                    for _i866 in range(_size862):
                        _key867 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val868 = []
                        (_etype872, _size869) = iprot.readSetBegin()
                        for _i873 in range(_size869):
                            _elem874 = TObject()
                            _elem874.read(iprot)
                            _val868.append(_elem874)
                        iprot.readSetEnd()
                        self.success[_key867] = _val868
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectRecordTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
            for kiter875, viter876 in list(self.success.items()):
                oprot.writeString(kiter875.encode('utf-8') if sys.version_info[0] == 2 else kiter875)
                oprot.writeSetBegin(TType.STRUCT, len(viter876))
                for iter877 in viter876:
                    iter877.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectRecordTime_result)
selectRecordTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectRecordTimestr_args(object):
    """
    Attributes:
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectRecordTimestr_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 2)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectRecordTimestr_args)
selectRecordTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.STRING, 'timestamp', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class selectRecordTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype879, _vtype880, _size878) = iprot.readMapBegin()
                    for _i882 in range(_size878):
                        _key883 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val884 = []
                        (_etype888, _size885) = iprot.readSetBegin()
                        for _i889 in range(_size885):
                            _elem890 = TObject()
                            _elem890.read(iprot)
                            _val884.append(_elem890)
                        iprot.readSetEnd()
                        self.success[_key883] = _val884
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectRecordTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
            for kiter891, viter892 in list(self.success.items()):
                oprot.writeString(kiter891.encode('utf-8') if sys.version_info[0] == 2 else kiter891)
                oprot.writeSetBegin(TType.STRUCT, len(viter892))
                for iter893 in viter892:
                    iter893.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectRecordTimestr_result)
selectRecordTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectRecordsTime_args(object):
    """
    Attributes:
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype897, _size894) = iprot.readListBegin()
                    for _i898 in range(_size894):
                        _elem899 = iprot.readI64()
                        self.records.append(_elem899)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectRecordsTime_args')
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter900 in self.records:
                oprot.writeI64(iter900)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectRecordsTime_args)
selectRecordsTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class selectRecordsTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype902, _vtype903, _size901) = iprot.readMapBegin()
                    for _i905 in range(_size901):
                        _key906 = iprot.readI64()
                        _val907 = {}
                        (_ktype909, _vtype910, _size908) = iprot.readMapBegin()
                        for _i912 in range(_size908):
                            _key913 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val914 = []
                            (_etype918, _size915) = iprot.readSetBegin()
                            for _i919 in range(_size915):
                                _elem920 = TObject()
                                _elem920.read(iprot)
                                _val914.append(_elem920)
                            iprot.readSetEnd()
                            _val907[_key913] = _val914
                        iprot.readMapEnd()
                        self.success[_key906] = _val907
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectRecordsTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter921, viter922 in list(self.success.items()):
                oprot.writeI64(kiter921)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter922))
                for kiter923, viter924 in list(viter922.items()):
                    oprot.writeString(kiter923.encode('utf-8') if sys.version_info[0] == 2 else kiter923)
                    oprot.writeSetBegin(TType.STRUCT, len(viter924))
                    for iter925 in viter924:
                        iter925.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectRecordsTime_result)
selectRecordsTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectRecordsTimestr_args(object):
    """
    Attributes:
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype929, _size926) = iprot.readListBegin()
                    for _i930 in range(_size926):
                        _elem931 = iprot.readI64()
                        self.records.append(_elem931)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectRecordsTimestr_args')
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter932 in self.records:
                oprot.writeI64(iter932)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 2)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectRecordsTimestr_args)
selectRecordsTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRING, 'timestamp', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class selectRecordsTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype934, _vtype935, _size933) = iprot.readMapBegin()
                    for _i937 in range(_size933):
                        _key938 = iprot.readI64()
                        _val939 = {}
                        (_ktype941, _vtype942, _size940) = iprot.readMapBegin()
                        for _i944 in range(_size940):
                            _key945 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val946 = []
                            (_etype950, _size947) = iprot.readSetBegin()
                            for _i951 in range(_size947):
                                _elem952 = TObject()
                                _elem952.read(iprot)
                                _val946.append(_elem952)
                            iprot.readSetEnd()
                            _val939[_key945] = _val946
                        iprot.readMapEnd()
                        self.success[_key938] = _val939
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectRecordsTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter953, viter954 in list(self.success.items()):
                oprot.writeI64(kiter953)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter954))
                for kiter955, viter956 in list(viter954.items()):
                    oprot.writeString(kiter955.encode('utf-8') if sys.version_info[0] == 2 else kiter955)
                    oprot.writeSetBegin(TType.STRUCT, len(viter956))
                    for iter957 in viter956:
                        iter957.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectRecordsTimestr_result)
selectRecordsTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectKeyRecord_args(object):
    """
    Attributes:
     - key
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyRecord_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyRecord_args)
selectKeyRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class selectKeyRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype961, _size958) = iprot.readSetBegin()
                    for _i962 in range(_size958):
                        _elem963 = TObject()
                        _elem963.read(iprot)
                        self.success.append(_elem963)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.STRUCT, len(self.success))
            for iter964 in self.success:
                iter964.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyRecord_result)
selectKeyRecord_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT, [TObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectKeyRecordTime_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyRecordTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyRecordTime_args)
selectKeyRecordTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class selectKeyRecordTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype968, _size965) = iprot.readSetBegin()
                    for _i969 in range(_size965):
                        _elem970 = TObject()
                        _elem970.read(iprot)
                        self.success.append(_elem970)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyRecordTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.STRUCT, len(self.success))
            for iter971 in self.success:
                iter971.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyRecordTime_result)
selectKeyRecordTime_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT, [TObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectKeyRecordTimestr_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyRecordTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyRecordTimestr_args)
selectKeyRecordTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class selectKeyRecordTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype975, _size972) = iprot.readSetBegin()
                    for _i976 in range(_size972):
                        _elem977 = TObject()
                        _elem977.read(iprot)
                        self.success.append(_elem977)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyRecordTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.STRUCT, len(self.success))
            for iter978 in self.success:
                iter978.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyRecordTimestr_result)
selectKeyRecordTimestr_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT, [TObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectKeysRecord_args(object):
    """
    Attributes:
     - keys
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, record=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype982, _size979) = iprot.readListBegin()
                    for _i983 in range(_size979):
                        _elem984 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem984)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysRecord_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter985 in self.keys:
                oprot.writeString(iter985.encode('utf-8') if sys.version_info[0] == 2 else iter985)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysRecord_args)
selectKeysRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class selectKeysRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype987, _vtype988, _size986) = iprot.readMapBegin()
                    for _i990 in range(_size986):
                        _key991 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val992 = []
                        (_etype996, _size993) = iprot.readSetBegin()
                        for _i997 in range(_size993):
                            _elem998 = TObject()
                            _elem998.read(iprot)
                            _val992.append(_elem998)
                        iprot.readSetEnd()
                        self.success[_key991] = _val992
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
            for kiter999, viter1000 in list(self.success.items()):
                oprot.writeString(kiter999.encode('utf-8') if sys.version_info[0] == 2 else kiter999)
                oprot.writeSetBegin(TType.STRUCT, len(viter1000))
                for iter1001 in viter1000:
                    iter1001.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysRecord_result)
selectKeysRecord_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectKeysRecordTime_args(object):
    """
    Attributes:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1005, _size1002) = iprot.readListBegin()
                    for _i1006 in range(_size1002):
                        _elem1007 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1007)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysRecordTime_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1008 in self.keys:
                oprot.writeString(iter1008.encode('utf-8') if sys.version_info[0] == 2 else iter1008)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysRecordTime_args)
selectKeysRecordTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class selectKeysRecordTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1010, _vtype1011, _size1009) = iprot.readMapBegin()
                    for _i1013 in range(_size1009):
                        _key1014 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val1015 = []
                        (_etype1019, _size1016) = iprot.readSetBegin()
                        for _i1020 in range(_size1016):
                            _elem1021 = TObject()
                            _elem1021.read(iprot)
                            _val1015.append(_elem1021)
                        iprot.readSetEnd()
                        self.success[_key1014] = _val1015
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysRecordTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
            for kiter1022, viter1023 in list(self.success.items()):
                oprot.writeString(kiter1022.encode('utf-8') if sys.version_info[0] == 2 else kiter1022)
                oprot.writeSetBegin(TType.STRUCT, len(viter1023))
                for iter1024 in viter1023:
                    iter1024.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysRecordTime_result)
selectKeysRecordTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectKeysRecordTimestr_args(object):
    """
    Attributes:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1028, _size1025) = iprot.readListBegin()
                    for _i1029 in range(_size1025):
                        _elem1030 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1030)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysRecordTimestr_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1031 in self.keys:
                oprot.writeString(iter1031.encode('utf-8') if sys.version_info[0] == 2 else iter1031)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysRecordTimestr_args)
selectKeysRecordTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class selectKeysRecordTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1033, _vtype1034, _size1032) = iprot.readMapBegin()
                    for _i1036 in range(_size1032):
                        _key1037 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val1038 = []
                        (_etype1042, _size1039) = iprot.readSetBegin()
                        for _i1043 in range(_size1039):
                            _elem1044 = TObject()
                            _elem1044.read(iprot)
                            _val1038.append(_elem1044)
                        iprot.readSetEnd()
                        self.success[_key1037] = _val1038
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysRecordTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
            for kiter1045, viter1046 in list(self.success.items()):
                oprot.writeString(kiter1045.encode('utf-8') if sys.version_info[0] == 2 else kiter1045)
                oprot.writeSetBegin(TType.STRUCT, len(viter1046))
                for iter1047 in viter1046:
                    iter1047.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysRecordTimestr_result)
selectKeysRecordTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectKeysRecords_args(object):
    """
    Attributes:
     - keys
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, records=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1051, _size1048) = iprot.readListBegin()
                    for _i1052 in range(_size1048):
                        _elem1053 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1053)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype1057, _size1054) = iprot.readListBegin()
                    for _i1058 in range(_size1054):
                        _elem1059 = iprot.readI64()
                        self.records.append(_elem1059)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysRecords_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1060 in self.keys:
                oprot.writeString(iter1060.encode('utf-8') if sys.version_info[0] == 2 else iter1060)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter1061 in self.records:
                oprot.writeI64(iter1061)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysRecords_args)
selectKeysRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class selectKeysRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1063, _vtype1064, _size1062) = iprot.readMapBegin()
                    for _i1066 in range(_size1062):
                        _key1067 = iprot.readI64()
                        _val1068 = {}
                        (_ktype1070, _vtype1071, _size1069) = iprot.readMapBegin()
                        for _i1073 in range(_size1069):
                            _key1074 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1075 = []
                            (_etype1079, _size1076) = iprot.readSetBegin()
                            for _i1080 in range(_size1076):
                                _elem1081 = TObject()
                                _elem1081.read(iprot)
                                _val1075.append(_elem1081)
                            iprot.readSetEnd()
                            _val1068[_key1074] = _val1075
                        iprot.readMapEnd()
                        self.success[_key1067] = _val1068
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1082, viter1083 in list(self.success.items()):
                oprot.writeI64(kiter1082)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1083))
                for kiter1084, viter1085 in list(viter1083.items()):
                    oprot.writeString(kiter1084.encode('utf-8') if sys.version_info[0] == 2 else kiter1084)
                    oprot.writeSetBegin(TType.STRUCT, len(viter1085))
                    for iter1086 in viter1085:
                        iter1086.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysRecords_result)
selectKeysRecords_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectKeyRecords_args(object):
    """
    Attributes:
     - key
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype1090, _size1087) = iprot.readListBegin()
                    for _i1091 in range(_size1087):
                        _elem1092 = iprot.readI64()
                        self.records.append(_elem1092)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyRecords_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter1093 in self.records:
                oprot.writeI64(iter1093)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyRecords_args)
selectKeyRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class selectKeyRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1095, _vtype1096, _size1094) = iprot.readMapBegin()
                    for _i1098 in range(_size1094):
                        _key1099 = iprot.readI64()
                        _val1100 = []
                        (_etype1104, _size1101) = iprot.readSetBegin()
                        for _i1105 in range(_size1101):
                            _elem1106 = TObject()
                            _elem1106.read(iprot)
                            _val1100.append(_elem1106)
                        iprot.readSetEnd()
                        self.success[_key1099] = _val1100
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter1107, viter1108 in list(self.success.items()):
                oprot.writeI64(kiter1107)
                oprot.writeSetBegin(TType.STRUCT, len(viter1108))
                for iter1109 in viter1108:
                    iter1109.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyRecords_result)
selectKeyRecords_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectKeyRecordsTime_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype1113, _size1110) = iprot.readListBegin()
                    for _i1114 in range(_size1110):
                        _elem1115 = iprot.readI64()
                        self.records.append(_elem1115)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyRecordsTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter1116 in self.records:
                oprot.writeI64(iter1116)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyRecordsTime_args)
selectKeyRecordsTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class selectKeyRecordsTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1118, _vtype1119, _size1117) = iprot.readMapBegin()
                    for _i1121 in range(_size1117):
                        _key1122 = iprot.readI64()
                        _val1123 = []
                        (_etype1127, _size1124) = iprot.readSetBegin()
                        for _i1128 in range(_size1124):
                            _elem1129 = TObject()
                            _elem1129.read(iprot)
                            _val1123.append(_elem1129)
                        iprot.readSetEnd()
                        self.success[_key1122] = _val1123
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyRecordsTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter1130, viter1131 in list(self.success.items()):
                oprot.writeI64(kiter1130)
                oprot.writeSetBegin(TType.STRUCT, len(viter1131))
                for iter1132 in viter1131:
                    iter1132.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyRecordsTime_result)
selectKeyRecordsTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectKeyRecordsTimestr_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype1136, _size1133) = iprot.readListBegin()
                    for _i1137 in range(_size1133):
                        _elem1138 = iprot.readI64()
                        self.records.append(_elem1138)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyRecordsTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter1139 in self.records:
                oprot.writeI64(iter1139)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyRecordsTimestr_args)
selectKeyRecordsTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class selectKeyRecordsTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1141, _vtype1142, _size1140) = iprot.readMapBegin()
                    for _i1144 in range(_size1140):
                        _key1145 = iprot.readI64()
                        _val1146 = []
                        (_etype1150, _size1147) = iprot.readSetBegin()
                        for _i1151 in range(_size1147):
                            _elem1152 = TObject()
                            _elem1152.read(iprot)
                            _val1146.append(_elem1152)
                        iprot.readSetEnd()
                        self.success[_key1145] = _val1146
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyRecordsTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter1153, viter1154 in list(self.success.items()):
                oprot.writeI64(kiter1153)
                oprot.writeSetBegin(TType.STRUCT, len(viter1154))
                for iter1155 in viter1154:
                    iter1155.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyRecordsTimestr_result)
selectKeyRecordsTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectKeysRecordsTime_args(object):
    """
    Attributes:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1159, _size1156) = iprot.readListBegin()
                    for _i1160 in range(_size1156):
                        _elem1161 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1161)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype1165, _size1162) = iprot.readListBegin()
                    for _i1166 in range(_size1162):
                        _elem1167 = iprot.readI64()
                        self.records.append(_elem1167)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysRecordsTime_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1168 in self.keys:
                oprot.writeString(iter1168.encode('utf-8') if sys.version_info[0] == 2 else iter1168)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter1169 in self.records:
                oprot.writeI64(iter1169)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysRecordsTime_args)
selectKeysRecordsTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class selectKeysRecordsTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1171, _vtype1172, _size1170) = iprot.readMapBegin()
                    for _i1174 in range(_size1170):
                        _key1175 = iprot.readI64()
                        _val1176 = {}
                        (_ktype1178, _vtype1179, _size1177) = iprot.readMapBegin()
                        for _i1181 in range(_size1177):
                            _key1182 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1183 = []
                            (_etype1187, _size1184) = iprot.readSetBegin()
                            for _i1188 in range(_size1184):
                                _elem1189 = TObject()
                                _elem1189.read(iprot)
                                _val1183.append(_elem1189)
                            iprot.readSetEnd()
                            _val1176[_key1182] = _val1183
                        iprot.readMapEnd()
                        self.success[_key1175] = _val1176
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysRecordsTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1190, viter1191 in list(self.success.items()):
                oprot.writeI64(kiter1190)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1191))
                for kiter1192, viter1193 in list(viter1191.items()):
                    oprot.writeString(kiter1192.encode('utf-8') if sys.version_info[0] == 2 else kiter1192)
                    oprot.writeSetBegin(TType.STRUCT, len(viter1193))
                    for iter1194 in viter1193:
                        iter1194.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysRecordsTime_result)
selectKeysRecordsTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectKeysRecordsTimestr_args(object):
    """
    Attributes:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1198, _size1195) = iprot.readListBegin()
                    for _i1199 in range(_size1195):
                        _elem1200 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1200)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype1204, _size1201) = iprot.readListBegin()
                    for _i1205 in range(_size1201):
                        _elem1206 = iprot.readI64()
                        self.records.append(_elem1206)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysRecordsTimestr_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1207 in self.keys:
                oprot.writeString(iter1207.encode('utf-8') if sys.version_info[0] == 2 else iter1207)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter1208 in self.records:
                oprot.writeI64(iter1208)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysRecordsTimestr_args)
selectKeysRecordsTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class selectKeysRecordsTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1210, _vtype1211, _size1209) = iprot.readMapBegin()
                    for _i1213 in range(_size1209):
                        _key1214 = iprot.readI64()
                        _val1215 = {}
                        (_ktype1217, _vtype1218, _size1216) = iprot.readMapBegin()
                        for _i1220 in range(_size1216):
                            _key1221 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1222 = []
                            (_etype1226, _size1223) = iprot.readSetBegin()
                            for _i1227 in range(_size1223):
                                _elem1228 = TObject()
                                _elem1228.read(iprot)
                                _val1222.append(_elem1228)
                            iprot.readSetEnd()
                            _val1215[_key1221] = _val1222
                        iprot.readMapEnd()
                        self.success[_key1214] = _val1215
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysRecordsTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1229, viter1230 in list(self.success.items()):
                oprot.writeI64(kiter1229)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1230))
                for kiter1231, viter1232 in list(viter1230.items()):
                    oprot.writeString(kiter1231.encode('utf-8') if sys.version_info[0] == 2 else kiter1231)
                    oprot.writeSetBegin(TType.STRUCT, len(viter1232))
                    for iter1233 in viter1232:
                        iter1233.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysRecordsTimestr_result)
selectKeysRecordsTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectCriteria_args(object):
    """
    Attributes:
     - criteria
     - creds
     - transaction
     - environment

    """


    def __init__(self, criteria=None, creds=None, transaction=None, environment=None,):
        self.criteria = criteria
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectCriteria_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectCriteria_args)
selectCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class selectCriteria_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1235, _vtype1236, _size1234) = iprot.readMapBegin()
                    for _i1238 in range(_size1234):
                        _key1239 = iprot.readI64()
                        _val1240 = {}
                        (_ktype1242, _vtype1243, _size1241) = iprot.readMapBegin()
                        for _i1245 in range(_size1241):
                            _key1246 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1247 = []
                            (_etype1251, _size1248) = iprot.readSetBegin()
                            for _i1252 in range(_size1248):
                                _elem1253 = TObject()
                                _elem1253.read(iprot)
                                _val1247.append(_elem1253)
                            iprot.readSetEnd()
                            _val1240[_key1246] = _val1247
                        iprot.readMapEnd()
                        self.success[_key1239] = _val1240
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1254, viter1255 in list(self.success.items()):
                oprot.writeI64(kiter1254)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1255))
                for kiter1256, viter1257 in list(viter1255.items()):
                    oprot.writeString(kiter1256.encode('utf-8') if sys.version_info[0] == 2 else kiter1256)
                    oprot.writeSetBegin(TType.STRUCT, len(viter1257))
                    for iter1258 in viter1257:
                        iter1258.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectCriteria_result)
selectCriteria_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectCcl_args(object):
    """
    Attributes:
     - ccl
     - creds
     - transaction
     - environment

    """


    def __init__(self, ccl=None, creds=None, transaction=None, environment=None,):
        self.ccl = ccl
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectCcl_args')
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 1)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectCcl_args)
selectCcl_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ccl', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class selectCcl_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1260, _vtype1261, _size1259) = iprot.readMapBegin()
                    for _i1263 in range(_size1259):
                        _key1264 = iprot.readI64()
                        _val1265 = {}
                        (_ktype1267, _vtype1268, _size1266) = iprot.readMapBegin()
                        for _i1270 in range(_size1266):
                            _key1271 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1272 = []
                            (_etype1276, _size1273) = iprot.readSetBegin()
                            for _i1277 in range(_size1273):
                                _elem1278 = TObject()
                                _elem1278.read(iprot)
                                _val1272.append(_elem1278)
                            iprot.readSetEnd()
                            _val1265[_key1271] = _val1272
                        iprot.readMapEnd()
                        self.success[_key1264] = _val1265
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectCcl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1279, viter1280 in list(self.success.items()):
                oprot.writeI64(kiter1279)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1280))
                for kiter1281, viter1282 in list(viter1280.items()):
                    oprot.writeString(kiter1281.encode('utf-8') if sys.version_info[0] == 2 else kiter1281)
                    oprot.writeSetBegin(TType.STRUCT, len(viter1282))
                    for iter1283 in viter1282:
                        iter1283.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectCcl_result)
selectCcl_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectCriteriaTime_args(object):
    """
    Attributes:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectCriteriaTime_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectCriteriaTime_args)
selectCriteriaTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class selectCriteriaTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1285, _vtype1286, _size1284) = iprot.readMapBegin()
                    for _i1288 in range(_size1284):
                        _key1289 = iprot.readI64()
                        _val1290 = {}
                        (_ktype1292, _vtype1293, _size1291) = iprot.readMapBegin()
                        for _i1295 in range(_size1291):
                            _key1296 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1297 = []
                            (_etype1301, _size1298) = iprot.readSetBegin()
                            for _i1302 in range(_size1298):
                                _elem1303 = TObject()
                                _elem1303.read(iprot)
                                _val1297.append(_elem1303)
                            iprot.readSetEnd()
                            _val1290[_key1296] = _val1297
                        iprot.readMapEnd()
                        self.success[_key1289] = _val1290
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectCriteriaTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1304, viter1305 in list(self.success.items()):
                oprot.writeI64(kiter1304)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1305))
                for kiter1306, viter1307 in list(viter1305.items()):
                    oprot.writeString(kiter1306.encode('utf-8') if sys.version_info[0] == 2 else kiter1306)
                    oprot.writeSetBegin(TType.STRUCT, len(viter1307))
                    for iter1308 in viter1307:
                        iter1308.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectCriteriaTime_result)
selectCriteriaTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectCriteriaTimestr_args(object):
    """
    Attributes:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectCriteriaTimestr_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 2)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectCriteriaTimestr_args)
selectCriteriaTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 1
    (2, TType.STRING, 'timestamp', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class selectCriteriaTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1310, _vtype1311, _size1309) = iprot.readMapBegin()
                    for _i1313 in range(_size1309):
                        _key1314 = iprot.readI64()
                        _val1315 = {}
                        (_ktype1317, _vtype1318, _size1316) = iprot.readMapBegin()
                        for _i1320 in range(_size1316):
                            _key1321 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1322 = []
                            (_etype1326, _size1323) = iprot.readSetBegin()
                            for _i1327 in range(_size1323):
                                _elem1328 = TObject()
                                _elem1328.read(iprot)
                                _val1322.append(_elem1328)
                            iprot.readSetEnd()
                            _val1315[_key1321] = _val1322
                        iprot.readMapEnd()
                        self.success[_key1314] = _val1315
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectCriteriaTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1329, viter1330 in list(self.success.items()):
                oprot.writeI64(kiter1329)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1330))
                for kiter1331, viter1332 in list(viter1330.items()):
                    oprot.writeString(kiter1331.encode('utf-8') if sys.version_info[0] == 2 else kiter1331)
                    oprot.writeSetBegin(TType.STRUCT, len(viter1332))
                    for iter1333 in viter1332:
                        iter1333.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectCriteriaTimestr_result)
selectCriteriaTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectCclTime_args(object):
    """
    Attributes:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectCclTime_args')
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 1)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectCclTime_args)
selectCclTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ccl', 'UTF8', None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class selectCclTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1335, _vtype1336, _size1334) = iprot.readMapBegin()
                    for _i1338 in range(_size1334):
                        _key1339 = iprot.readI64()
                        _val1340 = {}
                        (_ktype1342, _vtype1343, _size1341) = iprot.readMapBegin()
                        for _i1345 in range(_size1341):
                            _key1346 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1347 = []
                            (_etype1351, _size1348) = iprot.readSetBegin()
                            for _i1352 in range(_size1348):
                                _elem1353 = TObject()
                                _elem1353.read(iprot)
                                _val1347.append(_elem1353)
                            iprot.readSetEnd()
                            _val1340[_key1346] = _val1347
                        iprot.readMapEnd()
                        self.success[_key1339] = _val1340
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectCclTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1354, viter1355 in list(self.success.items()):
                oprot.writeI64(kiter1354)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1355))
                for kiter1356, viter1357 in list(viter1355.items()):
                    oprot.writeString(kiter1356.encode('utf-8') if sys.version_info[0] == 2 else kiter1356)
                    oprot.writeSetBegin(TType.STRUCT, len(viter1357))
                    for iter1358 in viter1357:
                        iter1358.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectCclTime_result)
selectCclTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectCclTimestr_args(object):
    """
    Attributes:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectCclTimestr_args')
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 1)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 2)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectCclTimestr_args)
selectCclTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ccl', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'timestamp', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class selectCclTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1360, _vtype1361, _size1359) = iprot.readMapBegin()
                    for _i1363 in range(_size1359):
                        _key1364 = iprot.readI64()
                        _val1365 = {}
                        (_ktype1367, _vtype1368, _size1366) = iprot.readMapBegin()
                        for _i1370 in range(_size1366):
                            _key1371 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1372 = []
                            (_etype1376, _size1373) = iprot.readSetBegin()
                            for _i1377 in range(_size1373):
                                _elem1378 = TObject()
                                _elem1378.read(iprot)
                                _val1372.append(_elem1378)
                            iprot.readSetEnd()
                            _val1365[_key1371] = _val1372
                        iprot.readMapEnd()
                        self.success[_key1364] = _val1365
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectCclTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1379, viter1380 in list(self.success.items()):
                oprot.writeI64(kiter1379)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1380))
                for kiter1381, viter1382 in list(viter1380.items()):
                    oprot.writeString(kiter1381.encode('utf-8') if sys.version_info[0] == 2 else kiter1381)
                    oprot.writeSetBegin(TType.STRUCT, len(viter1382))
                    for iter1383 in viter1382:
                        iter1383.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectCclTimestr_result)
selectCclTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectKeyCriteria_args(object):
    """
    Attributes:
     - key
     - criteria
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyCriteria_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyCriteria_args)
selectKeyCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class selectKeyCriteria_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1385, _vtype1386, _size1384) = iprot.readMapBegin()
                    for _i1388 in range(_size1384):
                        _key1389 = iprot.readI64()
                        _val1390 = []
                        (_etype1394, _size1391) = iprot.readSetBegin()
                        for _i1395 in range(_size1391):
                            _elem1396 = TObject()
                            _elem1396.read(iprot)
                            _val1390.append(_elem1396)
                        iprot.readSetEnd()
                        self.success[_key1389] = _val1390
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter1397, viter1398 in list(self.success.items()):
                oprot.writeI64(kiter1397)
                oprot.writeSetBegin(TType.STRUCT, len(viter1398))
                for iter1399 in viter1398:
                    iter1399.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyCriteria_result)
selectKeyCriteria_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectKeyCcl_args(object):
    """
    Attributes:
     - key
     - ccl
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyCcl_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyCcl_args)
selectKeyCcl_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class selectKeyCcl_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1401, _vtype1402, _size1400) = iprot.readMapBegin()
                    for _i1404 in range(_size1400):
                        _key1405 = iprot.readI64()
                        _val1406 = []
                        (_etype1410, _size1407) = iprot.readSetBegin()
                        for _i1411 in range(_size1407):
                            _elem1412 = TObject()
                            _elem1412.read(iprot)
                            _val1406.append(_elem1412)
                        iprot.readSetEnd()
                        self.success[_key1405] = _val1406
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyCcl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter1413, viter1414 in list(self.success.items()):
                oprot.writeI64(kiter1413)
                oprot.writeSetBegin(TType.STRUCT, len(viter1414))
                for iter1415 in viter1414:
                    iter1415.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyCcl_result)
selectKeyCcl_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectKeyCriteriaTime_args(object):
    """
    Attributes:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyCriteriaTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyCriteriaTime_args)
selectKeyCriteriaTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class selectKeyCriteriaTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1417, _vtype1418, _size1416) = iprot.readMapBegin()
                    for _i1420 in range(_size1416):
                        _key1421 = iprot.readI64()
                        _val1422 = []
                        (_etype1426, _size1423) = iprot.readSetBegin()
                        for _i1427 in range(_size1423):
                            _elem1428 = TObject()
                            _elem1428.read(iprot)
                            _val1422.append(_elem1428)
                        iprot.readSetEnd()
                        self.success[_key1421] = _val1422
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyCriteriaTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter1429, viter1430 in list(self.success.items()):
                oprot.writeI64(kiter1429)
                oprot.writeSetBegin(TType.STRUCT, len(viter1430))
                for iter1431 in viter1430:
                    iter1431.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyCriteriaTime_result)
selectKeyCriteriaTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectKeyCriteriaTimestr_args(object):
    """
    Attributes:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyCriteriaTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyCriteriaTimestr_args)
selectKeyCriteriaTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class selectKeyCriteriaTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1433, _vtype1434, _size1432) = iprot.readMapBegin()
                    for _i1436 in range(_size1432):
                        _key1437 = iprot.readI64()
                        _val1438 = []
                        (_etype1442, _size1439) = iprot.readSetBegin()
                        for _i1443 in range(_size1439):
                            _elem1444 = TObject()
                            _elem1444.read(iprot)
                            _val1438.append(_elem1444)
                        iprot.readSetEnd()
                        self.success[_key1437] = _val1438
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyCriteriaTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter1445, viter1446 in list(self.success.items()):
                oprot.writeI64(kiter1445)
                oprot.writeSetBegin(TType.STRUCT, len(viter1446))
                for iter1447 in viter1446:
                    iter1447.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyCriteriaTimestr_result)
selectKeyCriteriaTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectKeyCclTime_args(object):
    """
    Attributes:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyCclTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyCclTime_args)
selectKeyCclTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class selectKeyCclTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1449, _vtype1450, _size1448) = iprot.readMapBegin()
                    for _i1452 in range(_size1448):
                        _key1453 = iprot.readI64()
                        _val1454 = []
                        (_etype1458, _size1455) = iprot.readSetBegin()
                        for _i1459 in range(_size1455):
                            _elem1460 = TObject()
                            _elem1460.read(iprot)
                            _val1454.append(_elem1460)
                        iprot.readSetEnd()
                        self.success[_key1453] = _val1454
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyCclTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter1461, viter1462 in list(self.success.items()):
                oprot.writeI64(kiter1461)
                oprot.writeSetBegin(TType.STRUCT, len(viter1462))
                for iter1463 in viter1462:
                    iter1463.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyCclTime_result)
selectKeyCclTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectKeyCclTimestr_args(object):
    """
    Attributes:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyCclTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyCclTimestr_args)
selectKeyCclTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class selectKeyCclTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1465, _vtype1466, _size1464) = iprot.readMapBegin()
                    for _i1468 in range(_size1464):
                        _key1469 = iprot.readI64()
                        _val1470 = []
                        (_etype1474, _size1471) = iprot.readSetBegin()
                        for _i1475 in range(_size1471):
                            _elem1476 = TObject()
                            _elem1476.read(iprot)
                            _val1470.append(_elem1476)
                        iprot.readSetEnd()
                        self.success[_key1469] = _val1470
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeyCclTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter1477, viter1478 in list(self.success.items()):
                oprot.writeI64(kiter1477)
                oprot.writeSetBegin(TType.STRUCT, len(viter1478))
                for iter1479 in viter1478:
                    iter1479.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeyCclTimestr_result)
selectKeyCclTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectKeysCriteria_args(object):
    """
    Attributes:
     - keys
     - criteria
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, criteria=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.criteria = criteria
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1483, _size1480) = iprot.readListBegin()
                    for _i1484 in range(_size1480):
                        _elem1485 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1485)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysCriteria_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1486 in self.keys:
                oprot.writeString(iter1486.encode('utf-8') if sys.version_info[0] == 2 else iter1486)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysCriteria_args)
selectKeysCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class selectKeysCriteria_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1488, _vtype1489, _size1487) = iprot.readMapBegin()
                    for _i1491 in range(_size1487):
                        _key1492 = iprot.readI64()
                        _val1493 = {}
                        (_ktype1495, _vtype1496, _size1494) = iprot.readMapBegin()
                        for _i1498 in range(_size1494):
                            _key1499 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1500 = []
                            (_etype1504, _size1501) = iprot.readSetBegin()
                            for _i1505 in range(_size1501):
                                _elem1506 = TObject()
                                _elem1506.read(iprot)
                                _val1500.append(_elem1506)
                            iprot.readSetEnd()
                            _val1493[_key1499] = _val1500
                        iprot.readMapEnd()
                        self.success[_key1492] = _val1493
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1507, viter1508 in list(self.success.items()):
                oprot.writeI64(kiter1507)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1508))
                for kiter1509, viter1510 in list(viter1508.items()):
                    oprot.writeString(kiter1509.encode('utf-8') if sys.version_info[0] == 2 else kiter1509)
                    oprot.writeSetBegin(TType.STRUCT, len(viter1510))
                    for iter1511 in viter1510:
                        iter1511.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysCriteria_result)
selectKeysCriteria_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectKeysCcl_args(object):
    """
    Attributes:
     - keys
     - ccl
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, ccl=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.ccl = ccl
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1515, _size1512) = iprot.readListBegin()
                    for _i1516 in range(_size1512):
                        _elem1517 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1517)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysCcl_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1518 in self.keys:
                oprot.writeString(iter1518.encode('utf-8') if sys.version_info[0] == 2 else iter1518)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysCcl_args)
selectKeysCcl_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class selectKeysCcl_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1520, _vtype1521, _size1519) = iprot.readMapBegin()
                    for _i1523 in range(_size1519):
                        _key1524 = iprot.readI64()
                        _val1525 = {}
                        (_ktype1527, _vtype1528, _size1526) = iprot.readMapBegin()
                        for _i1530 in range(_size1526):
                            _key1531 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1532 = []
                            (_etype1536, _size1533) = iprot.readSetBegin()
                            for _i1537 in range(_size1533):
                                _elem1538 = TObject()
                                _elem1538.read(iprot)
                                _val1532.append(_elem1538)
                            iprot.readSetEnd()
                            _val1525[_key1531] = _val1532
                        iprot.readMapEnd()
                        self.success[_key1524] = _val1525
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysCcl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1539, viter1540 in list(self.success.items()):
                oprot.writeI64(kiter1539)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1540))
                for kiter1541, viter1542 in list(viter1540.items()):
                    oprot.writeString(kiter1541.encode('utf-8') if sys.version_info[0] == 2 else kiter1541)
                    oprot.writeSetBegin(TType.STRUCT, len(viter1542))
                    for iter1543 in viter1542:
                        iter1543.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysCcl_result)
selectKeysCcl_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectKeysCriteriaTime_args(object):
    """
    Attributes:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1547, _size1544) = iprot.readListBegin()
                    for _i1548 in range(_size1544):
                        _elem1549 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1549)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysCriteriaTime_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1550 in self.keys:
                oprot.writeString(iter1550.encode('utf-8') if sys.version_info[0] == 2 else iter1550)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysCriteriaTime_args)
selectKeysCriteriaTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class selectKeysCriteriaTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1552, _vtype1553, _size1551) = iprot.readMapBegin()
                    for _i1555 in range(_size1551):
                        _key1556 = iprot.readI64()
                        _val1557 = {}
                        (_ktype1559, _vtype1560, _size1558) = iprot.readMapBegin()
                        for _i1562 in range(_size1558):
                            _key1563 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1564 = []
                            (_etype1568, _size1565) = iprot.readSetBegin()
                            for _i1569 in range(_size1565):
                                _elem1570 = TObject()
                                _elem1570.read(iprot)
                                _val1564.append(_elem1570)
                            iprot.readSetEnd()
                            _val1557[_key1563] = _val1564
                        iprot.readMapEnd()
                        self.success[_key1556] = _val1557
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysCriteriaTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1571, viter1572 in list(self.success.items()):
                oprot.writeI64(kiter1571)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1572))
                for kiter1573, viter1574 in list(viter1572.items()):
                    oprot.writeString(kiter1573.encode('utf-8') if sys.version_info[0] == 2 else kiter1573)
                    oprot.writeSetBegin(TType.STRUCT, len(viter1574))
                    for iter1575 in viter1574:
                        iter1575.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysCriteriaTime_result)
selectKeysCriteriaTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class selectKeysCriteriaTimestr_args(object):
    """
    Attributes:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1579, _size1576) = iprot.readListBegin()
                    for _i1580 in range(_size1576):
                        _elem1581 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1581)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysCriteriaTimestr_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1582 in self.keys:
                oprot.writeString(iter1582.encode('utf-8') if sys.version_info[0] == 2 else iter1582)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysCriteriaTimestr_args)
selectKeysCriteriaTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class selectKeysCriteriaTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1584, _vtype1585, _size1583) = iprot.readMapBegin()
                    for _i1587 in range(_size1583):
                        _key1588 = iprot.readI64()
                        _val1589 = {}
                        (_ktype1591, _vtype1592, _size1590) = iprot.readMapBegin()
                        for _i1594 in range(_size1590):
                            _key1595 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1596 = []
                            (_etype1600, _size1597) = iprot.readSetBegin()
                            for _i1601 in range(_size1597):
                                _elem1602 = TObject()
                                _elem1602.read(iprot)
                                _val1596.append(_elem1602)
                            iprot.readSetEnd()
                            _val1589[_key1595] = _val1596
                        iprot.readMapEnd()
                        self.success[_key1588] = _val1589
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysCriteriaTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1603, viter1604 in list(self.success.items()):
                oprot.writeI64(kiter1603)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1604))
                for kiter1605, viter1606 in list(viter1604.items()):
                    oprot.writeString(kiter1605.encode('utf-8') if sys.version_info[0] == 2 else kiter1605)
                    oprot.writeSetBegin(TType.STRUCT, len(viter1606))
                    for iter1607 in viter1606:
                        iter1607.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysCriteriaTimestr_result)
selectKeysCriteriaTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectKeysCclTime_args(object):
    """
    Attributes:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1611, _size1608) = iprot.readListBegin()
                    for _i1612 in range(_size1608):
                        _elem1613 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1613)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysCclTime_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1614 in self.keys:
                oprot.writeString(iter1614.encode('utf-8') if sys.version_info[0] == 2 else iter1614)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysCclTime_args)
selectKeysCclTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class selectKeysCclTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1616, _vtype1617, _size1615) = iprot.readMapBegin()
                    for _i1619 in range(_size1615):
                        _key1620 = iprot.readI64()
                        _val1621 = {}
                        (_ktype1623, _vtype1624, _size1622) = iprot.readMapBegin()
                        for _i1626 in range(_size1622):
                            _key1627 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1628 = []
                            (_etype1632, _size1629) = iprot.readSetBegin()
                            for _i1633 in range(_size1629):
                                _elem1634 = TObject()
                                _elem1634.read(iprot)
                                _val1628.append(_elem1634)
                            iprot.readSetEnd()
                            _val1621[_key1627] = _val1628
                        iprot.readMapEnd()
                        self.success[_key1620] = _val1621
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysCclTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1635, viter1636 in list(self.success.items()):
                oprot.writeI64(kiter1635)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1636))
                for kiter1637, viter1638 in list(viter1636.items()):
                    oprot.writeString(kiter1637.encode('utf-8') if sys.version_info[0] == 2 else kiter1637)
                    oprot.writeSetBegin(TType.STRUCT, len(viter1638))
                    for iter1639 in viter1638:
                        iter1639.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysCclTime_result)
selectKeysCclTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class selectKeysCclTimestr_args(object):
    """
    Attributes:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1643, _size1640) = iprot.readListBegin()
                    for _i1644 in range(_size1640):
                        _elem1645 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1645)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysCclTimestr_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1646 in self.keys:
                oprot.writeString(iter1646.encode('utf-8') if sys.version_info[0] == 2 else iter1646)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysCclTimestr_args)
selectKeysCclTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class selectKeysCclTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1648, _vtype1649, _size1647) = iprot.readMapBegin()
                    for _i1651 in range(_size1647):
                        _key1652 = iprot.readI64()
                        _val1653 = {}
                        (_ktype1655, _vtype1656, _size1654) = iprot.readMapBegin()
                        for _i1658 in range(_size1654):
                            _key1659 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1660 = []
                            (_etype1664, _size1661) = iprot.readSetBegin()
                            for _i1665 in range(_size1661):
                                _elem1666 = TObject()
                                _elem1666.read(iprot)
                                _val1660.append(_elem1666)
                            iprot.readSetEnd()
                            _val1653[_key1659] = _val1660
                        iprot.readMapEnd()
                        self.success[_key1652] = _val1653
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('selectKeysCclTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1667, viter1668 in list(self.success.items()):
                oprot.writeI64(kiter1667)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1668))
                for kiter1669, viter1670 in list(viter1668.items()):
                    oprot.writeString(kiter1669.encode('utf-8') if sys.version_info[0] == 2 else kiter1669)
                    oprot.writeSetBegin(TType.STRUCT, len(viter1670))
                    for iter1671 in viter1670:
                        iter1671.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(selectKeysCclTimestr_result)
selectKeysCclTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getKeyRecord_args(object):
    """
    Attributes:
     - key
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyRecord_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyRecord_args)
getKeyRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class getKeyRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyRecord_result)
getKeyRecord_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class getKeyRecordTime_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyRecordTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyRecordTime_args)
getKeyRecordTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class getKeyRecordTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyRecordTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyRecordTime_result)
getKeyRecordTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class getKeyRecordTimestr_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyRecordTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyRecordTimestr_args)
getKeyRecordTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class getKeyRecordTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyRecordTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyRecordTimestr_result)
getKeyRecordTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getKeysRecord_args(object):
    """
    Attributes:
     - keys
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, record=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1675, _size1672) = iprot.readListBegin()
                    for _i1676 in range(_size1672):
                        _elem1677 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1677)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysRecord_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1678 in self.keys:
                oprot.writeString(iter1678.encode('utf-8') if sys.version_info[0] == 2 else iter1678)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysRecord_args)
getKeysRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class getKeysRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1680, _vtype1681, _size1679) = iprot.readMapBegin()
                    for _i1683 in range(_size1679):
                        _key1684 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val1685 = TObject()
                        _val1685.read(iprot)
                        self.success[_key1684] = _val1685
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter1686, viter1687 in list(self.success.items()):
                oprot.writeString(kiter1686.encode('utf-8') if sys.version_info[0] == 2 else kiter1686)
                viter1687.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysRecord_result)
getKeysRecord_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class getKeysRecordTime_args(object):
    """
    Attributes:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1691, _size1688) = iprot.readListBegin()
                    for _i1692 in range(_size1688):
                        _elem1693 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1693)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysRecordTime_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1694 in self.keys:
                oprot.writeString(iter1694.encode('utf-8') if sys.version_info[0] == 2 else iter1694)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysRecordTime_args)
getKeysRecordTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class getKeysRecordTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1696, _vtype1697, _size1695) = iprot.readMapBegin()
                    for _i1699 in range(_size1695):
                        _key1700 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val1701 = TObject()
                        _val1701.read(iprot)
                        self.success[_key1700] = _val1701
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysRecordTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter1702, viter1703 in list(self.success.items()):
                oprot.writeString(kiter1702.encode('utf-8') if sys.version_info[0] == 2 else kiter1702)
                viter1703.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysRecordTime_result)
getKeysRecordTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class getKeysRecordTimestr_args(object):
    """
    Attributes:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1707, _size1704) = iprot.readListBegin()
                    for _i1708 in range(_size1704):
                        _elem1709 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1709)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysRecordTimestr_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1710 in self.keys:
                oprot.writeString(iter1710.encode('utf-8') if sys.version_info[0] == 2 else iter1710)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysRecordTimestr_args)
getKeysRecordTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class getKeysRecordTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1712, _vtype1713, _size1711) = iprot.readMapBegin()
                    for _i1715 in range(_size1711):
                        _key1716 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val1717 = TObject()
                        _val1717.read(iprot)
                        self.success[_key1716] = _val1717
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysRecordTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter1718, viter1719 in list(self.success.items()):
                oprot.writeString(kiter1718.encode('utf-8') if sys.version_info[0] == 2 else kiter1718)
                viter1719.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysRecordTimestr_result)
getKeysRecordTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getKeysRecords_args(object):
    """
    Attributes:
     - keys
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, records=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1723, _size1720) = iprot.readListBegin()
                    for _i1724 in range(_size1720):
                        _elem1725 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1725)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype1729, _size1726) = iprot.readListBegin()
                    for _i1730 in range(_size1726):
                        _elem1731 = iprot.readI64()
                        self.records.append(_elem1731)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysRecords_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1732 in self.keys:
                oprot.writeString(iter1732.encode('utf-8') if sys.version_info[0] == 2 else iter1732)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter1733 in self.records:
                oprot.writeI64(iter1733)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysRecords_args)
getKeysRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class getKeysRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1735, _vtype1736, _size1734) = iprot.readMapBegin()
                    for _i1738 in range(_size1734):
                        _key1739 = iprot.readI64()
                        _val1740 = {}
                        (_ktype1742, _vtype1743, _size1741) = iprot.readMapBegin()
                        for _i1745 in range(_size1741):
                            _key1746 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1747 = TObject()
                            _val1747.read(iprot)
                            _val1740[_key1746] = _val1747
                        iprot.readMapEnd()
                        self.success[_key1739] = _val1740
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1748, viter1749 in list(self.success.items()):
                oprot.writeI64(kiter1748)
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1749))
                for kiter1750, viter1751 in list(viter1749.items()):
                    oprot.writeString(kiter1750.encode('utf-8') if sys.version_info[0] == 2 else kiter1750)
                    viter1751.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysRecords_result)
getKeysRecords_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class getKeyRecords_args(object):
    """
    Attributes:
     - key
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype1755, _size1752) = iprot.readListBegin()
                    for _i1756 in range(_size1752):
                        _elem1757 = iprot.readI64()
                        self.records.append(_elem1757)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyRecords_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter1758 in self.records:
                oprot.writeI64(iter1758)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyRecords_args)
getKeyRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class getKeyRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1760, _vtype1761, _size1759) = iprot.readMapBegin()
                    for _i1763 in range(_size1759):
                        _key1764 = iprot.readI64()
                        _val1765 = TObject()
                        _val1765.read(iprot)
                        self.success[_key1764] = _val1765
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
            for kiter1766, viter1767 in list(self.success.items()):
                oprot.writeI64(kiter1766)
                viter1767.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyRecords_result)
getKeyRecords_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRUCT, [TObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class getKeyRecordsTime_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype1771, _size1768) = iprot.readListBegin()
                    for _i1772 in range(_size1768):
                        _elem1773 = iprot.readI64()
                        self.records.append(_elem1773)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyRecordsTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter1774 in self.records:
                oprot.writeI64(iter1774)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyRecordsTime_args)
getKeyRecordsTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class getKeyRecordsTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1776, _vtype1777, _size1775) = iprot.readMapBegin()
                    for _i1779 in range(_size1775):
                        _key1780 = iprot.readI64()
                        _val1781 = TObject()
                        _val1781.read(iprot)
                        self.success[_key1780] = _val1781
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyRecordsTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
            for kiter1782, viter1783 in list(self.success.items()):
                oprot.writeI64(kiter1782)
                viter1783.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyRecordsTime_result)
getKeyRecordsTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRUCT, [TObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class getKeyRecordsTimestr_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype1787, _size1784) = iprot.readListBegin()
                    for _i1788 in range(_size1784):
                        _elem1789 = iprot.readI64()
                        self.records.append(_elem1789)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyRecordsTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter1790 in self.records:
                oprot.writeI64(iter1790)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyRecordsTimestr_args)
getKeyRecordsTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class getKeyRecordsTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1792, _vtype1793, _size1791) = iprot.readMapBegin()
                    for _i1795 in range(_size1791):
                        _key1796 = iprot.readI64()
                        _val1797 = TObject()
                        _val1797.read(iprot)
                        self.success[_key1796] = _val1797
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyRecordsTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
            for kiter1798, viter1799 in list(self.success.items()):
                oprot.writeI64(kiter1798)
                viter1799.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyRecordsTimestr_result)
getKeyRecordsTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRUCT, [TObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getKeysRecordsTime_args(object):
    """
    Attributes:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1803, _size1800) = iprot.readListBegin()
                    for _i1804 in range(_size1800):
                        _elem1805 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1805)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype1809, _size1806) = iprot.readListBegin()
                    for _i1810 in range(_size1806):
                        _elem1811 = iprot.readI64()
                        self.records.append(_elem1811)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysRecordsTime_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1812 in self.keys:
                oprot.writeString(iter1812.encode('utf-8') if sys.version_info[0] == 2 else iter1812)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter1813 in self.records:
                oprot.writeI64(iter1813)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysRecordsTime_args)
getKeysRecordsTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class getKeysRecordsTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1815, _vtype1816, _size1814) = iprot.readMapBegin()
                    for _i1818 in range(_size1814):
                        _key1819 = iprot.readI64()
                        _val1820 = {}
                        (_ktype1822, _vtype1823, _size1821) = iprot.readMapBegin()
                        for _i1825 in range(_size1821):
                            _key1826 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1827 = TObject()
                            _val1827.read(iprot)
                            _val1820[_key1826] = _val1827
                        iprot.readMapEnd()
                        self.success[_key1819] = _val1820
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysRecordsTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1828, viter1829 in list(self.success.items()):
                oprot.writeI64(kiter1828)
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1829))
                for kiter1830, viter1831 in list(viter1829.items()):
                    oprot.writeString(kiter1830.encode('utf-8') if sys.version_info[0] == 2 else kiter1830)
                    viter1831.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysRecordsTime_result)
getKeysRecordsTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class getKeysRecordsTimestr_args(object):
    """
    Attributes:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype1835, _size1832) = iprot.readListBegin()
                    for _i1836 in range(_size1832):
                        _elem1837 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem1837)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype1841, _size1838) = iprot.readListBegin()
                    for _i1842 in range(_size1838):
                        _elem1843 = iprot.readI64()
                        self.records.append(_elem1843)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysRecordsTimestr_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter1844 in self.keys:
                oprot.writeString(iter1844.encode('utf-8') if sys.version_info[0] == 2 else iter1844)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter1845 in self.records:
                oprot.writeI64(iter1845)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysRecordsTimestr_args)
getKeysRecordsTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class getKeysRecordsTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1847, _vtype1848, _size1846) = iprot.readMapBegin()
                    for _i1850 in range(_size1846):
                        _key1851 = iprot.readI64()
                        _val1852 = {}
                        (_ktype1854, _vtype1855, _size1853) = iprot.readMapBegin()
                        for _i1857 in range(_size1853):
                            _key1858 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1859 = TObject()
                            _val1859.read(iprot)
                            _val1852[_key1858] = _val1859
                        iprot.readMapEnd()
                        self.success[_key1851] = _val1852
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysRecordsTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1860, viter1861 in list(self.success.items()):
                oprot.writeI64(kiter1860)
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1861))
                for kiter1862, viter1863 in list(viter1861.items()):
                    oprot.writeString(kiter1862.encode('utf-8') if sys.version_info[0] == 2 else kiter1862)
                    viter1863.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysRecordsTimestr_result)
getKeysRecordsTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getKeyCriteria_args(object):
    """
    Attributes:
     - key
     - criteria
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyCriteria_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyCriteria_args)
getKeyCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class getKeyCriteria_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1865, _vtype1866, _size1864) = iprot.readMapBegin()
                    for _i1868 in range(_size1864):
                        _key1869 = iprot.readI64()
                        _val1870 = TObject()
                        _val1870.read(iprot)
                        self.success[_key1869] = _val1870
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
            for kiter1871, viter1872 in list(self.success.items()):
                oprot.writeI64(kiter1871)
                viter1872.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyCriteria_result)
getKeyCriteria_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRUCT, [TObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class getCriteria_args(object):
    """
    Attributes:
     - criteria
     - creds
     - transaction
     - environment

    """


    def __init__(self, criteria=None, creds=None, transaction=None, environment=None,):
        self.criteria = criteria
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCriteria_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCriteria_args)
getCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class getCriteria_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1874, _vtype1875, _size1873) = iprot.readMapBegin()
                    for _i1877 in range(_size1873):
                        _key1878 = iprot.readI64()
                        _val1879 = {}
                        (_ktype1881, _vtype1882, _size1880) = iprot.readMapBegin()
                        for _i1884 in range(_size1880):
                            _key1885 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1886 = TObject()
                            _val1886.read(iprot)
                            _val1879[_key1885] = _val1886
                        iprot.readMapEnd()
                        self.success[_key1878] = _val1879
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1887, viter1888 in list(self.success.items()):
                oprot.writeI64(kiter1887)
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1888))
                for kiter1889, viter1890 in list(viter1888.items()):
                    oprot.writeString(kiter1889.encode('utf-8') if sys.version_info[0] == 2 else kiter1889)
                    viter1890.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCriteria_result)
getCriteria_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class getCcl_args(object):
    """
    Attributes:
     - ccl
     - creds
     - transaction
     - environment

    """


    def __init__(self, ccl=None, creds=None, transaction=None, environment=None,):
        self.ccl = ccl
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCcl_args')
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 1)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCcl_args)
getCcl_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ccl', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class getCcl_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1892, _vtype1893, _size1891) = iprot.readMapBegin()
                    for _i1895 in range(_size1891):
                        _key1896 = iprot.readI64()
                        _val1897 = {}
                        (_ktype1899, _vtype1900, _size1898) = iprot.readMapBegin()
                        for _i1902 in range(_size1898):
                            _key1903 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1904 = TObject()
                            _val1904.read(iprot)
                            _val1897[_key1903] = _val1904
                        iprot.readMapEnd()
                        self.success[_key1896] = _val1897
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCcl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1905, viter1906 in list(self.success.items()):
                oprot.writeI64(kiter1905)
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1906))
                for kiter1907, viter1908 in list(viter1906.items()):
                    oprot.writeString(kiter1907.encode('utf-8') if sys.version_info[0] == 2 else kiter1907)
                    viter1908.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCcl_result)
getCcl_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getCriteriaTime_args(object):
    """
    Attributes:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCriteriaTime_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCriteriaTime_args)
getCriteriaTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class getCriteriaTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1910, _vtype1911, _size1909) = iprot.readMapBegin()
                    for _i1913 in range(_size1909):
                        _key1914 = iprot.readI64()
                        _val1915 = {}
                        (_ktype1917, _vtype1918, _size1916) = iprot.readMapBegin()
                        for _i1920 in range(_size1916):
                            _key1921 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1922 = TObject()
                            _val1922.read(iprot)
                            _val1915[_key1921] = _val1922
                        iprot.readMapEnd()
                        self.success[_key1914] = _val1915
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCriteriaTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1923, viter1924 in list(self.success.items()):
                oprot.writeI64(kiter1923)
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1924))
                for kiter1925, viter1926 in list(viter1924.items()):
                    oprot.writeString(kiter1925.encode('utf-8') if sys.version_info[0] == 2 else kiter1925)
                    viter1926.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCriteriaTime_result)
getCriteriaTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class getCriteriaTimestr_args(object):
    """
    Attributes:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCriteriaTimestr_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 2)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCriteriaTimestr_args)
getCriteriaTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 1
    (2, TType.STRING, 'timestamp', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class getCriteriaTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1928, _vtype1929, _size1927) = iprot.readMapBegin()
                    for _i1931 in range(_size1927):
                        _key1932 = iprot.readI64()
                        _val1933 = {}
                        (_ktype1935, _vtype1936, _size1934) = iprot.readMapBegin()
                        for _i1938 in range(_size1934):
                            _key1939 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1940 = TObject()
                            _val1940.read(iprot)
                            _val1933[_key1939] = _val1940
                        iprot.readMapEnd()
                        self.success[_key1932] = _val1933
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCriteriaTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1941, viter1942 in list(self.success.items()):
                oprot.writeI64(kiter1941)
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1942))
                for kiter1943, viter1944 in list(viter1942.items()):
                    oprot.writeString(kiter1943.encode('utf-8') if sys.version_info[0] == 2 else kiter1943)
                    viter1944.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCriteriaTimestr_result)
getCriteriaTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getCclTime_args(object):
    """
    Attributes:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCclTime_args')
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 1)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCclTime_args)
getCclTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ccl', 'UTF8', None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class getCclTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1946, _vtype1947, _size1945) = iprot.readMapBegin()
                    for _i1949 in range(_size1945):
                        _key1950 = iprot.readI64()
                        _val1951 = {}
                        (_ktype1953, _vtype1954, _size1952) = iprot.readMapBegin()
                        for _i1956 in range(_size1952):
                            _key1957 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1958 = TObject()
                            _val1958.read(iprot)
                            _val1951[_key1957] = _val1958
                        iprot.readMapEnd()
                        self.success[_key1950] = _val1951
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCclTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1959, viter1960 in list(self.success.items()):
                oprot.writeI64(kiter1959)
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1960))
                for kiter1961, viter1962 in list(viter1960.items()):
                    oprot.writeString(kiter1961.encode('utf-8') if sys.version_info[0] == 2 else kiter1961)
                    viter1962.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCclTime_result)
getCclTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getCclTimestr_args(object):
    """
    Attributes:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCclTimestr_args')
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 1)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 2)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCclTimestr_args)
getCclTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ccl', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'timestamp', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class getCclTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1964, _vtype1965, _size1963) = iprot.readMapBegin()
                    for _i1967 in range(_size1963):
                        _key1968 = iprot.readI64()
                        _val1969 = {}
                        (_ktype1971, _vtype1972, _size1970) = iprot.readMapBegin()
                        for _i1974 in range(_size1970):
                            _key1975 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val1976 = TObject()
                            _val1976.read(iprot)
                            _val1969[_key1975] = _val1976
                        iprot.readMapEnd()
                        self.success[_key1968] = _val1969
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCclTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter1977, viter1978 in list(self.success.items()):
                oprot.writeI64(kiter1977)
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1978))
                for kiter1979, viter1980 in list(viter1978.items()):
                    oprot.writeString(kiter1979.encode('utf-8') if sys.version_info[0] == 2 else kiter1979)
                    viter1980.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCclTimestr_result)
getCclTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getKeyCcl_args(object):
    """
    Attributes:
     - key
     - ccl
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyCcl_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyCcl_args)
getKeyCcl_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class getKeyCcl_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1982, _vtype1983, _size1981) = iprot.readMapBegin()
                    for _i1985 in range(_size1981):
                        _key1986 = iprot.readI64()
                        _val1987 = TObject()
                        _val1987.read(iprot)
                        self.success[_key1986] = _val1987
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyCcl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
            for kiter1988, viter1989 in list(self.success.items()):
                oprot.writeI64(kiter1988)
                viter1989.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyCcl_result)
getKeyCcl_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRUCT, [TObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getKeyCriteriaTime_args(object):
    """
    Attributes:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyCriteriaTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyCriteriaTime_args)
getKeyCriteriaTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class getKeyCriteriaTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1991, _vtype1992, _size1990) = iprot.readMapBegin()
                    for _i1994 in range(_size1990):
                        _key1995 = iprot.readI64()
                        _val1996 = TObject()
                        _val1996.read(iprot)
                        self.success[_key1995] = _val1996
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyCriteriaTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
            for kiter1997, viter1998 in list(self.success.items()):
                oprot.writeI64(kiter1997)
                viter1998.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyCriteriaTime_result)
getKeyCriteriaTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRUCT, [TObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class getKeyCriteriaTimestr_args(object):
    """
    Attributes:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyCriteriaTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyCriteriaTimestr_args)
getKeyCriteriaTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class getKeyCriteriaTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2000, _vtype2001, _size1999) = iprot.readMapBegin()
                    for _i2003 in range(_size1999):
                        _key2004 = iprot.readI64()
                        _val2005 = TObject()
                        _val2005.read(iprot)
                        self.success[_key2004] = _val2005
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyCriteriaTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
            for kiter2006, viter2007 in list(self.success.items()):
                oprot.writeI64(kiter2006)
                viter2007.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyCriteriaTimestr_result)
getKeyCriteriaTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRUCT, [TObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getKeyCclTime_args(object):
    """
    Attributes:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyCclTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyCclTime_args)
getKeyCclTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class getKeyCclTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2009, _vtype2010, _size2008) = iprot.readMapBegin()
                    for _i2012 in range(_size2008):
                        _key2013 = iprot.readI64()
                        _val2014 = TObject()
                        _val2014.read(iprot)
                        self.success[_key2013] = _val2014
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyCclTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
            for kiter2015, viter2016 in list(self.success.items()):
                oprot.writeI64(kiter2015)
                viter2016.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyCclTime_result)
getKeyCclTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRUCT, [TObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getKeyCclTimestr_args(object):
    """
    Attributes:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyCclTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyCclTimestr_args)
getKeyCclTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class getKeyCclTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2018, _vtype2019, _size2017) = iprot.readMapBegin()
                    for _i2021 in range(_size2017):
                        _key2022 = iprot.readI64()
                        _val2023 = TObject()
                        _val2023.read(iprot)
                        self.success[_key2022] = _val2023
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeyCclTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
            for kiter2024, viter2025 in list(self.success.items()):
                oprot.writeI64(kiter2024)
                viter2025.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeyCclTimestr_result)
getKeyCclTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRUCT, [TObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getKeysCriteria_args(object):
    """
    Attributes:
     - keys
     - criteria
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, criteria=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.criteria = criteria
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2029, _size2026) = iprot.readListBegin()
                    for _i2030 in range(_size2026):
                        _elem2031 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2031)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysCriteria_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2032 in self.keys:
                oprot.writeString(iter2032.encode('utf-8') if sys.version_info[0] == 2 else iter2032)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysCriteria_args)
getKeysCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class getKeysCriteria_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2034, _vtype2035, _size2033) = iprot.readMapBegin()
                    for _i2037 in range(_size2033):
                        _key2038 = iprot.readI64()
                        _val2039 = {}
                        (_ktype2041, _vtype2042, _size2040) = iprot.readMapBegin()
                        for _i2044 in range(_size2040):
                            _key2045 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val2046 = TObject()
                            _val2046.read(iprot)
                            _val2039[_key2045] = _val2046
                        iprot.readMapEnd()
                        self.success[_key2038] = _val2039
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter2047, viter2048 in list(self.success.items()):
                oprot.writeI64(kiter2047)
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2048))
                for kiter2049, viter2050 in list(viter2048.items()):
                    oprot.writeString(kiter2049.encode('utf-8') if sys.version_info[0] == 2 else kiter2049)
                    viter2050.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysCriteria_result)
getKeysCriteria_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class getKeysCcl_args(object):
    """
    Attributes:
     - keys
     - ccl
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, ccl=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.ccl = ccl
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2054, _size2051) = iprot.readListBegin()
                    for _i2055 in range(_size2051):
                        _elem2056 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2056)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysCcl_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2057 in self.keys:
                oprot.writeString(iter2057.encode('utf-8') if sys.version_info[0] == 2 else iter2057)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysCcl_args)
getKeysCcl_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class getKeysCcl_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2059, _vtype2060, _size2058) = iprot.readMapBegin()
                    for _i2062 in range(_size2058):
                        _key2063 = iprot.readI64()
                        _val2064 = {}
                        (_ktype2066, _vtype2067, _size2065) = iprot.readMapBegin()
                        for _i2069 in range(_size2065):
                            _key2070 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val2071 = TObject()
                            _val2071.read(iprot)
                            _val2064[_key2070] = _val2071
                        iprot.readMapEnd()
                        self.success[_key2063] = _val2064
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysCcl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter2072, viter2073 in list(self.success.items()):
                oprot.writeI64(kiter2072)
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2073))
                for kiter2074, viter2075 in list(viter2073.items()):
                    oprot.writeString(kiter2074.encode('utf-8') if sys.version_info[0] == 2 else kiter2074)
                    viter2075.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysCcl_result)
getKeysCcl_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getKeysCriteriaTime_args(object):
    """
    Attributes:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2079, _size2076) = iprot.readListBegin()
                    for _i2080 in range(_size2076):
                        _elem2081 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2081)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysCriteriaTime_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2082 in self.keys:
                oprot.writeString(iter2082.encode('utf-8') if sys.version_info[0] == 2 else iter2082)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysCriteriaTime_args)
getKeysCriteriaTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class getKeysCriteriaTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2084, _vtype2085, _size2083) = iprot.readMapBegin()
                    for _i2087 in range(_size2083):
                        _key2088 = iprot.readI64()
                        _val2089 = {}
                        (_ktype2091, _vtype2092, _size2090) = iprot.readMapBegin()
                        for _i2094 in range(_size2090):
                            _key2095 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val2096 = TObject()
                            _val2096.read(iprot)
                            _val2089[_key2095] = _val2096
                        iprot.readMapEnd()
                        self.success[_key2088] = _val2089
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysCriteriaTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter2097, viter2098 in list(self.success.items()):
                oprot.writeI64(kiter2097)
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2098))
                for kiter2099, viter2100 in list(viter2098.items()):
                    oprot.writeString(kiter2099.encode('utf-8') if sys.version_info[0] == 2 else kiter2099)
                    viter2100.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysCriteriaTime_result)
getKeysCriteriaTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class getKeysCriteriaTimestr_args(object):
    """
    Attributes:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2104, _size2101) = iprot.readListBegin()
                    for _i2105 in range(_size2101):
                        _elem2106 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2106)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysCriteriaTimestr_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2107 in self.keys:
                oprot.writeString(iter2107.encode('utf-8') if sys.version_info[0] == 2 else iter2107)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysCriteriaTimestr_args)
getKeysCriteriaTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class getKeysCriteriaTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2109, _vtype2110, _size2108) = iprot.readMapBegin()
                    for _i2112 in range(_size2108):
                        _key2113 = iprot.readI64()
                        _val2114 = {}
                        (_ktype2116, _vtype2117, _size2115) = iprot.readMapBegin()
                        for _i2119 in range(_size2115):
                            _key2120 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val2121 = TObject()
                            _val2121.read(iprot)
                            _val2114[_key2120] = _val2121
                        iprot.readMapEnd()
                        self.success[_key2113] = _val2114
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysCriteriaTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter2122, viter2123 in list(self.success.items()):
                oprot.writeI64(kiter2122)
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2123))
                for kiter2124, viter2125 in list(viter2123.items()):
                    oprot.writeString(kiter2124.encode('utf-8') if sys.version_info[0] == 2 else kiter2124)
                    viter2125.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysCriteriaTimestr_result)
getKeysCriteriaTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getKeysCclTime_args(object):
    """
    Attributes:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2129, _size2126) = iprot.readListBegin()
                    for _i2130 in range(_size2126):
                        _elem2131 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2131)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysCclTime_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2132 in self.keys:
                oprot.writeString(iter2132.encode('utf-8') if sys.version_info[0] == 2 else iter2132)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysCclTime_args)
getKeysCclTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class getKeysCclTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2134, _vtype2135, _size2133) = iprot.readMapBegin()
                    for _i2137 in range(_size2133):
                        _key2138 = iprot.readI64()
                        _val2139 = {}
                        (_ktype2141, _vtype2142, _size2140) = iprot.readMapBegin()
                        for _i2144 in range(_size2140):
                            _key2145 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val2146 = TObject()
                            _val2146.read(iprot)
                            _val2139[_key2145] = _val2146
                        iprot.readMapEnd()
                        self.success[_key2138] = _val2139
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysCclTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter2147, viter2148 in list(self.success.items()):
                oprot.writeI64(kiter2147)
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2148))
                for kiter2149, viter2150 in list(viter2148.items()):
                    oprot.writeString(kiter2149.encode('utf-8') if sys.version_info[0] == 2 else kiter2149)
                    viter2150.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysCclTime_result)
getKeysCclTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getKeysCclTimestr_args(object):
    """
    Attributes:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2154, _size2151) = iprot.readListBegin()
                    for _i2155 in range(_size2151):
                        _elem2156 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2156)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysCclTimestr_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2157 in self.keys:
                oprot.writeString(iter2157.encode('utf-8') if sys.version_info[0] == 2 else iter2157)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysCclTimestr_args)
getKeysCclTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class getKeysCclTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2159, _vtype2160, _size2158) = iprot.readMapBegin()
                    for _i2162 in range(_size2158):
                        _key2163 = iprot.readI64()
                        _val2164 = {}
                        (_ktype2166, _vtype2167, _size2165) = iprot.readMapBegin()
                        for _i2169 in range(_size2165):
                            _key2170 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val2171 = TObject()
                            _val2171.read(iprot)
                            _val2164[_key2170] = _val2171
                        iprot.readMapEnd()
                        self.success[_key2163] = _val2164
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getKeysCclTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter2172, viter2173 in list(self.success.items()):
                oprot.writeI64(kiter2172)
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2173))
                for kiter2174, viter2175 in list(viter2173.items()):
                    oprot.writeString(kiter2174.encode('utf-8') if sys.version_info[0] == 2 else kiter2174)
                    viter2175.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getKeysCclTimestr_result)
getKeysCclTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class verifyKeyValueRecord_args(object):
    """
    Attributes:
     - key
     - value
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.value = value
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.value = TObject()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verifyKeyValueRecord_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 2)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 3)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verifyKeyValueRecord_args)
verifyKeyValueRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'value', [TObject, None], None, ),  # 2
    (3, TType.I64, 'record', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class verifyKeyValueRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verifyKeyValueRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verifyKeyValueRecord_result)
verifyKeyValueRecord_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class verifyKeyValueRecordTime_args(object):
    """
    Attributes:
     - key
     - value
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, value=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.value = value
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.value = TObject()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verifyKeyValueRecordTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 2)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 3)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 4)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 5)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 7)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verifyKeyValueRecordTime_args)
verifyKeyValueRecordTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'value', [TObject, None], None, ),  # 2
    (3, TType.I64, 'record', None, None, ),  # 3
    (4, TType.I64, 'timestamp', None, None, ),  # 4
    (5, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 5
    (6, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 6
    (7, TType.STRING, 'environment', 'UTF8', None, ),  # 7
)


class verifyKeyValueRecordTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verifyKeyValueRecordTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verifyKeyValueRecordTime_result)
verifyKeyValueRecordTime_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class verifyKeyValueRecordTimestr_args(object):
    """
    Attributes:
     - key
     - value
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, value=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.value = value
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.value = TObject()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verifyKeyValueRecordTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 2)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 3)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 4)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 5)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 7)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verifyKeyValueRecordTimestr_args)
verifyKeyValueRecordTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'value', [TObject, None], None, ),  # 2
    (3, TType.I64, 'record', None, None, ),  # 3
    (4, TType.STRING, 'timestamp', 'UTF8', None, ),  # 4
    (5, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 5
    (6, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 6
    (7, TType.STRING, 'environment', 'UTF8', None, ),  # 7
)


class verifyKeyValueRecordTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verifyKeyValueRecordTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verifyKeyValueRecordTimestr_result)
verifyKeyValueRecordTimestr_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class jsonifyRecords_args(object):
    """
    Attributes:
     - records
     - identifier
     - creds
     - transaction
     - environment

    """


    def __init__(self, records=None, identifier=None, creds=None, transaction=None, environment=None,):
        self.records = records
        self.identifier = identifier
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2179, _size2176) = iprot.readListBegin()
                    for _i2180 in range(_size2176):
                        _elem2181 = iprot.readI64()
                        self.records.append(_elem2181)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.identifier = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('jsonifyRecords_args')
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2182 in self.records:
                oprot.writeI64(iter2182)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.identifier is not None:
            oprot.writeFieldBegin('identifier', TType.BOOL, 2)
            oprot.writeBool(self.identifier)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(jsonifyRecords_args)
jsonifyRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 1
    (2, TType.BOOL, 'identifier', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class jsonifyRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('jsonifyRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(jsonifyRecords_result)
jsonifyRecords_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class jsonifyRecordsTime_args(object):
    """
    Attributes:
     - records
     - timestamp
     - identifier
     - creds
     - transaction
     - environment

    """


    def __init__(self, records=None, timestamp=None, identifier=None, creds=None, transaction=None, environment=None,):
        self.records = records
        self.timestamp = timestamp
        self.identifier = identifier
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2186, _size2183) = iprot.readListBegin()
                    for _i2187 in range(_size2183):
                        _elem2188 = iprot.readI64()
                        self.records.append(_elem2188)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.identifier = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('jsonifyRecordsTime_args')
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2189 in self.records:
                oprot.writeI64(iter2189)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.identifier is not None:
            oprot.writeFieldBegin('identifier', TType.BOOL, 3)
            oprot.writeBool(self.identifier)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(jsonifyRecordsTime_args)
jsonifyRecordsTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.BOOL, 'identifier', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class jsonifyRecordsTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('jsonifyRecordsTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(jsonifyRecordsTime_result)
jsonifyRecordsTime_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class jsonifyRecordsTimestr_args(object):
    """
    Attributes:
     - records
     - timestamp
     - identifier
     - creds
     - transaction
     - environment

    """


    def __init__(self, records=None, timestamp=None, identifier=None, creds=None, transaction=None, environment=None,):
        self.records = records
        self.timestamp = timestamp
        self.identifier = identifier
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2193, _size2190) = iprot.readListBegin()
                    for _i2194 in range(_size2190):
                        _elem2195 = iprot.readI64()
                        self.records.append(_elem2195)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.identifier = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('jsonifyRecordsTimestr_args')
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2196 in self.records:
                oprot.writeI64(iter2196)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 2)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.identifier is not None:
            oprot.writeFieldBegin('identifier', TType.BOOL, 3)
            oprot.writeBool(self.identifier)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(jsonifyRecordsTimestr_args)
jsonifyRecordsTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRING, 'timestamp', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'identifier', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class jsonifyRecordsTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('jsonifyRecordsTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(jsonifyRecordsTimestr_result)
jsonifyRecordsTimestr_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class findCriteria_args(object):
    """
    Attributes:
     - criteria
     - creds
     - transaction
     - environment

    """


    def __init__(self, criteria=None, creds=None, transaction=None, environment=None,):
        self.criteria = criteria
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findCriteria_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findCriteria_args)
findCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class findCriteria_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype2200, _size2197) = iprot.readSetBegin()
                    for _i2201 in range(_size2197):
                        _elem2202 = iprot.readI64()
                        self.success.append(_elem2202)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I64, len(self.success))
            for iter2203 in self.success:
                oprot.writeI64(iter2203)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findCriteria_result)
findCriteria_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class findCcl_args(object):
    """
    Attributes:
     - ccl
     - creds
     - transaction
     - environment

    """


    def __init__(self, ccl=None, creds=None, transaction=None, environment=None,):
        self.ccl = ccl
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findCcl_args')
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 1)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findCcl_args)
findCcl_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ccl', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class findCcl_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype2207, _size2204) = iprot.readSetBegin()
                    for _i2208 in range(_size2204):
                        _elem2209 = iprot.readI64()
                        self.success.append(_elem2209)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findCcl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I64, len(self.success))
            for iter2210 in self.success:
                oprot.writeI64(iter2210)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findCcl_result)
findCcl_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class findKeyOperatorValues_args(object):
    """
    Attributes:
     - key
     - operator
     - values
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, operator=None, values=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.operator = operator
        self.values = values
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype2214, _size2211) = iprot.readListBegin()
                    for _i2215 in range(_size2211):
                        _elem2216 = TObject()
                        _elem2216.read(iprot)
                        self.values.append(_elem2216)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findKeyOperatorValues_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.operator is not None:
            oprot.writeFieldBegin('operator', TType.I32, 2)
            oprot.writeI32(self.operator)
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.values))
            for iter2217 in self.values:
                iter2217.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findKeyOperatorValues_args)
findKeyOperatorValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I32, 'operator', None, None, ),  # 2
    (3, TType.LIST, 'values', (TType.STRUCT, [TObject, None], False), None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class findKeyOperatorValues_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype2221, _size2218) = iprot.readSetBegin()
                    for _i2222 in range(_size2218):
                        _elem2223 = iprot.readI64()
                        self.success.append(_elem2223)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findKeyOperatorValues_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I64, len(self.success))
            for iter2224 in self.success:
                oprot.writeI64(iter2224)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findKeyOperatorValues_result)
findKeyOperatorValues_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class findKeyOperatorValuesTime_args(object):
    """
    Attributes:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, operator=None, values=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.operator = operator
        self.values = values
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype2228, _size2225) = iprot.readListBegin()
                    for _i2229 in range(_size2225):
                        _elem2230 = TObject()
                        _elem2230.read(iprot)
                        self.values.append(_elem2230)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findKeyOperatorValuesTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.operator is not None:
            oprot.writeFieldBegin('operator', TType.I32, 2)
            oprot.writeI32(self.operator)
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.values))
            for iter2231 in self.values:
                iter2231.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 4)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 5)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 7)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findKeyOperatorValuesTime_args)
findKeyOperatorValuesTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I32, 'operator', None, None, ),  # 2
    (3, TType.LIST, 'values', (TType.STRUCT, [TObject, None], False), None, ),  # 3
    (4, TType.I64, 'timestamp', None, None, ),  # 4
    (5, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 5
    (6, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 6
    (7, TType.STRING, 'environment', 'UTF8', None, ),  # 7
)


class findKeyOperatorValuesTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype2235, _size2232) = iprot.readSetBegin()
                    for _i2236 in range(_size2232):
                        _elem2237 = iprot.readI64()
                        self.success.append(_elem2237)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findKeyOperatorValuesTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I64, len(self.success))
            for iter2238 in self.success:
                oprot.writeI64(iter2238)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findKeyOperatorValuesTime_result)
findKeyOperatorValuesTime_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class findKeyOperatorValuesTimestr_args(object):
    """
    Attributes:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, operator=None, values=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.operator = operator
        self.values = values
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype2242, _size2239) = iprot.readListBegin()
                    for _i2243 in range(_size2239):
                        _elem2244 = TObject()
                        _elem2244.read(iprot)
                        self.values.append(_elem2244)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findKeyOperatorValuesTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.operator is not None:
            oprot.writeFieldBegin('operator', TType.I32, 2)
            oprot.writeI32(self.operator)
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.values))
            for iter2245 in self.values:
                iter2245.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 4)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 5)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 7)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findKeyOperatorValuesTimestr_args)
findKeyOperatorValuesTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I32, 'operator', None, None, ),  # 2
    (3, TType.LIST, 'values', (TType.STRUCT, [TObject, None], False), None, ),  # 3
    (4, TType.STRING, 'timestamp', 'UTF8', None, ),  # 4
    (5, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 5
    (6, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 6
    (7, TType.STRING, 'environment', 'UTF8', None, ),  # 7
)


class findKeyOperatorValuesTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype2249, _size2246) = iprot.readSetBegin()
                    for _i2250 in range(_size2246):
                        _elem2251 = iprot.readI64()
                        self.success.append(_elem2251)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findKeyOperatorValuesTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I64, len(self.success))
            for iter2252 in self.success:
                oprot.writeI64(iter2252)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findKeyOperatorValuesTimestr_result)
findKeyOperatorValuesTimestr_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class findKeyOperatorstrValues_args(object):
    """
    Attributes:
     - key
     - operator
     - values
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, operator=None, values=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.operator = operator
        self.values = values
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.operator = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype2256, _size2253) = iprot.readListBegin()
                    for _i2257 in range(_size2253):
                        _elem2258 = TObject()
                        _elem2258.read(iprot)
                        self.values.append(_elem2258)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findKeyOperatorstrValues_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.operator is not None:
            oprot.writeFieldBegin('operator', TType.STRING, 2)
            oprot.writeString(self.operator.encode('utf-8') if sys.version_info[0] == 2 else self.operator)
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.values))
            for iter2259 in self.values:
                iter2259.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findKeyOperatorstrValues_args)
findKeyOperatorstrValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'operator', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'values', (TType.STRUCT, [TObject, None], False), None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class findKeyOperatorstrValues_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype2263, _size2260) = iprot.readSetBegin()
                    for _i2264 in range(_size2260):
                        _elem2265 = iprot.readI64()
                        self.success.append(_elem2265)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findKeyOperatorstrValues_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I64, len(self.success))
            for iter2266 in self.success:
                oprot.writeI64(iter2266)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findKeyOperatorstrValues_result)
findKeyOperatorstrValues_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class findKeyOperatorstrValuesTime_args(object):
    """
    Attributes:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, operator=None, values=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.operator = operator
        self.values = values
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.operator = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype2270, _size2267) = iprot.readListBegin()
                    for _i2271 in range(_size2267):
                        _elem2272 = TObject()
                        _elem2272.read(iprot)
                        self.values.append(_elem2272)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findKeyOperatorstrValuesTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.operator is not None:
            oprot.writeFieldBegin('operator', TType.STRING, 2)
            oprot.writeString(self.operator.encode('utf-8') if sys.version_info[0] == 2 else self.operator)
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.values))
            for iter2273 in self.values:
                iter2273.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 4)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 5)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 7)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findKeyOperatorstrValuesTime_args)
findKeyOperatorstrValuesTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'operator', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'values', (TType.STRUCT, [TObject, None], False), None, ),  # 3
    (4, TType.I64, 'timestamp', None, None, ),  # 4
    (5, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 5
    (6, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 6
    (7, TType.STRING, 'environment', 'UTF8', None, ),  # 7
)


class findKeyOperatorstrValuesTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype2277, _size2274) = iprot.readSetBegin()
                    for _i2278 in range(_size2274):
                        _elem2279 = iprot.readI64()
                        self.success.append(_elem2279)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findKeyOperatorstrValuesTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I64, len(self.success))
            for iter2280 in self.success:
                oprot.writeI64(iter2280)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findKeyOperatorstrValuesTime_result)
findKeyOperatorstrValuesTime_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class findKeyOperatorstrValuesTimestr_args(object):
    """
    Attributes:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, operator=None, values=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.operator = operator
        self.values = values
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.operator = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype2284, _size2281) = iprot.readListBegin()
                    for _i2285 in range(_size2281):
                        _elem2286 = TObject()
                        _elem2286.read(iprot)
                        self.values.append(_elem2286)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findKeyOperatorstrValuesTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.operator is not None:
            oprot.writeFieldBegin('operator', TType.STRING, 2)
            oprot.writeString(self.operator.encode('utf-8') if sys.version_info[0] == 2 else self.operator)
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.values))
            for iter2287 in self.values:
                iter2287.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 4)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 5)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 7)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findKeyOperatorstrValuesTimestr_args)
findKeyOperatorstrValuesTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'operator', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'values', (TType.STRUCT, [TObject, None], False), None, ),  # 3
    (4, TType.STRING, 'timestamp', 'UTF8', None, ),  # 4
    (5, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 5
    (6, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 6
    (7, TType.STRING, 'environment', 'UTF8', None, ),  # 7
)


class findKeyOperatorstrValuesTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype2291, _size2288) = iprot.readSetBegin()
                    for _i2292 in range(_size2288):
                        _elem2293 = iprot.readI64()
                        self.success.append(_elem2293)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findKeyOperatorstrValuesTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I64, len(self.success))
            for iter2294 in self.success:
                oprot.writeI64(iter2294)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findKeyOperatorstrValuesTimestr_result)
findKeyOperatorstrValuesTimestr_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class search_args(object):
    """
    Attributes:
     - key
     - query
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, query=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.query = query
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.query = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('search_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRING, 2)
            oprot.writeString(self.query.encode('utf-8') if sys.version_info[0] == 2 else self.query)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(search_args)
search_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'query', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class search_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = []
                    (_etype2298, _size2295) = iprot.readSetBegin()
                    for _i2299 in range(_size2295):
                        _elem2300 = iprot.readI64()
                        self.success.append(_elem2300)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('search_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I64, len(self.success))
            for iter2301 in self.success:
                oprot.writeI64(iter2301)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(search_result)
search_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class revertKeysRecordsTime_args(object):
    """
    Attributes:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2305, _size2302) = iprot.readListBegin()
                    for _i2306 in range(_size2302):
                        _elem2307 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2307)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2311, _size2308) = iprot.readListBegin()
                    for _i2312 in range(_size2308):
                        _elem2313 = iprot.readI64()
                        self.records.append(_elem2313)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revertKeysRecordsTime_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2314 in self.keys:
                oprot.writeString(iter2314.encode('utf-8') if sys.version_info[0] == 2 else iter2314)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2315 in self.records:
                oprot.writeI64(iter2315)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revertKeysRecordsTime_args)
revertKeysRecordsTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class revertKeysRecordsTime_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3

    """


    def __init__(self, ex=None, ex2=None, ex3=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revertKeysRecordsTime_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revertKeysRecordsTime_result)
revertKeysRecordsTime_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class revertKeysRecordsTimestr_args(object):
    """
    Attributes:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2319, _size2316) = iprot.readListBegin()
                    for _i2320 in range(_size2316):
                        _elem2321 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2321)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2325, _size2322) = iprot.readListBegin()
                    for _i2326 in range(_size2322):
                        _elem2327 = iprot.readI64()
                        self.records.append(_elem2327)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revertKeysRecordsTimestr_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2328 in self.keys:
                oprot.writeString(iter2328.encode('utf-8') if sys.version_info[0] == 2 else iter2328)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2329 in self.records:
                oprot.writeI64(iter2329)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revertKeysRecordsTimestr_args)
revertKeysRecordsTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class revertKeysRecordsTimestr_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, ex=None, ex2=None, ex3=None, ex4=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revertKeysRecordsTimestr_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revertKeysRecordsTimestr_result)
revertKeysRecordsTimestr_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class revertKeysRecordTime_args(object):
    """
    Attributes:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2333, _size2330) = iprot.readListBegin()
                    for _i2334 in range(_size2330):
                        _elem2335 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2335)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revertKeysRecordTime_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2336 in self.keys:
                oprot.writeString(iter2336.encode('utf-8') if sys.version_info[0] == 2 else iter2336)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revertKeysRecordTime_args)
revertKeysRecordTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class revertKeysRecordTime_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3

    """


    def __init__(self, ex=None, ex2=None, ex3=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revertKeysRecordTime_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revertKeysRecordTime_result)
revertKeysRecordTime_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class revertKeysRecordTimestr_args(object):
    """
    Attributes:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2340, _size2337) = iprot.readListBegin()
                    for _i2341 in range(_size2337):
                        _elem2342 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2342)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revertKeysRecordTimestr_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2343 in self.keys:
                oprot.writeString(iter2343.encode('utf-8') if sys.version_info[0] == 2 else iter2343)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revertKeysRecordTimestr_args)
revertKeysRecordTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class revertKeysRecordTimestr_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, ex=None, ex2=None, ex3=None, ex4=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revertKeysRecordTimestr_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revertKeysRecordTimestr_result)
revertKeysRecordTimestr_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class revertKeyRecordsTime_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2347, _size2344) = iprot.readListBegin()
                    for _i2348 in range(_size2344):
                        _elem2349 = iprot.readI64()
                        self.records.append(_elem2349)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revertKeyRecordsTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2350 in self.records:
                oprot.writeI64(iter2350)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revertKeyRecordsTime_args)
revertKeyRecordsTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class revertKeyRecordsTime_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3

    """


    def __init__(self, ex=None, ex2=None, ex3=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revertKeyRecordsTime_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revertKeyRecordsTime_result)
revertKeyRecordsTime_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class revertKeyRecordsTimestr_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2354, _size2351) = iprot.readListBegin()
                    for _i2355 in range(_size2351):
                        _elem2356 = iprot.readI64()
                        self.records.append(_elem2356)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revertKeyRecordsTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2357 in self.records:
                oprot.writeI64(iter2357)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revertKeyRecordsTimestr_args)
revertKeyRecordsTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class revertKeyRecordsTimestr_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, ex=None, ex2=None, ex3=None, ex4=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revertKeyRecordsTimestr_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revertKeyRecordsTimestr_result)
revertKeyRecordsTimestr_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class revertKeyRecordTime_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revertKeyRecordTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revertKeyRecordTime_args)
revertKeyRecordTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class revertKeyRecordTime_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3

    """


    def __init__(self, ex=None, ex2=None, ex3=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revertKeyRecordTime_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revertKeyRecordTime_result)
revertKeyRecordTime_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class revertKeyRecordTimestr_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revertKeyRecordTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revertKeyRecordTimestr_args)
revertKeyRecordTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class revertKeyRecordTimestr_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, ex=None, ex2=None, ex3=None, ex4=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revertKeyRecordTimestr_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revertKeyRecordTimestr_result)
revertKeyRecordTimestr_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class pingRecords_args(object):
    """
    Attributes:
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, records=None, creds=None, transaction=None, environment=None,):
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2361, _size2358) = iprot.readListBegin()
                    for _i2362 in range(_size2358):
                        _elem2363 = iprot.readI64()
                        self.records.append(_elem2363)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pingRecords_args')
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2364 in self.records:
                oprot.writeI64(iter2364)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pingRecords_args)
pingRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class pingRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2366, _vtype2367, _size2365) = iprot.readMapBegin()
                    for _i2369 in range(_size2365):
                        _key2370 = iprot.readI64()
                        _val2371 = iprot.readBool()
                        self.success[_key2370] = _val2371
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pingRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.BOOL, len(self.success))
            for kiter2372, viter2373 in list(self.success.items()):
                oprot.writeI64(kiter2372)
                oprot.writeBool(viter2373)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pingRecords_result)
pingRecords_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.BOOL, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class pingRecord_args(object):
    """
    Attributes:
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, record=None, creds=None, transaction=None, environment=None,):
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pingRecord_args')
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 1)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pingRecord_args)
pingRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'record', None, None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class pingRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pingRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pingRecord_result)
pingRecord_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class verifyAndSwap_args(object):
    """
    Attributes:
     - key
     - expected
     - record
     - replacement
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, expected=None, record=None, replacement=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.expected = expected
        self.record = record
        self.replacement = replacement
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.expected = TObject()
                    self.expected.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.replacement = TObject()
                    self.replacement.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verifyAndSwap_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.expected is not None:
            oprot.writeFieldBegin('expected', TType.STRUCT, 2)
            self.expected.write(oprot)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 3)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.replacement is not None:
            oprot.writeFieldBegin('replacement', TType.STRUCT, 4)
            self.replacement.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 5)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 7)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verifyAndSwap_args)
verifyAndSwap_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'expected', [TObject, None], None, ),  # 2
    (3, TType.I64, 'record', None, None, ),  # 3
    (4, TType.STRUCT, 'replacement', [TObject, None], None, ),  # 4
    (5, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 5
    (6, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 6
    (7, TType.STRING, 'environment', 'UTF8', None, ),  # 7
)


class verifyAndSwap_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verifyAndSwap_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verifyAndSwap_result)
verifyAndSwap_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class verifyOrSet_args(object):
    """
    Attributes:
     - key
     - value
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.value = value
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.value = TObject()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verifyOrSet_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 2)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 3)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verifyOrSet_args)
verifyOrSet_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'value', [TObject, None], None, ),  # 2
    (3, TType.I64, 'record', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class verifyOrSet_result(object):
    """
    Attributes:
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, ex=None, ex2=None, ex3=None, ex4=None,):
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = InvalidArgumentException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verifyOrSet_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verifyOrSet_result)
verifyOrSet_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [InvalidArgumentException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class findOrAddKeyValue_args(object):
    """
    Attributes:
     - key
     - value
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, value=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.value = value
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.value = TObject()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findOrAddKeyValue_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 2)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findOrAddKeyValue_args)
findOrAddKeyValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'value', [TObject, None], None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class findOrAddKeyValue_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4
     - ex5

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None, ex5=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4
        self.ex5 = ex5

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = DuplicateEntryException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = InvalidArgumentException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.ex5 = PermissionException()
                    self.ex5.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findOrAddKeyValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        if self.ex5 is not None:
            oprot.writeFieldBegin('ex5', TType.STRUCT, 5)
            self.ex5.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findOrAddKeyValue_result)
findOrAddKeyValue_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [DuplicateEntryException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [InvalidArgumentException, None], None, ),  # 4
    (5, TType.STRUCT, 'ex5', [PermissionException, None], None, ),  # 5
)


class findOrInsertCriteriaJson_args(object):
    """
    Attributes:
     - criteria
     - json
     - creds
     - transaction
     - environment

    """


    def __init__(self, criteria=None, json=None, creds=None, transaction=None, environment=None,):
        self.criteria = criteria
        self.json = json
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.json = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findOrInsertCriteriaJson_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.json is not None:
            oprot.writeFieldBegin('json', TType.STRING, 2)
            oprot.writeString(self.json.encode('utf-8') if sys.version_info[0] == 2 else self.json)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findOrInsertCriteriaJson_args)
findOrInsertCriteriaJson_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 1
    (2, TType.STRING, 'json', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class findOrInsertCriteriaJson_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = DuplicateEntryException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findOrInsertCriteriaJson_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findOrInsertCriteriaJson_result)
findOrInsertCriteriaJson_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [DuplicateEntryException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class findOrInsertCclJson_args(object):
    """
    Attributes:
     - ccl
     - json
     - creds
     - transaction
     - environment

    """


    def __init__(self, ccl=None, json=None, creds=None, transaction=None, environment=None,):
        self.ccl = ccl
        self.json = json
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.json = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findOrInsertCclJson_args')
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 1)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.json is not None:
            oprot.writeFieldBegin('json', TType.STRING, 2)
            oprot.writeString(self.json.encode('utf-8') if sys.version_info[0] == 2 else self.json)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findOrInsertCclJson_args)
findOrInsertCclJson_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ccl', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'json', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class findOrInsertCclJson_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4
     - ex5

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None, ex5=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4
        self.ex5 = ex5

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = DuplicateEntryException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.ex5 = PermissionException()
                    self.ex5.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findOrInsertCclJson_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        if self.ex5 is not None:
            oprot.writeFieldBegin('ex5', TType.STRUCT, 5)
            self.ex5.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findOrInsertCclJson_result)
findOrInsertCclJson_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [DuplicateEntryException, None], None, ),  # 4
    (5, TType.STRUCT, 'ex5', [PermissionException, None], None, ),  # 5
)


class sumKeyRecord_args(object):
    """
    Attributes:
     - key
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyRecord_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyRecord_args)
sumKeyRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class sumKeyRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyRecord_result)
sumKeyRecord_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class sumKeyRecordTime_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyRecordTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyRecordTime_args)
sumKeyRecordTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class sumKeyRecordTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyRecordTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyRecordTime_result)
sumKeyRecordTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class sumKeyRecordTimestr_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyRecordTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyRecordTimestr_args)
sumKeyRecordTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class sumKeyRecordTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyRecordTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyRecordTimestr_result)
sumKeyRecordTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class sumKeyRecords_args(object):
    """
    Attributes:
     - key
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2377, _size2374) = iprot.readListBegin()
                    for _i2378 in range(_size2374):
                        _elem2379 = iprot.readI64()
                        self.records.append(_elem2379)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyRecords_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2380 in self.records:
                oprot.writeI64(iter2380)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyRecords_args)
sumKeyRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class sumKeyRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyRecords_result)
sumKeyRecords_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class sumKeyRecordsTime_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2384, _size2381) = iprot.readListBegin()
                    for _i2385 in range(_size2381):
                        _elem2386 = iprot.readI64()
                        self.records.append(_elem2386)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyRecordsTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2387 in self.records:
                oprot.writeI64(iter2387)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyRecordsTime_args)
sumKeyRecordsTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class sumKeyRecordsTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyRecordsTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyRecordsTime_result)
sumKeyRecordsTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class sumKeyRecordsTimestr_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2391, _size2388) = iprot.readListBegin()
                    for _i2392 in range(_size2388):
                        _elem2393 = iprot.readI64()
                        self.records.append(_elem2393)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyRecordsTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2394 in self.records:
                oprot.writeI64(iter2394)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyRecordsTimestr_args)
sumKeyRecordsTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class sumKeyRecordsTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyRecordsTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyRecordsTimestr_result)
sumKeyRecordsTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class sumKey_args(object):
    """
    Attributes:
     - key
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKey_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKey_args)
sumKey_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class sumKey_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKey_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKey_result)
sumKey_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class sumKeyTime_args(object):
    """
    Attributes:
     - key
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyTime_args)
sumKeyTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class sumKeyTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyTime_result)
sumKeyTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class sumKeyTimestr_args(object):
    """
    Attributes:
     - key
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 2)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyTimestr_args)
sumKeyTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'timestamp', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class sumKeyTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyTimestr_result)
sumKeyTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class sumKeyCriteria_args(object):
    """
    Attributes:
     - key
     - criteria
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyCriteria_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyCriteria_args)
sumKeyCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class sumKeyCriteria_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyCriteria_result)
sumKeyCriteria_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class sumKeyCriteriaTime_args(object):
    """
    Attributes:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyCriteriaTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyCriteriaTime_args)
sumKeyCriteriaTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class sumKeyCriteriaTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyCriteriaTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyCriteriaTime_result)
sumKeyCriteriaTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class sumKeyCriteriaTimestr_args(object):
    """
    Attributes:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyCriteriaTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyCriteriaTimestr_args)
sumKeyCriteriaTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class sumKeyCriteriaTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyCriteriaTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyCriteriaTimestr_result)
sumKeyCriteriaTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class sumKeyCcl_args(object):
    """
    Attributes:
     - key
     - ccl
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyCcl_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyCcl_args)
sumKeyCcl_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class sumKeyCcl_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyCcl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyCcl_result)
sumKeyCcl_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class sumKeyCclTime_args(object):
    """
    Attributes:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyCclTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyCclTime_args)
sumKeyCclTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class sumKeyCclTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyCclTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyCclTime_result)
sumKeyCclTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class sumKeyCclTimestr_args(object):
    """
    Attributes:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyCclTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyCclTimestr_args)
sumKeyCclTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class sumKeyCclTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sumKeyCclTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sumKeyCclTimestr_result)
sumKeyCclTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class averageKeyRecord_args(object):
    """
    Attributes:
     - key
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyRecord_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyRecord_args)
averageKeyRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class averageKeyRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyRecord_result)
averageKeyRecord_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class averageKeyRecordTime_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyRecordTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyRecordTime_args)
averageKeyRecordTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class averageKeyRecordTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyRecordTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyRecordTime_result)
averageKeyRecordTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class averageKeyRecordTimestr_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyRecordTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyRecordTimestr_args)
averageKeyRecordTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class averageKeyRecordTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyRecordTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyRecordTimestr_result)
averageKeyRecordTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class averageKeyRecords_args(object):
    """
    Attributes:
     - key
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2398, _size2395) = iprot.readListBegin()
                    for _i2399 in range(_size2395):
                        _elem2400 = iprot.readI64()
                        self.records.append(_elem2400)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyRecords_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2401 in self.records:
                oprot.writeI64(iter2401)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyRecords_args)
averageKeyRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class averageKeyRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyRecords_result)
averageKeyRecords_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class averageKeyRecordsTime_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2405, _size2402) = iprot.readListBegin()
                    for _i2406 in range(_size2402):
                        _elem2407 = iprot.readI64()
                        self.records.append(_elem2407)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyRecordsTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2408 in self.records:
                oprot.writeI64(iter2408)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyRecordsTime_args)
averageKeyRecordsTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class averageKeyRecordsTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyRecordsTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyRecordsTime_result)
averageKeyRecordsTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class averageKeyRecordsTimestr_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2412, _size2409) = iprot.readListBegin()
                    for _i2413 in range(_size2409):
                        _elem2414 = iprot.readI64()
                        self.records.append(_elem2414)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyRecordsTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2415 in self.records:
                oprot.writeI64(iter2415)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyRecordsTimestr_args)
averageKeyRecordsTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class averageKeyRecordsTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyRecordsTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyRecordsTimestr_result)
averageKeyRecordsTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class averageKey_args(object):
    """
    Attributes:
     - key
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKey_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKey_args)
averageKey_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class averageKey_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKey_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKey_result)
averageKey_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class averageKeyTime_args(object):
    """
    Attributes:
     - key
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyTime_args)
averageKeyTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class averageKeyTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyTime_result)
averageKeyTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class averageKeyTimestr_args(object):
    """
    Attributes:
     - key
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 2)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyTimestr_args)
averageKeyTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'timestamp', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class averageKeyTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyTimestr_result)
averageKeyTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class averageKeyCriteria_args(object):
    """
    Attributes:
     - key
     - criteria
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyCriteria_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyCriteria_args)
averageKeyCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class averageKeyCriteria_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyCriteria_result)
averageKeyCriteria_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class averageKeyCriteriaTime_args(object):
    """
    Attributes:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyCriteriaTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyCriteriaTime_args)
averageKeyCriteriaTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class averageKeyCriteriaTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyCriteriaTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyCriteriaTime_result)
averageKeyCriteriaTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class averageKeyCriteriaTimestr_args(object):
    """
    Attributes:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyCriteriaTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyCriteriaTimestr_args)
averageKeyCriteriaTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class averageKeyCriteriaTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyCriteriaTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyCriteriaTimestr_result)
averageKeyCriteriaTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class averageKeyCcl_args(object):
    """
    Attributes:
     - key
     - ccl
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyCcl_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyCcl_args)
averageKeyCcl_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class averageKeyCcl_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyCcl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyCcl_result)
averageKeyCcl_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class averageKeyCclTime_args(object):
    """
    Attributes:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyCclTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyCclTime_args)
averageKeyCclTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class averageKeyCclTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyCclTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyCclTime_result)
averageKeyCclTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class averageKeyCclTimestr_args(object):
    """
    Attributes:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyCclTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyCclTimestr_args)
averageKeyCclTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class averageKeyCclTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('averageKeyCclTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(averageKeyCclTimestr_result)
averageKeyCclTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class countKeyRecord_args(object):
    """
    Attributes:
     - key
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyRecord_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyRecord_args)
countKeyRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class countKeyRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyRecord_result)
countKeyRecord_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class countKeyRecordTime_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyRecordTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyRecordTime_args)
countKeyRecordTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class countKeyRecordTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyRecordTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyRecordTime_result)
countKeyRecordTime_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class countKeyRecordTimestr_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyRecordTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyRecordTimestr_args)
countKeyRecordTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class countKeyRecordTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyRecordTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyRecordTimestr_result)
countKeyRecordTimestr_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class countKeyRecords_args(object):
    """
    Attributes:
     - key
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2419, _size2416) = iprot.readListBegin()
                    for _i2420 in range(_size2416):
                        _elem2421 = iprot.readI64()
                        self.records.append(_elem2421)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyRecords_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2422 in self.records:
                oprot.writeI64(iter2422)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyRecords_args)
countKeyRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class countKeyRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyRecords_result)
countKeyRecords_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class countKeyRecordsTime_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2426, _size2423) = iprot.readListBegin()
                    for _i2427 in range(_size2423):
                        _elem2428 = iprot.readI64()
                        self.records.append(_elem2428)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyRecordsTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2429 in self.records:
                oprot.writeI64(iter2429)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyRecordsTime_args)
countKeyRecordsTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class countKeyRecordsTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyRecordsTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyRecordsTime_result)
countKeyRecordsTime_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class countKeyRecordsTimestr_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2433, _size2430) = iprot.readListBegin()
                    for _i2434 in range(_size2430):
                        _elem2435 = iprot.readI64()
                        self.records.append(_elem2435)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyRecordsTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2436 in self.records:
                oprot.writeI64(iter2436)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyRecordsTimestr_args)
countKeyRecordsTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class countKeyRecordsTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyRecordsTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyRecordsTimestr_result)
countKeyRecordsTimestr_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class countKey_args(object):
    """
    Attributes:
     - key
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKey_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKey_args)
countKey_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class countKey_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKey_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKey_result)
countKey_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class countKeyTime_args(object):
    """
    Attributes:
     - key
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyTime_args)
countKeyTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class countKeyTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyTime_result)
countKeyTime_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class countKeyTimestr_args(object):
    """
    Attributes:
     - key
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 2)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyTimestr_args)
countKeyTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'timestamp', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class countKeyTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyTimestr_result)
countKeyTimestr_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class countKeyCriteria_args(object):
    """
    Attributes:
     - key
     - criteria
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyCriteria_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyCriteria_args)
countKeyCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class countKeyCriteria_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyCriteria_result)
countKeyCriteria_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class countKeyCriteriaTime_args(object):
    """
    Attributes:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyCriteriaTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyCriteriaTime_args)
countKeyCriteriaTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class countKeyCriteriaTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyCriteriaTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyCriteriaTime_result)
countKeyCriteriaTime_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class countKeyCriteriaTimestr_args(object):
    """
    Attributes:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyCriteriaTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyCriteriaTimestr_args)
countKeyCriteriaTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class countKeyCriteriaTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyCriteriaTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyCriteriaTimestr_result)
countKeyCriteriaTimestr_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class countKeyCcl_args(object):
    """
    Attributes:
     - key
     - ccl
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyCcl_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyCcl_args)
countKeyCcl_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class countKeyCcl_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyCcl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyCcl_result)
countKeyCcl_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class countKeyCclTime_args(object):
    """
    Attributes:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyCclTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyCclTime_args)
countKeyCclTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class countKeyCclTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyCclTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyCclTime_result)
countKeyCclTime_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class countKeyCclTimestr_args(object):
    """
    Attributes:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyCclTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyCclTimestr_args)
countKeyCclTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class countKeyCclTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('countKeyCclTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(countKeyCclTimestr_result)
countKeyCclTimestr_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class maxKeyRecord_args(object):
    """
    Attributes:
     - key
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyRecord_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyRecord_args)
maxKeyRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class maxKeyRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyRecord_result)
maxKeyRecord_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class maxKeyRecordTime_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyRecordTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyRecordTime_args)
maxKeyRecordTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class maxKeyRecordTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyRecordTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyRecordTime_result)
maxKeyRecordTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class maxKeyRecordTimestr_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyRecordTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyRecordTimestr_args)
maxKeyRecordTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class maxKeyRecordTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyRecordTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyRecordTimestr_result)
maxKeyRecordTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class maxKeyRecords_args(object):
    """
    Attributes:
     - key
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2440, _size2437) = iprot.readListBegin()
                    for _i2441 in range(_size2437):
                        _elem2442 = iprot.readI64()
                        self.records.append(_elem2442)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyRecords_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2443 in self.records:
                oprot.writeI64(iter2443)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyRecords_args)
maxKeyRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class maxKeyRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyRecords_result)
maxKeyRecords_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class maxKeyRecordsTime_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2447, _size2444) = iprot.readListBegin()
                    for _i2448 in range(_size2444):
                        _elem2449 = iprot.readI64()
                        self.records.append(_elem2449)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyRecordsTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2450 in self.records:
                oprot.writeI64(iter2450)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyRecordsTime_args)
maxKeyRecordsTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class maxKeyRecordsTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyRecordsTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyRecordsTime_result)
maxKeyRecordsTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class maxKeyRecordsTimestr_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2454, _size2451) = iprot.readListBegin()
                    for _i2455 in range(_size2451):
                        _elem2456 = iprot.readI64()
                        self.records.append(_elem2456)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyRecordsTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2457 in self.records:
                oprot.writeI64(iter2457)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyRecordsTimestr_args)
maxKeyRecordsTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class maxKeyRecordsTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyRecordsTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyRecordsTimestr_result)
maxKeyRecordsTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class maxKeyCriteria_args(object):
    """
    Attributes:
     - key
     - criteria
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyCriteria_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyCriteria_args)
maxKeyCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class maxKeyCriteria_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyCriteria_result)
maxKeyCriteria_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class maxKeyCriteriaTime_args(object):
    """
    Attributes:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyCriteriaTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyCriteriaTime_args)
maxKeyCriteriaTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class maxKeyCriteriaTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyCriteriaTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyCriteriaTime_result)
maxKeyCriteriaTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class maxKeyCriteriaTimestr_args(object):
    """
    Attributes:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyCriteriaTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyCriteriaTimestr_args)
maxKeyCriteriaTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class maxKeyCriteriaTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyCriteriaTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyCriteriaTimestr_result)
maxKeyCriteriaTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class maxKeyCcl_args(object):
    """
    Attributes:
     - key
     - ccl
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyCcl_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyCcl_args)
maxKeyCcl_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class maxKeyCcl_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyCcl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyCcl_result)
maxKeyCcl_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class maxKeyCclTime_args(object):
    """
    Attributes:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyCclTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyCclTime_args)
maxKeyCclTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class maxKeyCclTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyCclTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyCclTime_result)
maxKeyCclTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class maxKeyCclTimestr_args(object):
    """
    Attributes:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyCclTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyCclTimestr_args)
maxKeyCclTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class maxKeyCclTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyCclTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyCclTimestr_result)
maxKeyCclTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class maxKey_args(object):
    """
    Attributes:
     - key
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKey_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKey_args)
maxKey_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class maxKey_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKey_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKey_result)
maxKey_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class maxKeyTime_args(object):
    """
    Attributes:
     - key
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyTime_args)
maxKeyTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class maxKeyTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyTime_result)
maxKeyTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class maxKeyTimestr_args(object):
    """
    Attributes:
     - key
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 2)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyTimestr_args)
maxKeyTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'timestamp', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class maxKeyTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('maxKeyTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(maxKeyTimestr_result)
maxKeyTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class minKeyRecord_args(object):
    """
    Attributes:
     - key
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyRecord_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyRecord_args)
minKeyRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class minKeyRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyRecord_result)
minKeyRecord_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class minKeyRecordTime_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyRecordTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyRecordTime_args)
minKeyRecordTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class minKeyRecordTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyRecordTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyRecordTime_result)
minKeyRecordTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class minKeyRecordTimestr_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyRecordTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyRecordTimestr_args)
minKeyRecordTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class minKeyRecordTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyRecordTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyRecordTimestr_result)
minKeyRecordTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class minKey_args(object):
    """
    Attributes:
     - key
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKey_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKey_args)
minKey_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class minKey_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKey_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKey_result)
minKey_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class minKeyRecordsTime_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2461, _size2458) = iprot.readListBegin()
                    for _i2462 in range(_size2458):
                        _elem2463 = iprot.readI64()
                        self.records.append(_elem2463)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyRecordsTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2464 in self.records:
                oprot.writeI64(iter2464)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyRecordsTime_args)
minKeyRecordsTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class minKeyRecordsTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyRecordsTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyRecordsTime_result)
minKeyRecordsTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class minKeyRecordsTimestr_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2468, _size2465) = iprot.readListBegin()
                    for _i2469 in range(_size2465):
                        _elem2470 = iprot.readI64()
                        self.records.append(_elem2470)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyRecordsTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2471 in self.records:
                oprot.writeI64(iter2471)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyRecordsTimestr_args)
minKeyRecordsTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class minKeyRecordsTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyRecordsTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyRecordsTimestr_result)
minKeyRecordsTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class minKeyCriteria_args(object):
    """
    Attributes:
     - key
     - criteria
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyCriteria_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyCriteria_args)
minKeyCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class minKeyCriteria_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyCriteria_result)
minKeyCriteria_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class minKeyCriteriaTime_args(object):
    """
    Attributes:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyCriteriaTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyCriteriaTime_args)
minKeyCriteriaTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class minKeyCriteriaTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyCriteriaTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyCriteriaTime_result)
minKeyCriteriaTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class minKeyCriteriaTimestr_args(object):
    """
    Attributes:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyCriteriaTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyCriteriaTimestr_args)
minKeyCriteriaTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class minKeyCriteriaTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyCriteriaTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyCriteriaTimestr_result)
minKeyCriteriaTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class minKeyCcl_args(object):
    """
    Attributes:
     - key
     - ccl
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyCcl_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyCcl_args)
minKeyCcl_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class minKeyCcl_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyCcl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyCcl_result)
minKeyCcl_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class minKeyCclTime_args(object):
    """
    Attributes:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyCclTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyCclTime_args)
minKeyCclTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class minKeyCclTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyCclTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyCclTime_result)
minKeyCclTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class minKeyCclTimestr_args(object):
    """
    Attributes:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyCclTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyCclTimestr_args)
minKeyCclTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class minKeyCclTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyCclTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyCclTimestr_result)
minKeyCclTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class minKeyTime_args(object):
    """
    Attributes:
     - key
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyTime_args)
minKeyTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class minKeyTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyTime_result)
minKeyTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class minKeyTimestr_args(object):
    """
    Attributes:
     - key
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 2)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyTimestr_args)
minKeyTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'timestamp', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class minKeyTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyTimestr_result)
minKeyTimestr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class minKeyRecords_args(object):
    """
    Attributes:
     - key
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2475, _size2472) = iprot.readListBegin()
                    for _i2476 in range(_size2472):
                        _elem2477 = iprot.readI64()
                        self.records.append(_elem2477)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyRecords_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2478 in self.records:
                oprot.writeI64(iter2478)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyRecords_args)
minKeyRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class minKeyRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('minKeyRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(minKeyRecords_result)
minKeyRecords_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class navigateKeyRecord_args(object):
    """
    Attributes:
     - key
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyRecord_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyRecord_args)
navigateKeyRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class navigateKeyRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2480, _vtype2481, _size2479) = iprot.readMapBegin()
                    for _i2483 in range(_size2479):
                        _key2484 = iprot.readI64()
                        _val2485 = []
                        (_etype2489, _size2486) = iprot.readSetBegin()
                        for _i2490 in range(_size2486):
                            _elem2491 = TObject()
                            _elem2491.read(iprot)
                            _val2485.append(_elem2491)
                        iprot.readSetEnd()
                        self.success[_key2484] = _val2485
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter2492, viter2493 in list(self.success.items()):
                oprot.writeI64(kiter2492)
                oprot.writeSetBegin(TType.STRUCT, len(viter2493))
                for iter2494 in viter2493:
                    iter2494.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyRecord_result)
navigateKeyRecord_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class navigateKeyRecordTime_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyRecordTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyRecordTime_args)
navigateKeyRecordTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class navigateKeyRecordTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2496, _vtype2497, _size2495) = iprot.readMapBegin()
                    for _i2499 in range(_size2495):
                        _key2500 = iprot.readI64()
                        _val2501 = []
                        (_etype2505, _size2502) = iprot.readSetBegin()
                        for _i2506 in range(_size2502):
                            _elem2507 = TObject()
                            _elem2507.read(iprot)
                            _val2501.append(_elem2507)
                        iprot.readSetEnd()
                        self.success[_key2500] = _val2501
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyRecordTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter2508, viter2509 in list(self.success.items()):
                oprot.writeI64(kiter2508)
                oprot.writeSetBegin(TType.STRUCT, len(viter2509))
                for iter2510 in viter2509:
                    iter2510.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyRecordTime_result)
navigateKeyRecordTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class navigateKeyRecordTimestr_args(object):
    """
    Attributes:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyRecordTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyRecordTimestr_args)
navigateKeyRecordTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class navigateKeyRecordTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2512, _vtype2513, _size2511) = iprot.readMapBegin()
                    for _i2515 in range(_size2511):
                        _key2516 = iprot.readI64()
                        _val2517 = []
                        (_etype2521, _size2518) = iprot.readSetBegin()
                        for _i2522 in range(_size2518):
                            _elem2523 = TObject()
                            _elem2523.read(iprot)
                            _val2517.append(_elem2523)
                        iprot.readSetEnd()
                        self.success[_key2516] = _val2517
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyRecordTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter2524, viter2525 in list(self.success.items()):
                oprot.writeI64(kiter2524)
                oprot.writeSetBegin(TType.STRUCT, len(viter2525))
                for iter2526 in viter2525:
                    iter2526.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyRecordTimestr_result)
navigateKeyRecordTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class navigateKeysRecord_args(object):
    """
    Attributes:
     - keys
     - record
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, record=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.record = record
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2530, _size2527) = iprot.readListBegin()
                    for _i2531 in range(_size2527):
                        _elem2532 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2532)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysRecord_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2533 in self.keys:
                oprot.writeString(iter2533.encode('utf-8') if sys.version_info[0] == 2 else iter2533)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysRecord_args)
navigateKeysRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class navigateKeysRecord_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2535, _vtype2536, _size2534) = iprot.readMapBegin()
                    for _i2538 in range(_size2534):
                        _key2539 = iprot.readI64()
                        _val2540 = {}
                        (_ktype2542, _vtype2543, _size2541) = iprot.readMapBegin()
                        for _i2545 in range(_size2541):
                            _key2546 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val2547 = []
                            (_etype2551, _size2548) = iprot.readSetBegin()
                            for _i2552 in range(_size2548):
                                _elem2553 = TObject()
                                _elem2553.read(iprot)
                                _val2547.append(_elem2553)
                            iprot.readSetEnd()
                            _val2540[_key2546] = _val2547
                        iprot.readMapEnd()
                        self.success[_key2539] = _val2540
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter2554, viter2555 in list(self.success.items()):
                oprot.writeI64(kiter2554)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2555))
                for kiter2556, viter2557 in list(viter2555.items()):
                    oprot.writeString(kiter2556.encode('utf-8') if sys.version_info[0] == 2 else kiter2556)
                    oprot.writeSetBegin(TType.STRUCT, len(viter2557))
                    for iter2558 in viter2557:
                        iter2558.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysRecord_result)
navigateKeysRecord_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class navigateKeysRecordTime_args(object):
    """
    Attributes:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2562, _size2559) = iprot.readListBegin()
                    for _i2563 in range(_size2559):
                        _elem2564 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2564)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysRecordTime_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2565 in self.keys:
                oprot.writeString(iter2565.encode('utf-8') if sys.version_info[0] == 2 else iter2565)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysRecordTime_args)
navigateKeysRecordTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class navigateKeysRecordTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2567, _vtype2568, _size2566) = iprot.readMapBegin()
                    for _i2570 in range(_size2566):
                        _key2571 = iprot.readI64()
                        _val2572 = {}
                        (_ktype2574, _vtype2575, _size2573) = iprot.readMapBegin()
                        for _i2577 in range(_size2573):
                            _key2578 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val2579 = []
                            (_etype2583, _size2580) = iprot.readSetBegin()
                            for _i2584 in range(_size2580):
                                _elem2585 = TObject()
                                _elem2585.read(iprot)
                                _val2579.append(_elem2585)
                            iprot.readSetEnd()
                            _val2572[_key2578] = _val2579
                        iprot.readMapEnd()
                        self.success[_key2571] = _val2572
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysRecordTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter2586, viter2587 in list(self.success.items()):
                oprot.writeI64(kiter2586)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2587))
                for kiter2588, viter2589 in list(viter2587.items()):
                    oprot.writeString(kiter2588.encode('utf-8') if sys.version_info[0] == 2 else kiter2588)
                    oprot.writeSetBegin(TType.STRUCT, len(viter2589))
                    for iter2590 in viter2589:
                        iter2590.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysRecordTime_result)
navigateKeysRecordTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class navigateKeysRecordTimestr_args(object):
    """
    Attributes:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.record = record
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2594, _size2591) = iprot.readListBegin()
                    for _i2595 in range(_size2591):
                        _elem2596 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2596)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.record = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysRecordTimestr_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2597 in self.keys:
                oprot.writeString(iter2597.encode('utf-8') if sys.version_info[0] == 2 else iter2597)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.I64, 2)
            oprot.writeI64(self.record)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysRecordTimestr_args)
navigateKeysRecordTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I64, 'record', None, None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class navigateKeysRecordTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2599, _vtype2600, _size2598) = iprot.readMapBegin()
                    for _i2602 in range(_size2598):
                        _key2603 = iprot.readI64()
                        _val2604 = {}
                        (_ktype2606, _vtype2607, _size2605) = iprot.readMapBegin()
                        for _i2609 in range(_size2605):
                            _key2610 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val2611 = []
                            (_etype2615, _size2612) = iprot.readSetBegin()
                            for _i2616 in range(_size2612):
                                _elem2617 = TObject()
                                _elem2617.read(iprot)
                                _val2611.append(_elem2617)
                            iprot.readSetEnd()
                            _val2604[_key2610] = _val2611
                        iprot.readMapEnd()
                        self.success[_key2603] = _val2604
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysRecordTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter2618, viter2619 in list(self.success.items()):
                oprot.writeI64(kiter2618)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2619))
                for kiter2620, viter2621 in list(viter2619.items()):
                    oprot.writeString(kiter2620.encode('utf-8') if sys.version_info[0] == 2 else kiter2620)
                    oprot.writeSetBegin(TType.STRUCT, len(viter2621))
                    for iter2622 in viter2621:
                        iter2622.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysRecordTimestr_result)
navigateKeysRecordTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class navigateKeysRecords_args(object):
    """
    Attributes:
     - keys
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, records=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2626, _size2623) = iprot.readListBegin()
                    for _i2627 in range(_size2623):
                        _elem2628 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2628)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2632, _size2629) = iprot.readListBegin()
                    for _i2633 in range(_size2629):
                        _elem2634 = iprot.readI64()
                        self.records.append(_elem2634)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysRecords_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2635 in self.keys:
                oprot.writeString(iter2635.encode('utf-8') if sys.version_info[0] == 2 else iter2635)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2636 in self.records:
                oprot.writeI64(iter2636)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysRecords_args)
navigateKeysRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class navigateKeysRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2638, _vtype2639, _size2637) = iprot.readMapBegin()
                    for _i2641 in range(_size2637):
                        _key2642 = iprot.readI64()
                        _val2643 = {}
                        (_ktype2645, _vtype2646, _size2644) = iprot.readMapBegin()
                        for _i2648 in range(_size2644):
                            _key2649 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val2650 = []
                            (_etype2654, _size2651) = iprot.readSetBegin()
                            for _i2655 in range(_size2651):
                                _elem2656 = TObject()
                                _elem2656.read(iprot)
                                _val2650.append(_elem2656)
                            iprot.readSetEnd()
                            _val2643[_key2649] = _val2650
                        iprot.readMapEnd()
                        self.success[_key2642] = _val2643
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter2657, viter2658 in list(self.success.items()):
                oprot.writeI64(kiter2657)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2658))
                for kiter2659, viter2660 in list(viter2658.items()):
                    oprot.writeString(kiter2659.encode('utf-8') if sys.version_info[0] == 2 else kiter2659)
                    oprot.writeSetBegin(TType.STRUCT, len(viter2660))
                    for iter2661 in viter2660:
                        iter2661.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysRecords_result)
navigateKeysRecords_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class navigateKeyRecords_args(object):
    """
    Attributes:
     - key
     - records
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2665, _size2662) = iprot.readListBegin()
                    for _i2666 in range(_size2662):
                        _elem2667 = iprot.readI64()
                        self.records.append(_elem2667)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyRecords_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2668 in self.records:
                oprot.writeI64(iter2668)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyRecords_args)
navigateKeyRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class navigateKeyRecords_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2670, _vtype2671, _size2669) = iprot.readMapBegin()
                    for _i2673 in range(_size2669):
                        _key2674 = iprot.readI64()
                        _val2675 = []
                        (_etype2679, _size2676) = iprot.readSetBegin()
                        for _i2680 in range(_size2676):
                            _elem2681 = TObject()
                            _elem2681.read(iprot)
                            _val2675.append(_elem2681)
                        iprot.readSetEnd()
                        self.success[_key2674] = _val2675
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter2682, viter2683 in list(self.success.items()):
                oprot.writeI64(kiter2682)
                oprot.writeSetBegin(TType.STRUCT, len(viter2683))
                for iter2684 in viter2683:
                    iter2684.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyRecords_result)
navigateKeyRecords_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class navigateKeyRecordsTime_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2688, _size2685) = iprot.readListBegin()
                    for _i2689 in range(_size2685):
                        _elem2690 = iprot.readI64()
                        self.records.append(_elem2690)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyRecordsTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2691 in self.records:
                oprot.writeI64(iter2691)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyRecordsTime_args)
navigateKeyRecordsTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class navigateKeyRecordsTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2693, _vtype2694, _size2692) = iprot.readMapBegin()
                    for _i2696 in range(_size2692):
                        _key2697 = iprot.readI64()
                        _val2698 = []
                        (_etype2702, _size2699) = iprot.readSetBegin()
                        for _i2703 in range(_size2699):
                            _elem2704 = TObject()
                            _elem2704.read(iprot)
                            _val2698.append(_elem2704)
                        iprot.readSetEnd()
                        self.success[_key2697] = _val2698
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyRecordsTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter2705, viter2706 in list(self.success.items()):
                oprot.writeI64(kiter2705)
                oprot.writeSetBegin(TType.STRUCT, len(viter2706))
                for iter2707 in viter2706:
                    iter2707.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyRecordsTime_result)
navigateKeyRecordsTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class navigateKeyRecordsTimestr_args(object):
    """
    Attributes:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2711, _size2708) = iprot.readListBegin()
                    for _i2712 in range(_size2708):
                        _elem2713 = iprot.readI64()
                        self.records.append(_elem2713)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyRecordsTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2714 in self.records:
                oprot.writeI64(iter2714)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyRecordsTimestr_args)
navigateKeyRecordsTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class navigateKeyRecordsTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2716, _vtype2717, _size2715) = iprot.readMapBegin()
                    for _i2719 in range(_size2715):
                        _key2720 = iprot.readI64()
                        _val2721 = []
                        (_etype2725, _size2722) = iprot.readSetBegin()
                        for _i2726 in range(_size2722):
                            _elem2727 = TObject()
                            _elem2727.read(iprot)
                            _val2721.append(_elem2727)
                        iprot.readSetEnd()
                        self.success[_key2720] = _val2721
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyRecordsTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter2728, viter2729 in list(self.success.items()):
                oprot.writeI64(kiter2728)
                oprot.writeSetBegin(TType.STRUCT, len(viter2729))
                for iter2730 in viter2729:
                    iter2730.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyRecordsTimestr_result)
navigateKeyRecordsTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class navigateKeysRecordsTime_args(object):
    """
    Attributes:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2734, _size2731) = iprot.readListBegin()
                    for _i2735 in range(_size2731):
                        _elem2736 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2736)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2740, _size2737) = iprot.readListBegin()
                    for _i2741 in range(_size2737):
                        _elem2742 = iprot.readI64()
                        self.records.append(_elem2742)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysRecordsTime_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2743 in self.keys:
                oprot.writeString(iter2743.encode('utf-8') if sys.version_info[0] == 2 else iter2743)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2744 in self.records:
                oprot.writeI64(iter2744)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysRecordsTime_args)
navigateKeysRecordsTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class navigateKeysRecordsTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2746, _vtype2747, _size2745) = iprot.readMapBegin()
                    for _i2749 in range(_size2745):
                        _key2750 = iprot.readI64()
                        _val2751 = {}
                        (_ktype2753, _vtype2754, _size2752) = iprot.readMapBegin()
                        for _i2756 in range(_size2752):
                            _key2757 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val2758 = []
                            (_etype2762, _size2759) = iprot.readSetBegin()
                            for _i2763 in range(_size2759):
                                _elem2764 = TObject()
                                _elem2764.read(iprot)
                                _val2758.append(_elem2764)
                            iprot.readSetEnd()
                            _val2751[_key2757] = _val2758
                        iprot.readMapEnd()
                        self.success[_key2750] = _val2751
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysRecordsTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter2765, viter2766 in list(self.success.items()):
                oprot.writeI64(kiter2765)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2766))
                for kiter2767, viter2768 in list(viter2766.items()):
                    oprot.writeString(kiter2767.encode('utf-8') if sys.version_info[0] == 2 else kiter2767)
                    oprot.writeSetBegin(TType.STRUCT, len(viter2768))
                    for iter2769 in viter2768:
                        iter2769.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysRecordsTime_result)
navigateKeysRecordsTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class navigateKeysRecordsTimestr_args(object):
    """
    Attributes:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.records = records
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2773, _size2770) = iprot.readListBegin()
                    for _i2774 in range(_size2770):
                        _elem2775 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2775)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype2779, _size2776) = iprot.readListBegin()
                    for _i2780 in range(_size2776):
                        _elem2781 = iprot.readI64()
                        self.records.append(_elem2781)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysRecordsTimestr_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2782 in self.keys:
                oprot.writeString(iter2782.encode('utf-8') if sys.version_info[0] == 2 else iter2782)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.records))
            for iter2783 in self.records:
                oprot.writeI64(iter2783)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysRecordsTimestr_args)
navigateKeysRecordsTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'records', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class navigateKeysRecordsTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2785, _vtype2786, _size2784) = iprot.readMapBegin()
                    for _i2788 in range(_size2784):
                        _key2789 = iprot.readI64()
                        _val2790 = {}
                        (_ktype2792, _vtype2793, _size2791) = iprot.readMapBegin()
                        for _i2795 in range(_size2791):
                            _key2796 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val2797 = []
                            (_etype2801, _size2798) = iprot.readSetBegin()
                            for _i2802 in range(_size2798):
                                _elem2803 = TObject()
                                _elem2803.read(iprot)
                                _val2797.append(_elem2803)
                            iprot.readSetEnd()
                            _val2790[_key2796] = _val2797
                        iprot.readMapEnd()
                        self.success[_key2789] = _val2790
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysRecordsTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter2804, viter2805 in list(self.success.items()):
                oprot.writeI64(kiter2804)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2805))
                for kiter2806, viter2807 in list(viter2805.items()):
                    oprot.writeString(kiter2806.encode('utf-8') if sys.version_info[0] == 2 else kiter2806)
                    oprot.writeSetBegin(TType.STRUCT, len(viter2807))
                    for iter2808 in viter2807:
                        iter2808.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysRecordsTimestr_result)
navigateKeysRecordsTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class navigateKeyCcl_args(object):
    """
    Attributes:
     - key
     - ccl
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyCcl_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyCcl_args)
navigateKeyCcl_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class navigateKeyCcl_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2810, _vtype2811, _size2809) = iprot.readMapBegin()
                    for _i2813 in range(_size2809):
                        _key2814 = iprot.readI64()
                        _val2815 = []
                        (_etype2819, _size2816) = iprot.readSetBegin()
                        for _i2820 in range(_size2816):
                            _elem2821 = TObject()
                            _elem2821.read(iprot)
                            _val2815.append(_elem2821)
                        iprot.readSetEnd()
                        self.success[_key2814] = _val2815
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyCcl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter2822, viter2823 in list(self.success.items()):
                oprot.writeI64(kiter2822)
                oprot.writeSetBegin(TType.STRUCT, len(viter2823))
                for iter2824 in viter2823:
                    iter2824.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyCcl_result)
navigateKeyCcl_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class navigateKeyCclTime_args(object):
    """
    Attributes:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyCclTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyCclTime_args)
navigateKeyCclTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class navigateKeyCclTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2826, _vtype2827, _size2825) = iprot.readMapBegin()
                    for _i2829 in range(_size2825):
                        _key2830 = iprot.readI64()
                        _val2831 = []
                        (_etype2835, _size2832) = iprot.readSetBegin()
                        for _i2836 in range(_size2832):
                            _elem2837 = TObject()
                            _elem2837.read(iprot)
                            _val2831.append(_elem2837)
                        iprot.readSetEnd()
                        self.success[_key2830] = _val2831
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyCclTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter2838, viter2839 in list(self.success.items()):
                oprot.writeI64(kiter2838)
                oprot.writeSetBegin(TType.STRUCT, len(viter2839))
                for iter2840 in viter2839:
                    iter2840.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyCclTime_result)
navigateKeyCclTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class navigateKeyCclTimestr_args(object):
    """
    Attributes:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyCclTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyCclTimestr_args)
navigateKeyCclTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class navigateKeyCclTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2842, _vtype2843, _size2841) = iprot.readMapBegin()
                    for _i2845 in range(_size2841):
                        _key2846 = iprot.readI64()
                        _val2847 = []
                        (_etype2851, _size2848) = iprot.readSetBegin()
                        for _i2852 in range(_size2848):
                            _elem2853 = TObject()
                            _elem2853.read(iprot)
                            _val2847.append(_elem2853)
                        iprot.readSetEnd()
                        self.success[_key2846] = _val2847
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyCclTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter2854, viter2855 in list(self.success.items()):
                oprot.writeI64(kiter2854)
                oprot.writeSetBegin(TType.STRUCT, len(viter2855))
                for iter2856 in viter2855:
                    iter2856.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyCclTimestr_result)
navigateKeyCclTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class navigateKeysCcl_args(object):
    """
    Attributes:
     - keys
     - ccl
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, ccl=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.ccl = ccl
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2860, _size2857) = iprot.readListBegin()
                    for _i2861 in range(_size2857):
                        _elem2862 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2862)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysCcl_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2863 in self.keys:
                oprot.writeString(iter2863.encode('utf-8') if sys.version_info[0] == 2 else iter2863)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysCcl_args)
navigateKeysCcl_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class navigateKeysCcl_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2865, _vtype2866, _size2864) = iprot.readMapBegin()
                    for _i2868 in range(_size2864):
                        _key2869 = iprot.readI64()
                        _val2870 = {}
                        (_ktype2872, _vtype2873, _size2871) = iprot.readMapBegin()
                        for _i2875 in range(_size2871):
                            _key2876 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val2877 = []
                            (_etype2881, _size2878) = iprot.readSetBegin()
                            for _i2882 in range(_size2878):
                                _elem2883 = TObject()
                                _elem2883.read(iprot)
                                _val2877.append(_elem2883)
                            iprot.readSetEnd()
                            _val2870[_key2876] = _val2877
                        iprot.readMapEnd()
                        self.success[_key2869] = _val2870
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysCcl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter2884, viter2885 in list(self.success.items()):
                oprot.writeI64(kiter2884)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2885))
                for kiter2886, viter2887 in list(viter2885.items()):
                    oprot.writeString(kiter2886.encode('utf-8') if sys.version_info[0] == 2 else kiter2886)
                    oprot.writeSetBegin(TType.STRUCT, len(viter2887))
                    for iter2888 in viter2887:
                        iter2888.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysCcl_result)
navigateKeysCcl_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class navigateKeysCclTime_args(object):
    """
    Attributes:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2892, _size2889) = iprot.readListBegin()
                    for _i2893 in range(_size2889):
                        _elem2894 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2894)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysCclTime_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2895 in self.keys:
                oprot.writeString(iter2895.encode('utf-8') if sys.version_info[0] == 2 else iter2895)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysCclTime_args)
navigateKeysCclTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class navigateKeysCclTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2897, _vtype2898, _size2896) = iprot.readMapBegin()
                    for _i2900 in range(_size2896):
                        _key2901 = iprot.readI64()
                        _val2902 = {}
                        (_ktype2904, _vtype2905, _size2903) = iprot.readMapBegin()
                        for _i2907 in range(_size2903):
                            _key2908 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val2909 = []
                            (_etype2913, _size2910) = iprot.readSetBegin()
                            for _i2914 in range(_size2910):
                                _elem2915 = TObject()
                                _elem2915.read(iprot)
                                _val2909.append(_elem2915)
                            iprot.readSetEnd()
                            _val2902[_key2908] = _val2909
                        iprot.readMapEnd()
                        self.success[_key2901] = _val2902
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysCclTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter2916, viter2917 in list(self.success.items()):
                oprot.writeI64(kiter2916)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2917))
                for kiter2918, viter2919 in list(viter2917.items()):
                    oprot.writeString(kiter2918.encode('utf-8') if sys.version_info[0] == 2 else kiter2918)
                    oprot.writeSetBegin(TType.STRUCT, len(viter2919))
                    for iter2920 in viter2919:
                        iter2920.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysCclTime_result)
navigateKeysCclTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class navigateKeysCclTimestr_args(object):
    """
    Attributes:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.ccl = ccl
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype2924, _size2921) = iprot.readListBegin()
                    for _i2925 in range(_size2921):
                        _elem2926 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem2926)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ccl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysCclTimestr_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter2927 in self.keys:
                oprot.writeString(iter2927.encode('utf-8') if sys.version_info[0] == 2 else iter2927)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ccl is not None:
            oprot.writeFieldBegin('ccl', TType.STRING, 2)
            oprot.writeString(self.ccl.encode('utf-8') if sys.version_info[0] == 2 else self.ccl)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysCclTimestr_args)
navigateKeysCclTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'ccl', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class navigateKeysCclTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2929, _vtype2930, _size2928) = iprot.readMapBegin()
                    for _i2932 in range(_size2928):
                        _key2933 = iprot.readI64()
                        _val2934 = {}
                        (_ktype2936, _vtype2937, _size2935) = iprot.readMapBegin()
                        for _i2939 in range(_size2935):
                            _key2940 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val2941 = []
                            (_etype2945, _size2942) = iprot.readSetBegin()
                            for _i2946 in range(_size2942):
                                _elem2947 = TObject()
                                _elem2947.read(iprot)
                                _val2941.append(_elem2947)
                            iprot.readSetEnd()
                            _val2934[_key2940] = _val2941
                        iprot.readMapEnd()
                        self.success[_key2933] = _val2934
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysCclTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter2948, viter2949 in list(self.success.items()):
                oprot.writeI64(kiter2948)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2949))
                for kiter2950, viter2951 in list(viter2949.items()):
                    oprot.writeString(kiter2950.encode('utf-8') if sys.version_info[0] == 2 else kiter2950)
                    oprot.writeSetBegin(TType.STRUCT, len(viter2951))
                    for iter2952 in viter2951:
                        iter2952.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysCclTimestr_result)
navigateKeysCclTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class navigateKeyCriteria_args(object):
    """
    Attributes:
     - key
     - criteria
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyCriteria_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyCriteria_args)
navigateKeyCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class navigateKeyCriteria_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2954, _vtype2955, _size2953) = iprot.readMapBegin()
                    for _i2957 in range(_size2953):
                        _key2958 = iprot.readI64()
                        _val2959 = []
                        (_etype2963, _size2960) = iprot.readSetBegin()
                        for _i2964 in range(_size2960):
                            _elem2965 = TObject()
                            _elem2965.read(iprot)
                            _val2959.append(_elem2965)
                        iprot.readSetEnd()
                        self.success[_key2958] = _val2959
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter2966, viter2967 in list(self.success.items()):
                oprot.writeI64(kiter2966)
                oprot.writeSetBegin(TType.STRUCT, len(viter2967))
                for iter2968 in viter2967:
                    iter2968.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyCriteria_result)
navigateKeyCriteria_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class navigateKeyCriteriaTime_args(object):
    """
    Attributes:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyCriteriaTime_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyCriteriaTime_args)
navigateKeyCriteriaTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class navigateKeyCriteriaTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2970, _vtype2971, _size2969) = iprot.readMapBegin()
                    for _i2973 in range(_size2969):
                        _key2974 = iprot.readI64()
                        _val2975 = []
                        (_etype2979, _size2976) = iprot.readSetBegin()
                        for _i2980 in range(_size2976):
                            _elem2981 = TObject()
                            _elem2981.read(iprot)
                            _val2975.append(_elem2981)
                        iprot.readSetEnd()
                        self.success[_key2974] = _val2975
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyCriteriaTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter2982, viter2983 in list(self.success.items()):
                oprot.writeI64(kiter2982)
                oprot.writeSetBegin(TType.STRUCT, len(viter2983))
                for iter2984 in viter2983:
                    iter2984.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyCriteriaTime_result)
navigateKeyCriteriaTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class navigateKeyCriteriaTimestr_args(object):
    """
    Attributes:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.key = key
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyCriteriaTimestr_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyCriteriaTimestr_args)
navigateKeyCriteriaTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class navigateKeyCriteriaTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype2986, _vtype2987, _size2985) = iprot.readMapBegin()
                    for _i2989 in range(_size2985):
                        _key2990 = iprot.readI64()
                        _val2991 = []
                        (_etype2995, _size2992) = iprot.readSetBegin()
                        for _i2996 in range(_size2992):
                            _elem2997 = TObject()
                            _elem2997.read(iprot)
                            _val2991.append(_elem2997)
                        iprot.readSetEnd()
                        self.success[_key2990] = _val2991
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeyCriteriaTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
            for kiter2998, viter2999 in list(self.success.items()):
                oprot.writeI64(kiter2998)
                oprot.writeSetBegin(TType.STRUCT, len(viter2999))
                for iter3000 in viter2999:
                    iter3000.write(oprot)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeyCriteriaTimestr_result)
navigateKeyCriteriaTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.SET, (TType.STRUCT, [TObject, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class navigateKeysCriteria_args(object):
    """
    Attributes:
     - keys
     - criteria
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, criteria=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.criteria = criteria
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype3004, _size3001) = iprot.readListBegin()
                    for _i3005 in range(_size3001):
                        _elem3006 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem3006)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysCriteria_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter3007 in self.keys:
                oprot.writeString(iter3007.encode('utf-8') if sys.version_info[0] == 2 else iter3007)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 3)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 5)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysCriteria_args)
navigateKeysCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 3
    (4, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 4
    (5, TType.STRING, 'environment', 'UTF8', None, ),  # 5
)


class navigateKeysCriteria_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype3009, _vtype3010, _size3008) = iprot.readMapBegin()
                    for _i3012 in range(_size3008):
                        _key3013 = iprot.readI64()
                        _val3014 = {}
                        (_ktype3016, _vtype3017, _size3015) = iprot.readMapBegin()
                        for _i3019 in range(_size3015):
                            _key3020 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val3021 = []
                            (_etype3025, _size3022) = iprot.readSetBegin()
                            for _i3026 in range(_size3022):
                                _elem3027 = TObject()
                                _elem3027.read(iprot)
                                _val3021.append(_elem3027)
                            iprot.readSetEnd()
                            _val3014[_key3020] = _val3021
                        iprot.readMapEnd()
                        self.success[_key3013] = _val3014
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter3028, viter3029 in list(self.success.items()):
                oprot.writeI64(kiter3028)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter3029))
                for kiter3030, viter3031 in list(viter3029.items()):
                    oprot.writeString(kiter3030.encode('utf-8') if sys.version_info[0] == 2 else kiter3030)
                    oprot.writeSetBegin(TType.STRUCT, len(viter3031))
                    for iter3032 in viter3031:
                        iter3032.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysCriteria_result)
navigateKeysCriteria_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class navigateKeysCriteriaTime_args(object):
    """
    Attributes:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype3036, _size3033) = iprot.readListBegin()
                    for _i3037 in range(_size3033):
                        _elem3038 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem3038)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysCriteriaTime_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter3039 in self.keys:
                oprot.writeString(iter3039.encode('utf-8') if sys.version_info[0] == 2 else iter3039)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysCriteriaTime_args)
navigateKeysCriteriaTime_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class navigateKeysCriteriaTime_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype3041, _vtype3042, _size3040) = iprot.readMapBegin()
                    for _i3044 in range(_size3040):
                        _key3045 = iprot.readI64()
                        _val3046 = {}
                        (_ktype3048, _vtype3049, _size3047) = iprot.readMapBegin()
                        for _i3051 in range(_size3047):
                            _key3052 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val3053 = []
                            (_etype3057, _size3054) = iprot.readSetBegin()
                            for _i3058 in range(_size3054):
                                _elem3059 = TObject()
                                _elem3059.read(iprot)
                                _val3053.append(_elem3059)
                            iprot.readSetEnd()
                            _val3046[_key3052] = _val3053
                        iprot.readMapEnd()
                        self.success[_key3045] = _val3046
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysCriteriaTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter3060, viter3061 in list(self.success.items()):
                oprot.writeI64(kiter3060)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter3061))
                for kiter3062, viter3063 in list(viter3061.items()):
                    oprot.writeString(kiter3062.encode('utf-8') if sys.version_info[0] == 2 else kiter3062)
                    oprot.writeSetBegin(TType.STRUCT, len(viter3063))
                    for iter3064 in viter3063:
                        iter3064.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysCriteriaTime_result)
navigateKeysCriteriaTime_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class navigateKeysCriteriaTimestr_args(object):
    """
    Attributes:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment

    """


    def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
        self.keys = keys
        self.criteria = criteria
        self.timestamp = timestamp
        self.creds = creds
        self.transaction = transaction
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype3068, _size3065) = iprot.readListBegin()
                    for _i3069 in range(_size3065):
                        _elem3070 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem3070)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.criteria = TCriteria()
                    self.criteria.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transaction = TransactionToken()
                    self.transaction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysCriteriaTimestr_args')
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter3071 in self.keys:
                oprot.writeString(iter3071.encode('utf-8') if sys.version_info[0] == 2 else iter3071)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
            self.criteria.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.transaction is not None:
            oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
            self.transaction.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 6)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysCriteriaTimestr_args)
navigateKeysCriteriaTimestr_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRUCT, 'criteria', [TCriteria, None], None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
    (5, TType.STRUCT, 'transaction', [TransactionToken, None], None, ),  # 5
    (6, TType.STRING, 'environment', 'UTF8', None, ),  # 6
)


class navigateKeysCriteriaTimestr_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype3073, _vtype3074, _size3072) = iprot.readMapBegin()
                    for _i3076 in range(_size3072):
                        _key3077 = iprot.readI64()
                        _val3078 = {}
                        (_ktype3080, _vtype3081, _size3079) = iprot.readMapBegin()
                        for _i3083 in range(_size3079):
                            _key3084 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val3085 = []
                            (_etype3089, _size3086) = iprot.readSetBegin()
                            for _i3090 in range(_size3086):
                                _elem3091 = TObject()
                                _elem3091.read(iprot)
                                _val3085.append(_elem3091)
                            iprot.readSetEnd()
                            _val3078[_key3084] = _val3085
                        iprot.readMapEnd()
                        self.success[_key3077] = _val3078
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('navigateKeysCriteriaTimestr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter3092, viter3093 in list(self.success.items()):
                oprot.writeI64(kiter3092)
                oprot.writeMapBegin(TType.STRING, TType.SET, len(viter3093))
                for kiter3094, viter3095 in list(viter3093.items()):
                    oprot.writeString(kiter3094.encode('utf-8') if sys.version_info[0] == 2 else kiter3094)
                    oprot.writeSetBegin(TType.STRUCT, len(viter3095))
                    for iter3096 in viter3095:
                        iter3096.write(oprot)
                    oprot.writeSetEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(navigateKeysCriteriaTimestr_result)
navigateKeysCriteriaTimestr_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.STRING, 'UTF8', TType.SET, (TType.STRUCT, [TObject, None], False), False), False), None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class getServerEnvironment_args(object):
    """
    Attributes:
     - creds
     - token
     - environment

    """


    def __init__(self, creds=None, token=None, environment=None,):
        self.creds = creds
        self.token = token
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.token = TransactionToken()
                    self.token.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getServerEnvironment_args')
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 1)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRUCT, 2)
            self.token.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 3)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getServerEnvironment_args)
getServerEnvironment_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 1
    (2, TType.STRUCT, 'token', [TransactionToken, None], None, ),  # 2
    (3, TType.STRING, 'environment', 'UTF8', None, ),  # 3
)


class getServerEnvironment_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getServerEnvironment_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getServerEnvironment_result)
getServerEnvironment_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class getServerVersion_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getServerVersion_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getServerVersion_args)
getServerVersion_args.thrift_spec = (
)


class getServerVersion_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getServerVersion_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getServerVersion_result)
getServerVersion_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class time_args(object):
    """
    Attributes:
     - creds
     - token
     - environment

    """


    def __init__(self, creds=None, token=None, environment=None,):
        self.creds = creds
        self.token = token
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.token = TransactionToken()
                    self.token.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('time_args')
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 1)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRUCT, 2)
            self.token.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 3)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(time_args)
time_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 1
    (2, TType.STRUCT, 'token', [TransactionToken, None], None, ),  # 2
    (3, TType.STRING, 'environment', 'UTF8', None, ),  # 3
)


class time_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = PermissionException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('time_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(time_result)
time_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [PermissionException, None], None, ),  # 3
)


class timePhrase_args(object):
    """
    Attributes:
     - phrase
     - creds
     - token
     - environment

    """


    def __init__(self, phrase=None, creds=None, token=None, environment=None,):
        self.phrase = phrase
        self.creds = creds
        self.token = token
        self.environment = environment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.phrase = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.token = TransactionToken()
                    self.token.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.environment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('timePhrase_args')
        if self.phrase is not None:
            oprot.writeFieldBegin('phrase', TType.STRING, 1)
            oprot.writeString(self.phrase.encode('utf-8') if sys.version_info[0] == 2 else self.phrase)
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 2)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRUCT, 3)
            self.token.write(oprot)
            oprot.writeFieldEnd()
        if self.environment is not None:
            oprot.writeFieldBegin('environment', TType.STRING, 4)
            oprot.writeString(self.environment.encode('utf-8') if sys.version_info[0] == 2 else self.environment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(timePhrase_args)
timePhrase_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'phrase', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 2
    (3, TType.STRUCT, 'token', [TransactionToken, None], None, ),  # 3
    (4, TType.STRING, 'environment', 'UTF8', None, ),  # 4
)


class timePhrase_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2
     - ex3
     - ex4

    """


    def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2
        self.ex3 = ex3
        self.ex4 = ex4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = TransactionException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ex3 = ParseException()
                    self.ex3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ex4 = PermissionException()
                    self.ex4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('timePhrase_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        if self.ex3 is not None:
            oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
            self.ex3.write(oprot)
            oprot.writeFieldEnd()
        if self.ex4 is not None:
            oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
            self.ex4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(timePhrase_result)
timePhrase_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [TransactionException, None], None, ),  # 2
    (3, TType.STRUCT, 'ex3', [ParseException, None], None, ),  # 3
    (4, TType.STRUCT, 'ex4', [PermissionException, None], None, ),  # 4
)


class invokeManagement_args(object):
    """
    Attributes:
     - method
     - params
     - creds

    """


    def __init__(self, method=None, params=None, creds=None,):
        self.method = method
        self.params = params
        self.creds = creds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.method = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.params = []
                    (_etype3100, _size3097) = iprot.readListBegin()
                    for _i3101 in range(_size3097):
                        _elem3102 = ComplexTObject()
                        _elem3102.read(iprot)
                        self.params.append(_elem3102)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creds = AccessToken()
                    self.creds.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('invokeManagement_args')
        if self.method is not None:
            oprot.writeFieldBegin('method', TType.STRING, 2)
            oprot.writeString(self.method.encode('utf-8') if sys.version_info[0] == 2 else self.method)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.params))
            for iter3103 in self.params:
                iter3103.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.creds is not None:
            oprot.writeFieldBegin('creds', TType.STRUCT, 4)
            self.creds.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(invokeManagement_args)
invokeManagement_args.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRING, 'method', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'params', (TType.STRUCT, [ComplexTObject, None], False), None, ),  # 3
    (4, TType.STRUCT, 'creds', [AccessToken, None], None, ),  # 4
)


class invokeManagement_result(object):
    """
    Attributes:
     - success
     - ex
     - ex2

    """


    def __init__(self, success=None, ex=None, ex2=None,):
        self.success = success
        self.ex = ex
        self.ex2 = ex2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ComplexTObject()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = SecurityException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ex2 = ManagementException()
                    self.ex2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('invokeManagement_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        if self.ex2 is not None:
            oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
            self.ex2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(invokeManagement_result)
invokeManagement_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ComplexTObject, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [SecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ex2', [ManagementException, None], None, ),  # 2
)
fix_spec(all_structs)
del all_structs

