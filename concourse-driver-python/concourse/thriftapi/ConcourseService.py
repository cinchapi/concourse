#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import logging
from .data.ttypes import *
from .shared.ttypes import *
from .exceptions.ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  """
  The interface definition for the Concourse Server API.
  """
  def abort(self, creds, transaction, environment):
    """
    Abort the current transaction and discard any changes that are
    currently staged.
    <p>
    After returning, the driver will return to {@code autocommit} mode and
    all subsequent changes will be committed immediately.
    </p>
    <p>
    Calling this method when the driver is not in {@code staging} mode is a
    no-op.
    </p>
    @param record the id of the record in which an attempt is made to add
                    the data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @throws exceptions.SecurityException if the {@code creds} don't represent a
            valid session

    Parameters:
     - creds
     - transaction
     - environment
    """
    pass

  def addKeyValue(self, key, value, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in a new record.

    @param key the field name
    @param value the value to add
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the new record id
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    pass

  def addKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in {@code record}.

    @param key the field name
    @param value the value to add
    @param record the record id where an attempt is made to add the data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a bool that indicates if the data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def addKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in each of the {@code records} where it
    doesn't exist.

    @param key the field name
    @param value the value to add
    @param records a list of record ids where an attempt is made to add the
                     data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a mapping from each record id to a boolean that indicates if the
                      data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def auditRecord(self, record, creds, transaction, environment):
    """
    List all the changes ever made to {@code record}.

    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def auditRecordStart(self, record, start, creds, transaction, environment):
    """
    List all the changes made to {@code record} since {@code start}
    (inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def auditRecordStartstr(self, record, start, creds, transaction, environment):
    """
    List all the changes made to {@code record} since {@code start}
    (inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def auditRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to {@code record} between {@code start}
    (inclusive) and {@code end} (non-inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def auditRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to {@code record} between {@code start}
    (inclusive) and {@code end} (non-inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def auditKeyRecord(self, key, record, creds, transaction, environment):
    """
    List all the changes ever made to the {@code key} field in {@code record}.

    @param key the field name
    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def auditKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record} since
    {@code start} (inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def auditKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record} since
    {@code start} (inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def auditKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record}
    between {@code start} (inclusive) and {@code end} (non-inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent change that
                 should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def auditKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record}
    between {@code start} (inclusive) and {@code end} (non-inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def browseKey(self, key, creds, transaction, environment):
    """
    View the values from all records that are currently stored for {@code key}.

    @param keys the field name
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contain that value in the {@code key} field
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - creds
     - transaction
     - environment
    """
    pass

  def browseKeys(self, keys, creds, transaction, environment):
    """
    View the values from all records that are currently stored for each of the
    {@code keys}.

    @param keys a list of field names
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the set of records that contain that value in the
            {@code key} field
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - keys
     - creds
     - transaction
     - environment
    """
    pass

  def browseKeyTime(self, key, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for {@code key} at
    {@code timestamp}.

    @param keys the field name
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contained that value in the {@code key} field at {@code
            timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def browseKeyTimestr(self, key, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for {@code key} at
    {@code timestamp}.

    @param keys the field name
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contained that value in the {@code key} field at {@code
            timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def browseKeysTime(self, keys, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for each of the
    {@code keys} at {@code timestamp}.

    @param keys a list of field names
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the {@link Set} of records that contained that value
            in the {@code key} field at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - keys
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def browseKeysTimestr(self, keys, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for each of the
    {@code keys} at {@code timestamp}.

    @param keys a list of field names
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the {@link Set} of records that contained that value
            in the {@code key} field at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - keys
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def chronologizeKeyRecord(self, key, record, creds, transaction, environment):
    """
    View a time series that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def chronologizeKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and the present that
    associates the timestamp of each modification for {@code key} in
    {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def chronologizeKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and the present that
    associates the timestamp of each modification for {@code key} in
    {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def chronologizeKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and {@code end}
    (non-inclusive) that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param end the {@link Timestamp} that should be greater than every
               timestamp in the time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def chronologizeKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and {@code end}
    (non-inclusive) that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param end the {@link Timestamp} that should be greater than every
               timestamp in the time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def clearRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def clearRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def clearKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def clearKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def clearKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def clearKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def commit(self, creds, transaction, environment):
    """
    Attempt to permanently commit any changes that are staged in a transaction
    and return {@code true} if and only if all the changes can be applied.
    Otherwise, returns {@code false} and all the changes are discarded.
    <p>
    After returning, the driver will return to {@code autocommit} mode and
    all subsequent changes will be committed immediately.
    </p>
    <p>
    This method will return {@code false} if it is called when the driver is
    not in {@code staging} mode.
    </p>

    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return {@code true} if all staged changes are committed, otherwise {@code
                         false}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - creds
     - transaction
     - environment
    """
    pass

  def describe(self, creds, transaction, environment):
    """
    List all the keys in the database.

    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys in the database
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - creds
     - transaction
     - environment
    """
    pass

  def describeTime(self, timestamp, creds, transaction, environment):
    """
    List all the keys in the database at {@code timestamp}.

    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys that were in the database at
            {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def describeTimestr(self, timestamp, creds, transaction, environment):
    """
    List all the keys in the database at {@code timestamp}.

    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys that were in the database at
            {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecord(self, record, creds, transaction, environment):
    """
    List all the keys in {@code record} that have at least one value.

    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys in {@code record}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecordTime(self, record, timestamp, creds, transaction, environment):
    """
    List all the keys in {@code record} that had at least one value at
    {@code timestamp}.

    @param record the record id
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys that were in {@code record} at
            {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecordTimestr(self, record, timestamp, creds, transaction, environment):
    """
    List all the keys in {@code record} that have at least one value.

    @param record the record id
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys that were in {@code record} at
            {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecords(self, records, creds, transaction, environment):
    """
    For each of the {@code records}, list all of the keys that have at least
    one value.

    @param records a collection of record ids
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys in that record
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecordsTime(self, records, timestamp, creds, transaction, environment):
    """
    For each of the {@code records}, list all the keys that had at least one
    value at {@code timestamp}.

    @param records a collection of record ids
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys that were in that record at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    """
    For each of the {@code records}, list all the keys that had at least one
    value at {@code timestamp}.

    @param records a collection of record ids
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys that were in that record at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def diffRecordStart(self, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code record} since {@code start}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at the present.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffRecordStartstr(self, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code record} since {@code start}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at the present.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code record} from {@code start} to
    {@code end}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at {@code end}.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def diffRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code record} from {@code start} to
    {@code end}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at {@code end}.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} since
    {@code start}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    the present.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} since
    {@code start}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    the present.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} from
    {@code start} to {@code end}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    {@code end}.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} from
    {@code start} to {@code end}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    {@code end}.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyStart(self, key, start, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    since {@code start}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at the present.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyStartstr(self, key, start, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    since {@code start}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at the present.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyStartEnd(self, key, start, tend, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    from {@code start} to {@code end}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at {@code end}.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyStartstrEndstr(self, key, start, tend, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    from {@code start} to {@code end}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at {@code end}.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def invokePlugin(self, id, method, params, creds, transaction, environment):
    """
    Invoke a Plugin method.

    <p>
    Assuming that there is a plugin distribution that contains a class
    named after {@code id}, and has the specified {@code method}, invoke the
    same with {@code params} and return the result.
    </p>

    @param id the fully qualified name of the plugin class
    @param method the name of the method in {@code clazz} to invoke
    @param params a list of TObjects to pass to {@code method} as args
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the result of the method invocation
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of the arguments are
            invalid

    Parameters:
     - id
     - method
     - params
     - creds
     - transaction
     - environment
    """
    pass

  def login(self, username, password, environment):
    """
    Attempt to authenticate the user identified by the {@code username} and
    {@code password} combination to the specified {@code environment}. If
    successful, establish a new session within the {@code environment} on
    behalf of that user and return an {@link shared.AccessToken}, which is
    required for all subsequent operations.

    <p>
    The AccessToken <em>may</em> expire after a while so clients should be
    prepared to seamlessly login again for active user sessions.
    </p>

    @param username a binary representation of the UTF-8 encoded username
    @param password a binary representation of the UTF-8 encoded password
    @param environment the name of the environment into which to login
    @return an {@link shared.AccessToken} to submit with all subsequent method
            calls
    @throws exceptions.SecurityException if the login is not successful

    Parameters:
     - username
     - password
     - environment
    """
    pass

  def logout(self, token, environment):
    """
    Terminate the session within {@code environment} for the user represented
    by the {@code token}. Afterwards, all other attempts to use {@code token}
    will result in a {@link exceptions.SecurityException} being thrown.

    @param token the {@link shared.AccessToken to expire}
    @param environment the environment of the session represented by the
                       {@code token}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session

    Parameters:
     - token
     - environment
    """
    pass

  def stage(self, token, environment):
    """
    Start a new transaction.
    <p>
    This method will turn on STAGING mode so that all subsequent changes are
    collected in an isolated buffer before possibly being committed to the
    database. Staged operations are guaranteed to be reliable, all or nothing
    units of work that allow correct recovery from failures and provide
    isolation between clients so the database is always in a consistent state.
    </p>
    <p>
    After this method returns, all subsequent operations will be done in
    {@code staging} mode until either #abort(shared.AccessToken) or
    #commit(shared.AccessToken) is called.
    </p>

    @param token
    @param environment
    @return TransactionToken
    @throws TSecurityException

    Parameters:
     - token
     - environment
    """
    pass

  def insertJson(self, json, creds, transaction, environment):
    """
    Parameters:
     - json
     - creds
     - transaction
     - environment
    """
    pass

  def insertJsonRecord(self, json, record, creds, transaction, environment):
    """
    Parameters:
     - json
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def insertJsonRecords(self, json, records, creds, transaction, environment):
    """
    Parameters:
     - json
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def removeKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def removeKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def setKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def setKeyValue(self, key, value, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    pass

  def setKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def reconcileKeyRecordValues(self, key, record, values, creds, transaction, environment):
    """
    The {@code value} in {@code key} of {@code record} are added
    and removed to be set as exactly the same as the input values

    @param key the field name
    @param record the record id where an attempt is made to add the data
    @param values collection of values to set
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a bool that indicates if the data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - record
     - values
     - creds
     - transaction
     - environment
    """
    pass

  def inventory(self, creds, transaction, environment):
    """
    Parameters:
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecordTime(self, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecordTimestr(self, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecordsTime(self, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def selectCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def selectCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectCclTime(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCriteria(self, keys, criteria, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCcl(self, keys, ccl, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def getCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def getCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def getCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getCclTime(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCriteria(self, keys, criteria, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCcl(self, keys, ccl, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def verifyKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def verifyKeyValueRecordTime(self, key, value, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def verifyKeyValueRecordTimestr(self, key, value, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def jsonifyRecords(self, records, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - identifier
     - creds
     - transaction
     - environment
    """
    pass

  def jsonifyRecordsTime(self, records, timestamp, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - identifier
     - creds
     - transaction
     - environment
    """
    pass

  def jsonifyRecordsTimestr(self, records, timestamp, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - identifier
     - creds
     - transaction
     - environment
    """
    pass

  def findCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def findCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorValues(self, key, operator, values, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorstrValues(self, key, operator, values, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorstrValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorstrValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def search(self, key, query, creds, transaction, environment):
    """
    Parameters:
     - key
     - query
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def pingRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def pingRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def verifyAndSwap(self, key, expected, record, replacement, creds, transaction, environment):
    """
    Parameters:
     - key
     - expected
     - record
     - replacement
     - creds
     - transaction
     - environment
    """
    pass

  def verifyOrSet(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def findOrAddKeyValue(self, key, value, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    pass

  def findOrInsertCriteriaJson(self, criteria, json, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - json
     - creds
     - transaction
     - environment
    """
    pass

  def findOrInsertCclJson(self, ccl, json, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - json
     - creds
     - transaction
     - environment
    """
    pass

  def sumKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def sumKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def sumKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def sumKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def sumKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def sumKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def sumKey(self, key, creds, transaction, environment):
    """
    Parameters:
     - key
     - creds
     - transaction
     - environment
    """
    pass

  def sumKeyTime(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def sumKeyTimestr(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def sumKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def sumKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def sumKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def sumKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def sumKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def sumKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def averageKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def averageKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def averageKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def averageKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def averageKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def averageKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def averageKey(self, key, creds, transaction, environment):
    """
    Parameters:
     - key
     - creds
     - transaction
     - environment
    """
    pass

  def averageKeyTime(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def averageKeyTimestr(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def averageKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def averageKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def averageKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def averageKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def averageKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def averageKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def countKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def countKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def countKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def countKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def countKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def countKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def countKey(self, key, creds, transaction, environment):
    """
    Parameters:
     - key
     - creds
     - transaction
     - environment
    """
    pass

  def countKeyTime(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def countKeyTimestr(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def countKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def countKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def countKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def countKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def countKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def countKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def maxKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def maxKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def maxKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def maxKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def maxKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def maxKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def maxKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def maxKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def maxKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def maxKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def maxKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def maxKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def maxKey(self, key, creds, transaction, environment):
    """
    Parameters:
     - key
     - creds
     - transaction
     - environment
    """
    pass

  def maxKeyTime(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def maxKeyTimestr(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def minKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def minKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def minKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def minKey(self, key, creds, transaction, environment):
    """
    Parameters:
     - key
     - creds
     - transaction
     - environment
    """
    pass

  def minKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def minKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def minKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def minKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def minKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def minKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def minKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def minKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def minKeyTime(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def minKeyTimestr(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def minKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeysCcl(self, keys, ccl, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeysCriteria(self, keys, criteria, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def navigateKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getServerEnvironment(self, creds, token, environment):
    """
    Parameters:
     - creds
     - token
     - environment
    """
    pass

  def getServerVersion(self):
    pass

  def time(self, creds, token, environment):
    """
    Parameters:
     - creds
     - token
     - environment
    """
    pass

  def timePhrase(self, phrase, creds, token, environment):
    """
    Parameters:
     - phrase
     - creds
     - token
     - environment
    """
    pass


class Client(Iface):
  """
  The interface definition for the Concourse Server API.
  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def abort(self, creds, transaction, environment):
    """
    Abort the current transaction and discard any changes that are
    currently staged.
    <p>
    After returning, the driver will return to {@code autocommit} mode and
    all subsequent changes will be committed immediately.
    </p>
    <p>
    Calling this method when the driver is not in {@code staging} mode is a
    no-op.
    </p>
    @param record the id of the record in which an attempt is made to add
                    the data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @throws exceptions.SecurityException if the {@code creds} don't represent a
            valid session

    Parameters:
     - creds
     - transaction
     - environment
    """
    self.send_abort(creds, transaction, environment)
    self.recv_abort()

  def send_abort(self, creds, transaction, environment):
    self._oprot.writeMessageBegin('abort', TMessageType.CALL, self._seqid)
    args = abort_args()
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_abort(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = abort_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    return

  def addKeyValue(self, key, value, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in a new record.

    @param key the field name
    @param value the value to add
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the new record id
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    self.send_addKeyValue(key, value, creds, transaction, environment)
    return self.recv_addKeyValue()

  def send_addKeyValue(self, key, value, creds, transaction, environment):
    self._oprot.writeMessageBegin('addKeyValue', TMessageType.CALL, self._seqid)
    args = addKeyValue_args()
    args.key = key
    args.value = value
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addKeyValue(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = addKeyValue_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addKeyValue failed: unknown result")

  def addKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in {@code record}.

    @param key the field name
    @param value the value to add
    @param record the record id where an attempt is made to add the data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a bool that indicates if the data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    self.send_addKeyValueRecord(key, value, record, creds, transaction, environment)
    return self.recv_addKeyValueRecord()

  def send_addKeyValueRecord(self, key, value, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('addKeyValueRecord', TMessageType.CALL, self._seqid)
    args = addKeyValueRecord_args()
    args.key = key
    args.value = value
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addKeyValueRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = addKeyValueRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addKeyValueRecord failed: unknown result")

  def addKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in each of the {@code records} where it
    doesn't exist.

    @param key the field name
    @param value the value to add
    @param records a list of record ids where an attempt is made to add the
                     data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a mapping from each record id to a boolean that indicates if the
                      data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    self.send_addKeyValueRecords(key, value, records, creds, transaction, environment)
    return self.recv_addKeyValueRecords()

  def send_addKeyValueRecords(self, key, value, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('addKeyValueRecords', TMessageType.CALL, self._seqid)
    args = addKeyValueRecords_args()
    args.key = key
    args.value = value
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addKeyValueRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = addKeyValueRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addKeyValueRecords failed: unknown result")

  def auditRecord(self, record, creds, transaction, environment):
    """
    List all the changes ever made to {@code record}.

    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    self.send_auditRecord(record, creds, transaction, environment)
    return self.recv_auditRecord()

  def send_auditRecord(self, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditRecord', TMessageType.CALL, self._seqid)
    args = auditRecord_args()
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecord failed: unknown result")

  def auditRecordStart(self, record, start, creds, transaction, environment):
    """
    List all the changes made to {@code record} since {@code start}
    (inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_auditRecordStart(record, start, creds, transaction, environment)
    return self.recv_auditRecordStart()

  def send_auditRecordStart(self, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditRecordStart', TMessageType.CALL, self._seqid)
    args = auditRecordStart_args()
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditRecordStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditRecordStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecordStart failed: unknown result")

  def auditRecordStartstr(self, record, start, creds, transaction, environment):
    """
    List all the changes made to {@code record} since {@code start}
    (inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_auditRecordStartstr(record, start, creds, transaction, environment)
    return self.recv_auditRecordStartstr()

  def send_auditRecordStartstr(self, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditRecordStartstr', TMessageType.CALL, self._seqid)
    args = auditRecordStartstr_args()
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditRecordStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditRecordStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecordStartstr failed: unknown result")

  def auditRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to {@code record} between {@code start}
    (inclusive) and {@code end} (non-inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_auditRecordStartEnd(record, start, tend, creds, transaction, environment)
    return self.recv_auditRecordStartEnd()

  def send_auditRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditRecordStartEnd', TMessageType.CALL, self._seqid)
    args = auditRecordStartEnd_args()
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditRecordStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditRecordStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecordStartEnd failed: unknown result")

  def auditRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to {@code record} between {@code start}
    (inclusive) and {@code end} (non-inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_auditRecordStartstrEndstr(record, start, tend, creds, transaction, environment)
    return self.recv_auditRecordStartstrEndstr()

  def send_auditRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditRecordStartstrEndstr', TMessageType.CALL, self._seqid)
    args = auditRecordStartstrEndstr_args()
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditRecordStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditRecordStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecordStartstrEndstr failed: unknown result")

  def auditKeyRecord(self, key, record, creds, transaction, environment):
    """
    List all the changes ever made to the {@code key} field in {@code record}.

    @param key the field name
    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_auditKeyRecord(key, record, creds, transaction, environment)
    return self.recv_auditKeyRecord()

  def send_auditKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditKeyRecord', TMessageType.CALL, self._seqid)
    args = auditKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecord failed: unknown result")

  def auditKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record} since
    {@code start} (inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_auditKeyRecordStart(key, record, start, creds, transaction, environment)
    return self.recv_auditKeyRecordStart()

  def send_auditKeyRecordStart(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditKeyRecordStart', TMessageType.CALL, self._seqid)
    args = auditKeyRecordStart_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditKeyRecordStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditKeyRecordStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecordStart failed: unknown result")

  def auditKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record} since
    {@code start} (inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_auditKeyRecordStartstr(key, record, start, creds, transaction, environment)
    return self.recv_auditKeyRecordStartstr()

  def send_auditKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditKeyRecordStartstr', TMessageType.CALL, self._seqid)
    args = auditKeyRecordStartstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditKeyRecordStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditKeyRecordStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecordStartstr failed: unknown result")

  def auditKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record}
    between {@code start} (inclusive) and {@code end} (non-inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent change that
                 should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_auditKeyRecordStartEnd(key, record, start, tend, creds, transaction, environment)
    return self.recv_auditKeyRecordStartEnd()

  def send_auditKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditKeyRecordStartEnd', TMessageType.CALL, self._seqid)
    args = auditKeyRecordStartEnd_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditKeyRecordStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditKeyRecordStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecordStartEnd failed: unknown result")

  def auditKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record}
    between {@code start} (inclusive) and {@code end} (non-inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_auditKeyRecordStartstrEndstr(key, record, start, tend, creds, transaction, environment)
    return self.recv_auditKeyRecordStartstrEndstr()

  def send_auditKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditKeyRecordStartstrEndstr', TMessageType.CALL, self._seqid)
    args = auditKeyRecordStartstrEndstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditKeyRecordStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditKeyRecordStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecordStartstrEndstr failed: unknown result")

  def browseKey(self, key, creds, transaction, environment):
    """
    View the values from all records that are currently stored for {@code key}.

    @param keys the field name
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contain that value in the {@code key} field
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - creds
     - transaction
     - environment
    """
    self.send_browseKey(key, creds, transaction, environment)
    return self.recv_browseKey()

  def send_browseKey(self, key, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKey', TMessageType.CALL, self._seqid)
    args = browseKey_args()
    args.key = key
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKey(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKey_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKey failed: unknown result")

  def browseKeys(self, keys, creds, transaction, environment):
    """
    View the values from all records that are currently stored for each of the
    {@code keys}.

    @param keys a list of field names
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the set of records that contain that value in the
            {@code key} field
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - keys
     - creds
     - transaction
     - environment
    """
    self.send_browseKeys(keys, creds, transaction, environment)
    return self.recv_browseKeys()

  def send_browseKeys(self, keys, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKeys', TMessageType.CALL, self._seqid)
    args = browseKeys_args()
    args.keys = keys
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKeys(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKeys_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeys failed: unknown result")

  def browseKeyTime(self, key, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for {@code key} at
    {@code timestamp}.

    @param keys the field name
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contained that value in the {@code key} field at {@code
            timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_browseKeyTime(key, timestamp, creds, transaction, environment)
    return self.recv_browseKeyTime()

  def send_browseKeyTime(self, key, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKeyTime', TMessageType.CALL, self._seqid)
    args = browseKeyTime_args()
    args.key = key
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKeyTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKeyTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeyTime failed: unknown result")

  def browseKeyTimestr(self, key, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for {@code key} at
    {@code timestamp}.

    @param keys the field name
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contained that value in the {@code key} field at {@code
            timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_browseKeyTimestr(key, timestamp, creds, transaction, environment)
    return self.recv_browseKeyTimestr()

  def send_browseKeyTimestr(self, key, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKeyTimestr', TMessageType.CALL, self._seqid)
    args = browseKeyTimestr_args()
    args.key = key
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKeyTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKeyTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeyTimestr failed: unknown result")

  def browseKeysTime(self, keys, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for each of the
    {@code keys} at {@code timestamp}.

    @param keys a list of field names
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the {@link Set} of records that contained that value
            in the {@code key} field at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - keys
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_browseKeysTime(keys, timestamp, creds, transaction, environment)
    return self.recv_browseKeysTime()

  def send_browseKeysTime(self, keys, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKeysTime', TMessageType.CALL, self._seqid)
    args = browseKeysTime_args()
    args.keys = keys
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKeysTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKeysTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeysTime failed: unknown result")

  def browseKeysTimestr(self, keys, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for each of the
    {@code keys} at {@code timestamp}.

    @param keys a list of field names
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the {@link Set} of records that contained that value
            in the {@code key} field at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - keys
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_browseKeysTimestr(keys, timestamp, creds, transaction, environment)
    return self.recv_browseKeysTimestr()

  def send_browseKeysTimestr(self, keys, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKeysTimestr', TMessageType.CALL, self._seqid)
    args = browseKeysTimestr_args()
    args.keys = keys
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKeysTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKeysTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeysTimestr failed: unknown result")

  def chronologizeKeyRecord(self, key, record, creds, transaction, environment):
    """
    View a time series that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_chronologizeKeyRecord(key, record, creds, transaction, environment)
    return self.recv_chronologizeKeyRecord()

  def send_chronologizeKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('chronologizeKeyRecord', TMessageType.CALL, self._seqid)
    args = chronologizeKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chronologizeKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = chronologizeKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecord failed: unknown result")

  def chronologizeKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and the present that
    associates the timestamp of each modification for {@code key} in
    {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_chronologizeKeyRecordStart(key, record, start, creds, transaction, environment)
    return self.recv_chronologizeKeyRecordStart()

  def send_chronologizeKeyRecordStart(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('chronologizeKeyRecordStart', TMessageType.CALL, self._seqid)
    args = chronologizeKeyRecordStart_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chronologizeKeyRecordStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = chronologizeKeyRecordStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecordStart failed: unknown result")

  def chronologizeKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and the present that
    associates the timestamp of each modification for {@code key} in
    {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_chronologizeKeyRecordStartstr(key, record, start, creds, transaction, environment)
    return self.recv_chronologizeKeyRecordStartstr()

  def send_chronologizeKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('chronologizeKeyRecordStartstr', TMessageType.CALL, self._seqid)
    args = chronologizeKeyRecordStartstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chronologizeKeyRecordStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = chronologizeKeyRecordStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecordStartstr failed: unknown result")

  def chronologizeKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and {@code end}
    (non-inclusive) that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param end the {@link Timestamp} that should be greater than every
               timestamp in the time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_chronologizeKeyRecordStartEnd(key, record, start, tend, creds, transaction, environment)
    return self.recv_chronologizeKeyRecordStartEnd()

  def send_chronologizeKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('chronologizeKeyRecordStartEnd', TMessageType.CALL, self._seqid)
    args = chronologizeKeyRecordStartEnd_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chronologizeKeyRecordStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = chronologizeKeyRecordStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecordStartEnd failed: unknown result")

  def chronologizeKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and {@code end}
    (non-inclusive) that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param end the {@link Timestamp} that should be greater than every
               timestamp in the time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_chronologizeKeyRecordStartstrEndstr(key, record, start, tend, creds, transaction, environment)
    return self.recv_chronologizeKeyRecordStartstrEndstr()

  def send_chronologizeKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('chronologizeKeyRecordStartstrEndstr', TMessageType.CALL, self._seqid)
    args = chronologizeKeyRecordStartstrEndstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chronologizeKeyRecordStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = chronologizeKeyRecordStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecordStartstrEndstr failed: unknown result")

  def clearRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    self.send_clearRecord(record, creds, transaction, environment)
    self.recv_clearRecord()

  def send_clearRecord(self, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearRecord', TMessageType.CALL, self._seqid)
    args = clearRecord_args()
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def clearRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    self.send_clearRecords(records, creds, transaction, environment)
    self.recv_clearRecords()

  def send_clearRecords(self, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearRecords', TMessageType.CALL, self._seqid)
    args = clearRecords_args()
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def clearKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_clearKeyRecord(key, record, creds, transaction, environment)
    self.recv_clearKeyRecord()

  def send_clearKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearKeyRecord', TMessageType.CALL, self._seqid)
    args = clearKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def clearKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    self.send_clearKeysRecord(keys, record, creds, transaction, environment)
    self.recv_clearKeysRecord()

  def send_clearKeysRecord(self, keys, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearKeysRecord', TMessageType.CALL, self._seqid)
    args = clearKeysRecord_args()
    args.keys = keys
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearKeysRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearKeysRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def clearKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    self.send_clearKeyRecords(key, records, creds, transaction, environment)
    self.recv_clearKeyRecords()

  def send_clearKeyRecords(self, key, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearKeyRecords', TMessageType.CALL, self._seqid)
    args = clearKeyRecords_args()
    args.key = key
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearKeyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearKeyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def clearKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    self.send_clearKeysRecords(keys, records, creds, transaction, environment)
    self.recv_clearKeysRecords()

  def send_clearKeysRecords(self, keys, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearKeysRecords', TMessageType.CALL, self._seqid)
    args = clearKeysRecords_args()
    args.keys = keys
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearKeysRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearKeysRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def commit(self, creds, transaction, environment):
    """
    Attempt to permanently commit any changes that are staged in a transaction
    and return {@code true} if and only if all the changes can be applied.
    Otherwise, returns {@code false} and all the changes are discarded.
    <p>
    After returning, the driver will return to {@code autocommit} mode and
    all subsequent changes will be committed immediately.
    </p>
    <p>
    This method will return {@code false} if it is called when the driver is
    not in {@code staging} mode.
    </p>

    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return {@code true} if all staged changes are committed, otherwise {@code
                         false}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - creds
     - transaction
     - environment
    """
    self.send_commit(creds, transaction, environment)
    return self.recv_commit()

  def send_commit(self, creds, transaction, environment):
    self._oprot.writeMessageBegin('commit', TMessageType.CALL, self._seqid)
    args = commit_args()
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_commit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = commit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "commit failed: unknown result")

  def describe(self, creds, transaction, environment):
    """
    List all the keys in the database.

    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys in the database
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - creds
     - transaction
     - environment
    """
    self.send_describe(creds, transaction, environment)
    return self.recv_describe()

  def send_describe(self, creds, transaction, environment):
    self._oprot.writeMessageBegin('describe', TMessageType.CALL, self._seqid)
    args = describe_args()
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describe(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describe_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describe failed: unknown result")

  def describeTime(self, timestamp, creds, transaction, environment):
    """
    List all the keys in the database at {@code timestamp}.

    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys that were in the database at
            {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_describeTime(timestamp, creds, transaction, environment)
    return self.recv_describeTime()

  def send_describeTime(self, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeTime', TMessageType.CALL, self._seqid)
    args = describeTime_args()
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeTime failed: unknown result")

  def describeTimestr(self, timestamp, creds, transaction, environment):
    """
    List all the keys in the database at {@code timestamp}.

    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys that were in the database at
            {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_describeTimestr(timestamp, creds, transaction, environment)
    return self.recv_describeTimestr()

  def send_describeTimestr(self, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeTimestr', TMessageType.CALL, self._seqid)
    args = describeTimestr_args()
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeTimestr failed: unknown result")

  def describeRecord(self, record, creds, transaction, environment):
    """
    List all the keys in {@code record} that have at least one value.

    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys in {@code record}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    self.send_describeRecord(record, creds, transaction, environment)
    return self.recv_describeRecord()

  def send_describeRecord(self, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecord', TMessageType.CALL, self._seqid)
    args = describeRecord_args()
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecord failed: unknown result")

  def describeRecordTime(self, record, timestamp, creds, transaction, environment):
    """
    List all the keys in {@code record} that had at least one value at
    {@code timestamp}.

    @param record the record id
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys that were in {@code record} at
            {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_describeRecordTime(record, timestamp, creds, transaction, environment)
    return self.recv_describeRecordTime()

  def send_describeRecordTime(self, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecordTime', TMessageType.CALL, self._seqid)
    args = describeRecordTime_args()
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecordTime failed: unknown result")

  def describeRecordTimestr(self, record, timestamp, creds, transaction, environment):
    """
    List all the keys in {@code record} that have at least one value.

    @param record the record id
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys that were in {@code record} at
            {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_describeRecordTimestr(record, timestamp, creds, transaction, environment)
    return self.recv_describeRecordTimestr()

  def send_describeRecordTimestr(self, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecordTimestr', TMessageType.CALL, self._seqid)
    args = describeRecordTimestr_args()
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecordTimestr failed: unknown result")

  def describeRecords(self, records, creds, transaction, environment):
    """
    For each of the {@code records}, list all of the keys that have at least
    one value.

    @param records a collection of record ids
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys in that record
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    self.send_describeRecords(records, creds, transaction, environment)
    return self.recv_describeRecords()

  def send_describeRecords(self, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecords', TMessageType.CALL, self._seqid)
    args = describeRecords_args()
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecords failed: unknown result")

  def describeRecordsTime(self, records, timestamp, creds, transaction, environment):
    """
    For each of the {@code records}, list all the keys that had at least one
    value at {@code timestamp}.

    @param records a collection of record ids
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys that were in that record at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_describeRecordsTime(records, timestamp, creds, transaction, environment)
    return self.recv_describeRecordsTime()

  def send_describeRecordsTime(self, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecordsTime', TMessageType.CALL, self._seqid)
    args = describeRecordsTime_args()
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecordsTime failed: unknown result")

  def describeRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    """
    For each of the {@code records}, list all the keys that had at least one
    value at {@code timestamp}.

    @param records a collection of record ids
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys that were in that record at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_describeRecordsTimestr(records, timestamp, creds, transaction, environment)
    return self.recv_describeRecordsTimestr()

  def send_describeRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecordsTimestr', TMessageType.CALL, self._seqid)
    args = describeRecordsTimestr_args()
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecordsTimestr failed: unknown result")

  def diffRecordStart(self, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code record} since {@code start}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at the present.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffRecordStart(record, start, creds, transaction, environment)
    return self.recv_diffRecordStart()

  def send_diffRecordStart(self, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffRecordStart', TMessageType.CALL, self._seqid)
    args = diffRecordStart_args()
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffRecordStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffRecordStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffRecordStart failed: unknown result")

  def diffRecordStartstr(self, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code record} since {@code start}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at the present.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffRecordStartstr(record, start, creds, transaction, environment)
    return self.recv_diffRecordStartstr()

  def send_diffRecordStartstr(self, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffRecordStartstr', TMessageType.CALL, self._seqid)
    args = diffRecordStartstr_args()
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffRecordStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffRecordStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffRecordStartstr failed: unknown result")

  def diffRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code record} from {@code start} to
    {@code end}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at {@code end}.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffRecordStartEnd(record, start, tend, creds, transaction, environment)
    return self.recv_diffRecordStartEnd()

  def send_diffRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffRecordStartEnd', TMessageType.CALL, self._seqid)
    args = diffRecordStartEnd_args()
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffRecordStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffRecordStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffRecordStartEnd failed: unknown result")

  def diffRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code record} from {@code start} to
    {@code end}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at {@code end}.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffRecordStartstrEndstr(record, start, tend, creds, transaction, environment)
    return self.recv_diffRecordStartstrEndstr()

  def send_diffRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffRecordStartstrEndstr', TMessageType.CALL, self._seqid)
    args = diffRecordStartstrEndstr_args()
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffRecordStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffRecordStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffRecordStartstrEndstr failed: unknown result")

  def diffKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} since
    {@code start}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    the present.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyRecordStart(key, record, start, creds, transaction, environment)
    return self.recv_diffKeyRecordStart()

  def send_diffKeyRecordStart(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyRecordStart', TMessageType.CALL, self._seqid)
    args = diffKeyRecordStart_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyRecordStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyRecordStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyRecordStart failed: unknown result")

  def diffKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} since
    {@code start}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    the present.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyRecordStartstr(key, record, start, creds, transaction, environment)
    return self.recv_diffKeyRecordStartstr()

  def send_diffKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyRecordStartstr', TMessageType.CALL, self._seqid)
    args = diffKeyRecordStartstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyRecordStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyRecordStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyRecordStartstr failed: unknown result")

  def diffKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} from
    {@code start} to {@code end}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    {@code end}.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyRecordStartEnd(key, record, start, tend, creds, transaction, environment)
    return self.recv_diffKeyRecordStartEnd()

  def send_diffKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyRecordStartEnd', TMessageType.CALL, self._seqid)
    args = diffKeyRecordStartEnd_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyRecordStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyRecordStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyRecordStartEnd failed: unknown result")

  def diffKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} from
    {@code start} to {@code end}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    {@code end}.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyRecordStartstrEndstr(key, record, start, tend, creds, transaction, environment)
    return self.recv_diffKeyRecordStartstrEndstr()

  def send_diffKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyRecordStartstrEndstr', TMessageType.CALL, self._seqid)
    args = diffKeyRecordStartstrEndstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyRecordStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyRecordStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyRecordStartstrEndstr failed: unknown result")

  def diffKeyStart(self, key, start, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    since {@code start}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at the present.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyStart(key, start, creds, transaction, environment)
    return self.recv_diffKeyStart()

  def send_diffKeyStart(self, key, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyStart', TMessageType.CALL, self._seqid)
    args = diffKeyStart_args()
    args.key = key
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyStart failed: unknown result")

  def diffKeyStartstr(self, key, start, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    since {@code start}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at the present.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyStartstr(key, start, creds, transaction, environment)
    return self.recv_diffKeyStartstr()

  def send_diffKeyStartstr(self, key, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyStartstr', TMessageType.CALL, self._seqid)
    args = diffKeyStartstr_args()
    args.key = key
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyStartstr failed: unknown result")

  def diffKeyStartEnd(self, key, start, tend, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    from {@code start} to {@code end}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at {@code end}.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyStartEnd(key, start, tend, creds, transaction, environment)
    return self.recv_diffKeyStartEnd()

  def send_diffKeyStartEnd(self, key, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyStartEnd', TMessageType.CALL, self._seqid)
    args = diffKeyStartEnd_args()
    args.key = key
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyStartEnd failed: unknown result")

  def diffKeyStartstrEndstr(self, key, start, tend, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    from {@code start} to {@code end}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at {@code end}.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyStartstrEndstr(key, start, tend, creds, transaction, environment)
    return self.recv_diffKeyStartstrEndstr()

  def send_diffKeyStartstrEndstr(self, key, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyStartstrEndstr', TMessageType.CALL, self._seqid)
    args = diffKeyStartstrEndstr_args()
    args.key = key
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyStartstrEndstr failed: unknown result")

  def invokePlugin(self, id, method, params, creds, transaction, environment):
    """
    Invoke a Plugin method.

    <p>
    Assuming that there is a plugin distribution that contains a class
    named after {@code id}, and has the specified {@code method}, invoke the
    same with {@code params} and return the result.
    </p>

    @param id the fully qualified name of the plugin class
    @param method the name of the method in {@code clazz} to invoke
    @param params a list of TObjects to pass to {@code method} as args
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the result of the method invocation
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of the arguments are
            invalid

    Parameters:
     - id
     - method
     - params
     - creds
     - transaction
     - environment
    """
    self.send_invokePlugin(id, method, params, creds, transaction, environment)
    return self.recv_invokePlugin()

  def send_invokePlugin(self, id, method, params, creds, transaction, environment):
    self._oprot.writeMessageBegin('invokePlugin', TMessageType.CALL, self._seqid)
    args = invokePlugin_args()
    args.id = id
    args.method = method
    args.params = params
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_invokePlugin(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = invokePlugin_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "invokePlugin failed: unknown result")

  def login(self, username, password, environment):
    """
    Attempt to authenticate the user identified by the {@code username} and
    {@code password} combination to the specified {@code environment}. If
    successful, establish a new session within the {@code environment} on
    behalf of that user and return an {@link shared.AccessToken}, which is
    required for all subsequent operations.

    <p>
    The AccessToken <em>may</em> expire after a while so clients should be
    prepared to seamlessly login again for active user sessions.
    </p>

    @param username a binary representation of the UTF-8 encoded username
    @param password a binary representation of the UTF-8 encoded password
    @param environment the name of the environment into which to login
    @return an {@link shared.AccessToken} to submit with all subsequent method
            calls
    @throws exceptions.SecurityException if the login is not successful

    Parameters:
     - username
     - password
     - environment
    """
    self.send_login(username, password, environment)
    return self.recv_login()

  def send_login(self, username, password, environment):
    self._oprot.writeMessageBegin('login', TMessageType.CALL, self._seqid)
    args = login_args()
    args.username = username
    args.password = password
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_login(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = login_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "login failed: unknown result")

  def logout(self, token, environment):
    """
    Terminate the session within {@code environment} for the user represented
    by the {@code token}. Afterwards, all other attempts to use {@code token}
    will result in a {@link exceptions.SecurityException} being thrown.

    @param token the {@link shared.AccessToken to expire}
    @param environment the environment of the session represented by the
                       {@code token}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session

    Parameters:
     - token
     - environment
    """
    self.send_logout(token, environment)
    self.recv_logout()

  def send_logout(self, token, environment):
    self._oprot.writeMessageBegin('logout', TMessageType.CALL, self._seqid)
    args = logout_args()
    args.token = token
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_logout(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = logout_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    return

  def stage(self, token, environment):
    """
    Start a new transaction.
    <p>
    This method will turn on STAGING mode so that all subsequent changes are
    collected in an isolated buffer before possibly being committed to the
    database. Staged operations are guaranteed to be reliable, all or nothing
    units of work that allow correct recovery from failures and provide
    isolation between clients so the database is always in a consistent state.
    </p>
    <p>
    After this method returns, all subsequent operations will be done in
    {@code staging} mode until either #abort(shared.AccessToken) or
    #commit(shared.AccessToken) is called.
    </p>

    @param token
    @param environment
    @return TransactionToken
    @throws TSecurityException

    Parameters:
     - token
     - environment
    """
    self.send_stage(token, environment)
    return self.recv_stage()

  def send_stage(self, token, environment):
    self._oprot.writeMessageBegin('stage', TMessageType.CALL, self._seqid)
    args = stage_args()
    args.token = token
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stage(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = stage_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "stage failed: unknown result")

  def insertJson(self, json, creds, transaction, environment):
    """
    Parameters:
     - json
     - creds
     - transaction
     - environment
    """
    self.send_insertJson(json, creds, transaction, environment)
    return self.recv_insertJson()

  def send_insertJson(self, json, creds, transaction, environment):
    self._oprot.writeMessageBegin('insertJson', TMessageType.CALL, self._seqid)
    args = insertJson_args()
    args.json = json
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_insertJson(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = insertJson_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "insertJson failed: unknown result")

  def insertJsonRecord(self, json, record, creds, transaction, environment):
    """
    Parameters:
     - json
     - record
     - creds
     - transaction
     - environment
    """
    self.send_insertJsonRecord(json, record, creds, transaction, environment)
    return self.recv_insertJsonRecord()

  def send_insertJsonRecord(self, json, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('insertJsonRecord', TMessageType.CALL, self._seqid)
    args = insertJsonRecord_args()
    args.json = json
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_insertJsonRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = insertJsonRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "insertJsonRecord failed: unknown result")

  def insertJsonRecords(self, json, records, creds, transaction, environment):
    """
    Parameters:
     - json
     - records
     - creds
     - transaction
     - environment
    """
    self.send_insertJsonRecords(json, records, creds, transaction, environment)
    return self.recv_insertJsonRecords()

  def send_insertJsonRecords(self, json, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('insertJsonRecords', TMessageType.CALL, self._seqid)
    args = insertJsonRecords_args()
    args.json = json
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_insertJsonRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = insertJsonRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "insertJsonRecords failed: unknown result")

  def removeKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    self.send_removeKeyValueRecord(key, value, record, creds, transaction, environment)
    return self.recv_removeKeyValueRecord()

  def send_removeKeyValueRecord(self, key, value, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('removeKeyValueRecord', TMessageType.CALL, self._seqid)
    args = removeKeyValueRecord_args()
    args.key = key
    args.value = value
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_removeKeyValueRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = removeKeyValueRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "removeKeyValueRecord failed: unknown result")

  def removeKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    self.send_removeKeyValueRecords(key, value, records, creds, transaction, environment)
    return self.recv_removeKeyValueRecords()

  def send_removeKeyValueRecords(self, key, value, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('removeKeyValueRecords', TMessageType.CALL, self._seqid)
    args = removeKeyValueRecords_args()
    args.key = key
    args.value = value
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_removeKeyValueRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = removeKeyValueRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "removeKeyValueRecords failed: unknown result")

  def setKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    self.send_setKeyValueRecord(key, value, record, creds, transaction, environment)
    self.recv_setKeyValueRecord()

  def send_setKeyValueRecord(self, key, value, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('setKeyValueRecord', TMessageType.CALL, self._seqid)
    args = setKeyValueRecord_args()
    args.key = key
    args.value = value
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setKeyValueRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setKeyValueRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def setKeyValue(self, key, value, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    self.send_setKeyValue(key, value, creds, transaction, environment)
    return self.recv_setKeyValue()

  def send_setKeyValue(self, key, value, creds, transaction, environment):
    self._oprot.writeMessageBegin('setKeyValue', TMessageType.CALL, self._seqid)
    args = setKeyValue_args()
    args.key = key
    args.value = value
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setKeyValue(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setKeyValue_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setKeyValue failed: unknown result")

  def setKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    self.send_setKeyValueRecords(key, value, records, creds, transaction, environment)
    self.recv_setKeyValueRecords()

  def send_setKeyValueRecords(self, key, value, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('setKeyValueRecords', TMessageType.CALL, self._seqid)
    args = setKeyValueRecords_args()
    args.key = key
    args.value = value
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setKeyValueRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setKeyValueRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def reconcileKeyRecordValues(self, key, record, values, creds, transaction, environment):
    """
    The {@code value} in {@code key} of {@code record} are added
    and removed to be set as exactly the same as the input values

    @param key the field name
    @param record the record id where an attempt is made to add the data
    @param values collection of values to set
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a bool that indicates if the data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - record
     - values
     - creds
     - transaction
     - environment
    """
    self.send_reconcileKeyRecordValues(key, record, values, creds, transaction, environment)
    self.recv_reconcileKeyRecordValues()

  def send_reconcileKeyRecordValues(self, key, record, values, creds, transaction, environment):
    self._oprot.writeMessageBegin('reconcileKeyRecordValues', TMessageType.CALL, self._seqid)
    args = reconcileKeyRecordValues_args()
    args.key = key
    args.record = record
    args.values = values
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_reconcileKeyRecordValues(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = reconcileKeyRecordValues_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def inventory(self, creds, transaction, environment):
    """
    Parameters:
     - creds
     - transaction
     - environment
    """
    self.send_inventory(creds, transaction, environment)
    return self.recv_inventory()

  def send_inventory(self, creds, transaction, environment):
    self._oprot.writeMessageBegin('inventory', TMessageType.CALL, self._seqid)
    args = inventory_args()
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_inventory(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = inventory_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "inventory failed: unknown result")

  def selectRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    self.send_selectRecord(record, creds, transaction, environment)
    return self.recv_selectRecord()

  def send_selectRecord(self, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecord', TMessageType.CALL, self._seqid)
    args = selectRecord_args()
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecord failed: unknown result")

  def selectRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    self.send_selectRecords(records, creds, transaction, environment)
    return self.recv_selectRecords()

  def send_selectRecords(self, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecords', TMessageType.CALL, self._seqid)
    args = selectRecords_args()
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecords failed: unknown result")

  def selectRecordTime(self, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectRecordTime(record, timestamp, creds, transaction, environment)
    return self.recv_selectRecordTime()

  def send_selectRecordTime(self, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecordTime', TMessageType.CALL, self._seqid)
    args = selectRecordTime_args()
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecordTime failed: unknown result")

  def selectRecordTimestr(self, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectRecordTimestr(record, timestamp, creds, transaction, environment)
    return self.recv_selectRecordTimestr()

  def send_selectRecordTimestr(self, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecordTimestr', TMessageType.CALL, self._seqid)
    args = selectRecordTimestr_args()
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecordTimestr failed: unknown result")

  def selectRecordsTime(self, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectRecordsTime(records, timestamp, creds, transaction, environment)
    return self.recv_selectRecordsTime()

  def send_selectRecordsTime(self, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecordsTime', TMessageType.CALL, self._seqid)
    args = selectRecordsTime_args()
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecordsTime failed: unknown result")

  def selectRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectRecordsTimestr(records, timestamp, creds, transaction, environment)
    return self.recv_selectRecordsTimestr()

  def send_selectRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecordsTimestr', TMessageType.CALL, self._seqid)
    args = selectRecordsTimestr_args()
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecordsTimestr failed: unknown result")

  def selectKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecord(key, record, creds, transaction, environment)
    return self.recv_selectKeyRecord()

  def send_selectKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecord', TMessageType.CALL, self._seqid)
    args = selectKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecord failed: unknown result")

  def selectKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecordTime(key, record, timestamp, creds, transaction, environment)
    return self.recv_selectKeyRecordTime()

  def send_selectKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecordTime', TMessageType.CALL, self._seqid)
    args = selectKeyRecordTime_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecordTime failed: unknown result")

  def selectKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
    return self.recv_selectKeyRecordTimestr()

  def send_selectKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecordTimestr', TMessageType.CALL, self._seqid)
    args = selectKeyRecordTimestr_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecordTimestr failed: unknown result")

  def selectKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecord(keys, record, creds, transaction, environment)
    return self.recv_selectKeysRecord()

  def send_selectKeysRecord(self, keys, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecord', TMessageType.CALL, self._seqid)
    args = selectKeysRecord_args()
    args.keys = keys
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecord failed: unknown result")

  def selectKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecordTime(keys, record, timestamp, creds, transaction, environment)
    return self.recv_selectKeysRecordTime()

  def send_selectKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecordTime', TMessageType.CALL, self._seqid)
    args = selectKeysRecordTime_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecordTime failed: unknown result")

  def selectKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecordTimestr(keys, record, timestamp, creds, transaction, environment)
    return self.recv_selectKeysRecordTimestr()

  def send_selectKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecordTimestr', TMessageType.CALL, self._seqid)
    args = selectKeysRecordTimestr_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecordTimestr failed: unknown result")

  def selectKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecords(keys, records, creds, transaction, environment)
    return self.recv_selectKeysRecords()

  def send_selectKeysRecords(self, keys, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecords', TMessageType.CALL, self._seqid)
    args = selectKeysRecords_args()
    args.keys = keys
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecords failed: unknown result")

  def selectKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecords(key, records, creds, transaction, environment)
    return self.recv_selectKeyRecords()

  def send_selectKeyRecords(self, key, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecords', TMessageType.CALL, self._seqid)
    args = selectKeyRecords_args()
    args.key = key
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecords failed: unknown result")

  def selectKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
    return self.recv_selectKeyRecordsTime()

  def send_selectKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecordsTime', TMessageType.CALL, self._seqid)
    args = selectKeyRecordsTime_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecordsTime failed: unknown result")

  def selectKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
    return self.recv_selectKeyRecordsTimestr()

  def send_selectKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = selectKeyRecordsTimestr_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecordsTimestr failed: unknown result")

  def selectKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecordsTime(keys, records, timestamp, creds, transaction, environment)
    return self.recv_selectKeysRecordsTime()

  def send_selectKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecordsTime', TMessageType.CALL, self._seqid)
    args = selectKeysRecordsTime_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecordsTime failed: unknown result")

  def selectKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecordsTimestr(keys, records, timestamp, creds, transaction, environment)
    return self.recv_selectKeysRecordsTimestr()

  def send_selectKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecordsTimestr', TMessageType.CALL, self._seqid)
    args = selectKeysRecordsTimestr_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecordsTimestr failed: unknown result")

  def selectCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_selectCriteria(criteria, creds, transaction, environment)
    return self.recv_selectCriteria()

  def send_selectCriteria(self, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCriteria', TMessageType.CALL, self._seqid)
    args = selectCriteria_args()
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCriteria failed: unknown result")

  def selectCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_selectCcl(ccl, creds, transaction, environment)
    return self.recv_selectCcl()

  def send_selectCcl(self, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCcl', TMessageType.CALL, self._seqid)
    args = selectCcl_args()
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCcl failed: unknown result")

  def selectCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectCriteriaTime(criteria, timestamp, creds, transaction, environment)
    return self.recv_selectCriteriaTime()

  def send_selectCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCriteriaTime', TMessageType.CALL, self._seqid)
    args = selectCriteriaTime_args()
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCriteriaTime failed: unknown result")

  def selectCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectCriteriaTimestr(criteria, timestamp, creds, transaction, environment)
    return self.recv_selectCriteriaTimestr()

  def send_selectCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = selectCriteriaTimestr_args()
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCriteriaTimestr failed: unknown result")

  def selectCclTime(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectCclTime(ccl, timestamp, creds, transaction, environment)
    return self.recv_selectCclTime()

  def send_selectCclTime(self, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCclTime', TMessageType.CALL, self._seqid)
    args = selectCclTime_args()
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCclTime failed: unknown result")

  def selectCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectCclTimestr(ccl, timestamp, creds, transaction, environment)
    return self.recv_selectCclTimestr()

  def send_selectCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCclTimestr', TMessageType.CALL, self._seqid)
    args = selectCclTimestr_args()
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCclTimestr failed: unknown result")

  def selectKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCriteria(key, criteria, creds, transaction, environment)
    return self.recv_selectKeyCriteria()

  def send_selectKeyCriteria(self, key, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCriteria', TMessageType.CALL, self._seqid)
    args = selectKeyCriteria_args()
    args.key = key
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCriteria failed: unknown result")

  def selectKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCcl(key, ccl, creds, transaction, environment)
    return self.recv_selectKeyCcl()

  def send_selectKeyCcl(self, key, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCcl', TMessageType.CALL, self._seqid)
    args = selectKeyCcl_args()
    args.key = key
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCcl failed: unknown result")

  def selectKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_selectKeyCriteriaTime()

  def send_selectKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCriteriaTime', TMessageType.CALL, self._seqid)
    args = selectKeyCriteriaTime_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCriteriaTime failed: unknown result")

  def selectKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_selectKeyCriteriaTimestr()

  def send_selectKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = selectKeyCriteriaTimestr_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCriteriaTimestr failed: unknown result")

  def selectKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_selectKeyCclTime()

  def send_selectKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCclTime', TMessageType.CALL, self._seqid)
    args = selectKeyCclTime_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCclTime failed: unknown result")

  def selectKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_selectKeyCclTimestr()

  def send_selectKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCclTimestr', TMessageType.CALL, self._seqid)
    args = selectKeyCclTimestr_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCclTimestr failed: unknown result")

  def selectKeysCriteria(self, keys, criteria, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCriteria(keys, criteria, creds, transaction, environment)
    return self.recv_selectKeysCriteria()

  def send_selectKeysCriteria(self, keys, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCriteria', TMessageType.CALL, self._seqid)
    args = selectKeysCriteria_args()
    args.keys = keys
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCriteria failed: unknown result")

  def selectKeysCcl(self, keys, ccl, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCcl(keys, ccl, creds, transaction, environment)
    return self.recv_selectKeysCcl()

  def send_selectKeysCcl(self, keys, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCcl', TMessageType.CALL, self._seqid)
    args = selectKeysCcl_args()
    args.keys = keys
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCcl failed: unknown result")

  def selectKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCriteriaTime(keys, criteria, timestamp, creds, transaction, environment)
    return self.recv_selectKeysCriteriaTime()

  def send_selectKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCriteriaTime', TMessageType.CALL, self._seqid)
    args = selectKeysCriteriaTime_args()
    args.keys = keys
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCriteriaTime failed: unknown result")

  def selectKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCriteriaTimestr(keys, criteria, timestamp, creds, transaction, environment)
    return self.recv_selectKeysCriteriaTimestr()

  def send_selectKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = selectKeysCriteriaTimestr_args()
    args.keys = keys
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCriteriaTimestr failed: unknown result")

  def selectKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCclTime(keys, ccl, timestamp, creds, transaction, environment)
    return self.recv_selectKeysCclTime()

  def send_selectKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCclTime', TMessageType.CALL, self._seqid)
    args = selectKeysCclTime_args()
    args.keys = keys
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCclTime failed: unknown result")

  def selectKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCclTimestr(keys, ccl, timestamp, creds, transaction, environment)
    return self.recv_selectKeysCclTimestr()

  def send_selectKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCclTimestr', TMessageType.CALL, self._seqid)
    args = selectKeysCclTimestr_args()
    args.keys = keys
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCclTimestr failed: unknown result")

  def getKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecord(key, record, creds, transaction, environment)
    return self.recv_getKeyRecord()

  def send_getKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecord', TMessageType.CALL, self._seqid)
    args = getKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecord failed: unknown result")

  def getKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecordTime(key, record, timestamp, creds, transaction, environment)
    return self.recv_getKeyRecordTime()

  def send_getKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecordTime', TMessageType.CALL, self._seqid)
    args = getKeyRecordTime_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecordTime failed: unknown result")

  def getKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
    return self.recv_getKeyRecordTimestr()

  def send_getKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecordTimestr', TMessageType.CALL, self._seqid)
    args = getKeyRecordTimestr_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecordTimestr failed: unknown result")

  def getKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecord(keys, record, creds, transaction, environment)
    return self.recv_getKeysRecord()

  def send_getKeysRecord(self, keys, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecord', TMessageType.CALL, self._seqid)
    args = getKeysRecord_args()
    args.keys = keys
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecord failed: unknown result")

  def getKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecordTime(keys, record, timestamp, creds, transaction, environment)
    return self.recv_getKeysRecordTime()

  def send_getKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecordTime', TMessageType.CALL, self._seqid)
    args = getKeysRecordTime_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecordTime failed: unknown result")

  def getKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecordTimestr(keys, record, timestamp, creds, transaction, environment)
    return self.recv_getKeysRecordTimestr()

  def send_getKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecordTimestr', TMessageType.CALL, self._seqid)
    args = getKeysRecordTimestr_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecordTimestr failed: unknown result")

  def getKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecords(keys, records, creds, transaction, environment)
    return self.recv_getKeysRecords()

  def send_getKeysRecords(self, keys, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecords', TMessageType.CALL, self._seqid)
    args = getKeysRecords_args()
    args.keys = keys
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecords failed: unknown result")

  def getKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecords(key, records, creds, transaction, environment)
    return self.recv_getKeyRecords()

  def send_getKeyRecords(self, key, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecords', TMessageType.CALL, self._seqid)
    args = getKeyRecords_args()
    args.key = key
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecords failed: unknown result")

  def getKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
    return self.recv_getKeyRecordsTime()

  def send_getKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecordsTime', TMessageType.CALL, self._seqid)
    args = getKeyRecordsTime_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecordsTime failed: unknown result")

  def getKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
    return self.recv_getKeyRecordsTimestr()

  def send_getKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = getKeyRecordsTimestr_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecordsTimestr failed: unknown result")

  def getKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecordsTime(keys, records, timestamp, creds, transaction, environment)
    return self.recv_getKeysRecordsTime()

  def send_getKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecordsTime', TMessageType.CALL, self._seqid)
    args = getKeysRecordsTime_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecordsTime failed: unknown result")

  def getKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecordsTimestr(keys, records, timestamp, creds, transaction, environment)
    return self.recv_getKeysRecordsTimestr()

  def send_getKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecordsTimestr', TMessageType.CALL, self._seqid)
    args = getKeysRecordsTimestr_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecordsTimestr failed: unknown result")

  def getKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCriteria(key, criteria, creds, transaction, environment)
    return self.recv_getKeyCriteria()

  def send_getKeyCriteria(self, key, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCriteria', TMessageType.CALL, self._seqid)
    args = getKeyCriteria_args()
    args.key = key
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCriteria failed: unknown result")

  def getCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_getCriteria(criteria, creds, transaction, environment)
    return self.recv_getCriteria()

  def send_getCriteria(self, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCriteria', TMessageType.CALL, self._seqid)
    args = getCriteria_args()
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCriteria failed: unknown result")

  def getCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_getCcl(ccl, creds, transaction, environment)
    return self.recv_getCcl()

  def send_getCcl(self, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCcl', TMessageType.CALL, self._seqid)
    args = getCcl_args()
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCcl failed: unknown result")

  def getCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getCriteriaTime(criteria, timestamp, creds, transaction, environment)
    return self.recv_getCriteriaTime()

  def send_getCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCriteriaTime', TMessageType.CALL, self._seqid)
    args = getCriteriaTime_args()
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCriteriaTime failed: unknown result")

  def getCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getCriteriaTimestr(criteria, timestamp, creds, transaction, environment)
    return self.recv_getCriteriaTimestr()

  def send_getCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = getCriteriaTimestr_args()
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCriteriaTimestr failed: unknown result")

  def getCclTime(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getCclTime(ccl, timestamp, creds, transaction, environment)
    return self.recv_getCclTime()

  def send_getCclTime(self, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCclTime', TMessageType.CALL, self._seqid)
    args = getCclTime_args()
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCclTime failed: unknown result")

  def getCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getCclTimestr(ccl, timestamp, creds, transaction, environment)
    return self.recv_getCclTimestr()

  def send_getCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCclTimestr', TMessageType.CALL, self._seqid)
    args = getCclTimestr_args()
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCclTimestr failed: unknown result")

  def getKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCcl(key, ccl, creds, transaction, environment)
    return self.recv_getKeyCcl()

  def send_getKeyCcl(self, key, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCcl', TMessageType.CALL, self._seqid)
    args = getKeyCcl_args()
    args.key = key
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCcl failed: unknown result")

  def getKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_getKeyCriteriaTime()

  def send_getKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCriteriaTime', TMessageType.CALL, self._seqid)
    args = getKeyCriteriaTime_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCriteriaTime failed: unknown result")

  def getKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_getKeyCriteriaTimestr()

  def send_getKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = getKeyCriteriaTimestr_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCriteriaTimestr failed: unknown result")

  def getKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_getKeyCclTime()

  def send_getKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCclTime', TMessageType.CALL, self._seqid)
    args = getKeyCclTime_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCclTime failed: unknown result")

  def getKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_getKeyCclTimestr()

  def send_getKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCclTimestr', TMessageType.CALL, self._seqid)
    args = getKeyCclTimestr_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCclTimestr failed: unknown result")

  def getKeysCriteria(self, keys, criteria, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCriteria(keys, criteria, creds, transaction, environment)
    return self.recv_getKeysCriteria()

  def send_getKeysCriteria(self, keys, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCriteria', TMessageType.CALL, self._seqid)
    args = getKeysCriteria_args()
    args.keys = keys
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCriteria failed: unknown result")

  def getKeysCcl(self, keys, ccl, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCcl(keys, ccl, creds, transaction, environment)
    return self.recv_getKeysCcl()

  def send_getKeysCcl(self, keys, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCcl', TMessageType.CALL, self._seqid)
    args = getKeysCcl_args()
    args.keys = keys
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCcl failed: unknown result")

  def getKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCriteriaTime(keys, criteria, timestamp, creds, transaction, environment)
    return self.recv_getKeysCriteriaTime()

  def send_getKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCriteriaTime', TMessageType.CALL, self._seqid)
    args = getKeysCriteriaTime_args()
    args.keys = keys
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCriteriaTime failed: unknown result")

  def getKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCriteriaTimestr(keys, criteria, timestamp, creds, transaction, environment)
    return self.recv_getKeysCriteriaTimestr()

  def send_getKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = getKeysCriteriaTimestr_args()
    args.keys = keys
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCriteriaTimestr failed: unknown result")

  def getKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCclTime(keys, ccl, timestamp, creds, transaction, environment)
    return self.recv_getKeysCclTime()

  def send_getKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCclTime', TMessageType.CALL, self._seqid)
    args = getKeysCclTime_args()
    args.keys = keys
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCclTime failed: unknown result")

  def getKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCclTimestr(keys, ccl, timestamp, creds, transaction, environment)
    return self.recv_getKeysCclTimestr()

  def send_getKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCclTimestr', TMessageType.CALL, self._seqid)
    args = getKeysCclTimestr_args()
    args.keys = keys
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCclTimestr failed: unknown result")

  def verifyKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    self.send_verifyKeyValueRecord(key, value, record, creds, transaction, environment)
    return self.recv_verifyKeyValueRecord()

  def send_verifyKeyValueRecord(self, key, value, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('verifyKeyValueRecord', TMessageType.CALL, self._seqid)
    args = verifyKeyValueRecord_args()
    args.key = key
    args.value = value
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyKeyValueRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = verifyKeyValueRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyKeyValueRecord failed: unknown result")

  def verifyKeyValueRecordTime(self, key, value, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_verifyKeyValueRecordTime(key, value, record, timestamp, creds, transaction, environment)
    return self.recv_verifyKeyValueRecordTime()

  def send_verifyKeyValueRecordTime(self, key, value, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('verifyKeyValueRecordTime', TMessageType.CALL, self._seqid)
    args = verifyKeyValueRecordTime_args()
    args.key = key
    args.value = value
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyKeyValueRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = verifyKeyValueRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyKeyValueRecordTime failed: unknown result")

  def verifyKeyValueRecordTimestr(self, key, value, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_verifyKeyValueRecordTimestr(key, value, record, timestamp, creds, transaction, environment)
    return self.recv_verifyKeyValueRecordTimestr()

  def send_verifyKeyValueRecordTimestr(self, key, value, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('verifyKeyValueRecordTimestr', TMessageType.CALL, self._seqid)
    args = verifyKeyValueRecordTimestr_args()
    args.key = key
    args.value = value
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyKeyValueRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = verifyKeyValueRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyKeyValueRecordTimestr failed: unknown result")

  def jsonifyRecords(self, records, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - identifier
     - creds
     - transaction
     - environment
    """
    self.send_jsonifyRecords(records, identifier, creds, transaction, environment)
    return self.recv_jsonifyRecords()

  def send_jsonifyRecords(self, records, identifier, creds, transaction, environment):
    self._oprot.writeMessageBegin('jsonifyRecords', TMessageType.CALL, self._seqid)
    args = jsonifyRecords_args()
    args.records = records
    args.identifier = identifier
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_jsonifyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = jsonifyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "jsonifyRecords failed: unknown result")

  def jsonifyRecordsTime(self, records, timestamp, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - identifier
     - creds
     - transaction
     - environment
    """
    self.send_jsonifyRecordsTime(records, timestamp, identifier, creds, transaction, environment)
    return self.recv_jsonifyRecordsTime()

  def send_jsonifyRecordsTime(self, records, timestamp, identifier, creds, transaction, environment):
    self._oprot.writeMessageBegin('jsonifyRecordsTime', TMessageType.CALL, self._seqid)
    args = jsonifyRecordsTime_args()
    args.records = records
    args.timestamp = timestamp
    args.identifier = identifier
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_jsonifyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = jsonifyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "jsonifyRecordsTime failed: unknown result")

  def jsonifyRecordsTimestr(self, records, timestamp, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - identifier
     - creds
     - transaction
     - environment
    """
    self.send_jsonifyRecordsTimestr(records, timestamp, identifier, creds, transaction, environment)
    return self.recv_jsonifyRecordsTimestr()

  def send_jsonifyRecordsTimestr(self, records, timestamp, identifier, creds, transaction, environment):
    self._oprot.writeMessageBegin('jsonifyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = jsonifyRecordsTimestr_args()
    args.records = records
    args.timestamp = timestamp
    args.identifier = identifier
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_jsonifyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = jsonifyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "jsonifyRecordsTimestr failed: unknown result")

  def findCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_findCriteria(criteria, creds, transaction, environment)
    return self.recv_findCriteria()

  def send_findCriteria(self, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('findCriteria', TMessageType.CALL, self._seqid)
    args = findCriteria_args()
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findCriteria failed: unknown result")

  def findCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_findCcl(ccl, creds, transaction, environment)
    return self.recv_findCcl()

  def send_findCcl(self, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('findCcl', TMessageType.CALL, self._seqid)
    args = findCcl_args()
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findCcl failed: unknown result")

  def findKeyOperatorValues(self, key, operator, values, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorValues(key, operator, values, creds, transaction, environment)
    return self.recv_findKeyOperatorValues()

  def send_findKeyOperatorValues(self, key, operator, values, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorValues', TMessageType.CALL, self._seqid)
    args = findKeyOperatorValues_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorValues(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorValues_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorValues failed: unknown result")

  def findKeyOperatorValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorValuesTime(key, operator, values, timestamp, creds, transaction, environment)
    return self.recv_findKeyOperatorValuesTime()

  def send_findKeyOperatorValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorValuesTime', TMessageType.CALL, self._seqid)
    args = findKeyOperatorValuesTime_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorValuesTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorValuesTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorValuesTime failed: unknown result")

  def findKeyOperatorValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorValuesTimestr(key, operator, values, timestamp, creds, transaction, environment)
    return self.recv_findKeyOperatorValuesTimestr()

  def send_findKeyOperatorValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorValuesTimestr', TMessageType.CALL, self._seqid)
    args = findKeyOperatorValuesTimestr_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorValuesTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorValuesTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorValuesTimestr failed: unknown result")

  def findKeyOperatorstrValues(self, key, operator, values, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorstrValues(key, operator, values, creds, transaction, environment)
    return self.recv_findKeyOperatorstrValues()

  def send_findKeyOperatorstrValues(self, key, operator, values, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorstrValues', TMessageType.CALL, self._seqid)
    args = findKeyOperatorstrValues_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorstrValues(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorstrValues_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorstrValues failed: unknown result")

  def findKeyOperatorstrValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorstrValuesTime(key, operator, values, timestamp, creds, transaction, environment)
    return self.recv_findKeyOperatorstrValuesTime()

  def send_findKeyOperatorstrValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorstrValuesTime', TMessageType.CALL, self._seqid)
    args = findKeyOperatorstrValuesTime_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorstrValuesTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorstrValuesTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorstrValuesTime failed: unknown result")

  def findKeyOperatorstrValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorstrValuesTimestr(key, operator, values, timestamp, creds, transaction, environment)
    return self.recv_findKeyOperatorstrValuesTimestr()

  def send_findKeyOperatorstrValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorstrValuesTimestr', TMessageType.CALL, self._seqid)
    args = findKeyOperatorstrValuesTimestr_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorstrValuesTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorstrValuesTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorstrValuesTimestr failed: unknown result")

  def search(self, key, query, creds, transaction, environment):
    """
    Parameters:
     - key
     - query
     - creds
     - transaction
     - environment
    """
    self.send_search(key, query, creds, transaction, environment)
    return self.recv_search()

  def send_search(self, key, query, creds, transaction, environment):
    self._oprot.writeMessageBegin('search', TMessageType.CALL, self._seqid)
    args = search_args()
    args.key = key
    args.query = query
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_search(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = search_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "search failed: unknown result")

  def revertKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeysRecordsTime(keys, records, timestamp, creds, transaction, environment)
    self.recv_revertKeysRecordsTime()

  def send_revertKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeysRecordsTime', TMessageType.CALL, self._seqid)
    args = revertKeysRecordsTime_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeysRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeysRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def revertKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeysRecordsTimestr(keys, records, timestamp, creds, transaction, environment)
    self.recv_revertKeysRecordsTimestr()

  def send_revertKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeysRecordsTimestr', TMessageType.CALL, self._seqid)
    args = revertKeysRecordsTimestr_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeysRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeysRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def revertKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeysRecordTime(keys, record, timestamp, creds, transaction, environment)
    self.recv_revertKeysRecordTime()

  def send_revertKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeysRecordTime', TMessageType.CALL, self._seqid)
    args = revertKeysRecordTime_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeysRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeysRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def revertKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeysRecordTimestr(keys, record, timestamp, creds, transaction, environment)
    self.recv_revertKeysRecordTimestr()

  def send_revertKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeysRecordTimestr', TMessageType.CALL, self._seqid)
    args = revertKeysRecordTimestr_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeysRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeysRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def revertKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
    self.recv_revertKeyRecordsTime()

  def send_revertKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeyRecordsTime', TMessageType.CALL, self._seqid)
    args = revertKeyRecordsTime_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def revertKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
    self.recv_revertKeyRecordsTimestr()

  def send_revertKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = revertKeyRecordsTimestr_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def revertKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeyRecordTime(key, record, timestamp, creds, transaction, environment)
    self.recv_revertKeyRecordTime()

  def send_revertKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeyRecordTime', TMessageType.CALL, self._seqid)
    args = revertKeyRecordTime_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeyRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeyRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def revertKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
    self.recv_revertKeyRecordTimestr()

  def send_revertKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeyRecordTimestr', TMessageType.CALL, self._seqid)
    args = revertKeyRecordTimestr_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeyRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeyRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def pingRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    self.send_pingRecords(records, creds, transaction, environment)
    return self.recv_pingRecords()

  def send_pingRecords(self, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('pingRecords', TMessageType.CALL, self._seqid)
    args = pingRecords_args()
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_pingRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = pingRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "pingRecords failed: unknown result")

  def pingRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    self.send_pingRecord(record, creds, transaction, environment)
    return self.recv_pingRecord()

  def send_pingRecord(self, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('pingRecord', TMessageType.CALL, self._seqid)
    args = pingRecord_args()
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_pingRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = pingRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "pingRecord failed: unknown result")

  def verifyAndSwap(self, key, expected, record, replacement, creds, transaction, environment):
    """
    Parameters:
     - key
     - expected
     - record
     - replacement
     - creds
     - transaction
     - environment
    """
    self.send_verifyAndSwap(key, expected, record, replacement, creds, transaction, environment)
    return self.recv_verifyAndSwap()

  def send_verifyAndSwap(self, key, expected, record, replacement, creds, transaction, environment):
    self._oprot.writeMessageBegin('verifyAndSwap', TMessageType.CALL, self._seqid)
    args = verifyAndSwap_args()
    args.key = key
    args.expected = expected
    args.record = record
    args.replacement = replacement
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyAndSwap(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = verifyAndSwap_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyAndSwap failed: unknown result")

  def verifyOrSet(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    self.send_verifyOrSet(key, value, record, creds, transaction, environment)
    self.recv_verifyOrSet()

  def send_verifyOrSet(self, key, value, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('verifyOrSet', TMessageType.CALL, self._seqid)
    args = verifyOrSet_args()
    args.key = key
    args.value = value
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyOrSet(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = verifyOrSet_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def findOrAddKeyValue(self, key, value, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    self.send_findOrAddKeyValue(key, value, creds, transaction, environment)
    return self.recv_findOrAddKeyValue()

  def send_findOrAddKeyValue(self, key, value, creds, transaction, environment):
    self._oprot.writeMessageBegin('findOrAddKeyValue', TMessageType.CALL, self._seqid)
    args = findOrAddKeyValue_args()
    args.key = key
    args.value = value
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findOrAddKeyValue(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findOrAddKeyValue_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    if result.ex4 is not None:
      raise result.ex4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findOrAddKeyValue failed: unknown result")

  def findOrInsertCriteriaJson(self, criteria, json, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - json
     - creds
     - transaction
     - environment
    """
    self.send_findOrInsertCriteriaJson(criteria, json, creds, transaction, environment)
    return self.recv_findOrInsertCriteriaJson()

  def send_findOrInsertCriteriaJson(self, criteria, json, creds, transaction, environment):
    self._oprot.writeMessageBegin('findOrInsertCriteriaJson', TMessageType.CALL, self._seqid)
    args = findOrInsertCriteriaJson_args()
    args.criteria = criteria
    args.json = json
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findOrInsertCriteriaJson(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findOrInsertCriteriaJson_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findOrInsertCriteriaJson failed: unknown result")

  def findOrInsertCclJson(self, ccl, json, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - json
     - creds
     - transaction
     - environment
    """
    self.send_findOrInsertCclJson(ccl, json, creds, transaction, environment)
    return self.recv_findOrInsertCclJson()

  def send_findOrInsertCclJson(self, ccl, json, creds, transaction, environment):
    self._oprot.writeMessageBegin('findOrInsertCclJson', TMessageType.CALL, self._seqid)
    args = findOrInsertCclJson_args()
    args.ccl = ccl
    args.json = json
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findOrInsertCclJson(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findOrInsertCclJson_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    if result.ex4 is not None:
      raise result.ex4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findOrInsertCclJson failed: unknown result")

  def sumKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_sumKeyRecord(key, record, creds, transaction, environment)
    return self.recv_sumKeyRecord()

  def send_sumKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('sumKeyRecord', TMessageType.CALL, self._seqid)
    args = sumKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sumKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = sumKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyRecord failed: unknown result")

  def sumKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_sumKeyRecordTime(key, record, timestamp, creds, transaction, environment)
    return self.recv_sumKeyRecordTime()

  def send_sumKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('sumKeyRecordTime', TMessageType.CALL, self._seqid)
    args = sumKeyRecordTime_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sumKeyRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = sumKeyRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyRecordTime failed: unknown result")

  def sumKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_sumKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
    return self.recv_sumKeyRecordTimestr()

  def send_sumKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('sumKeyRecordTimestr', TMessageType.CALL, self._seqid)
    args = sumKeyRecordTimestr_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sumKeyRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = sumKeyRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyRecordTimestr failed: unknown result")

  def sumKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    self.send_sumKeyRecords(key, records, creds, transaction, environment)
    return self.recv_sumKeyRecords()

  def send_sumKeyRecords(self, key, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('sumKeyRecords', TMessageType.CALL, self._seqid)
    args = sumKeyRecords_args()
    args.key = key
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sumKeyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = sumKeyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyRecords failed: unknown result")

  def sumKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_sumKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
    return self.recv_sumKeyRecordsTime()

  def send_sumKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('sumKeyRecordsTime', TMessageType.CALL, self._seqid)
    args = sumKeyRecordsTime_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sumKeyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = sumKeyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyRecordsTime failed: unknown result")

  def sumKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_sumKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
    return self.recv_sumKeyRecordsTimestr()

  def send_sumKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('sumKeyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = sumKeyRecordsTimestr_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sumKeyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = sumKeyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyRecordsTimestr failed: unknown result")

  def sumKey(self, key, creds, transaction, environment):
    """
    Parameters:
     - key
     - creds
     - transaction
     - environment
    """
    self.send_sumKey(key, creds, transaction, environment)
    return self.recv_sumKey()

  def send_sumKey(self, key, creds, transaction, environment):
    self._oprot.writeMessageBegin('sumKey', TMessageType.CALL, self._seqid)
    args = sumKey_args()
    args.key = key
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sumKey(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = sumKey_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKey failed: unknown result")

  def sumKeyTime(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_sumKeyTime(key, timestamp, creds, transaction, environment)
    return self.recv_sumKeyTime()

  def send_sumKeyTime(self, key, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('sumKeyTime', TMessageType.CALL, self._seqid)
    args = sumKeyTime_args()
    args.key = key
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sumKeyTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = sumKeyTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyTime failed: unknown result")

  def sumKeyTimestr(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_sumKeyTimestr(key, timestamp, creds, transaction, environment)
    return self.recv_sumKeyTimestr()

  def send_sumKeyTimestr(self, key, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('sumKeyTimestr', TMessageType.CALL, self._seqid)
    args = sumKeyTimestr_args()
    args.key = key
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sumKeyTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = sumKeyTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyTimestr failed: unknown result")

  def sumKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_sumKeyCriteria(key, criteria, creds, transaction, environment)
    return self.recv_sumKeyCriteria()

  def send_sumKeyCriteria(self, key, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('sumKeyCriteria', TMessageType.CALL, self._seqid)
    args = sumKeyCriteria_args()
    args.key = key
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sumKeyCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = sumKeyCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyCriteria failed: unknown result")

  def sumKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_sumKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_sumKeyCriteriaTime()

  def send_sumKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('sumKeyCriteriaTime', TMessageType.CALL, self._seqid)
    args = sumKeyCriteriaTime_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sumKeyCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = sumKeyCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyCriteriaTime failed: unknown result")

  def sumKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_sumKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_sumKeyCriteriaTimestr()

  def send_sumKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('sumKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = sumKeyCriteriaTimestr_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sumKeyCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = sumKeyCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyCriteriaTimestr failed: unknown result")

  def sumKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_sumKeyCcl(key, ccl, creds, transaction, environment)
    return self.recv_sumKeyCcl()

  def send_sumKeyCcl(self, key, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('sumKeyCcl', TMessageType.CALL, self._seqid)
    args = sumKeyCcl_args()
    args.key = key
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sumKeyCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = sumKeyCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyCcl failed: unknown result")

  def sumKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_sumKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_sumKeyCclTime()

  def send_sumKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('sumKeyCclTime', TMessageType.CALL, self._seqid)
    args = sumKeyCclTime_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sumKeyCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = sumKeyCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyCclTime failed: unknown result")

  def sumKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_sumKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_sumKeyCclTimestr()

  def send_sumKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('sumKeyCclTimestr', TMessageType.CALL, self._seqid)
    args = sumKeyCclTimestr_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sumKeyCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = sumKeyCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sumKeyCclTimestr failed: unknown result")

  def averageKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_averageKeyRecord(key, record, creds, transaction, environment)
    return self.recv_averageKeyRecord()

  def send_averageKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('averageKeyRecord', TMessageType.CALL, self._seqid)
    args = averageKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_averageKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = averageKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyRecord failed: unknown result")

  def averageKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_averageKeyRecordTime(key, record, timestamp, creds, transaction, environment)
    return self.recv_averageKeyRecordTime()

  def send_averageKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('averageKeyRecordTime', TMessageType.CALL, self._seqid)
    args = averageKeyRecordTime_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_averageKeyRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = averageKeyRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyRecordTime failed: unknown result")

  def averageKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_averageKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
    return self.recv_averageKeyRecordTimestr()

  def send_averageKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('averageKeyRecordTimestr', TMessageType.CALL, self._seqid)
    args = averageKeyRecordTimestr_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_averageKeyRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = averageKeyRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyRecordTimestr failed: unknown result")

  def averageKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    self.send_averageKeyRecords(key, records, creds, transaction, environment)
    return self.recv_averageKeyRecords()

  def send_averageKeyRecords(self, key, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('averageKeyRecords', TMessageType.CALL, self._seqid)
    args = averageKeyRecords_args()
    args.key = key
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_averageKeyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = averageKeyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyRecords failed: unknown result")

  def averageKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_averageKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
    return self.recv_averageKeyRecordsTime()

  def send_averageKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('averageKeyRecordsTime', TMessageType.CALL, self._seqid)
    args = averageKeyRecordsTime_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_averageKeyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = averageKeyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyRecordsTime failed: unknown result")

  def averageKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_averageKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
    return self.recv_averageKeyRecordsTimestr()

  def send_averageKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('averageKeyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = averageKeyRecordsTimestr_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_averageKeyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = averageKeyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyRecordsTimestr failed: unknown result")

  def averageKey(self, key, creds, transaction, environment):
    """
    Parameters:
     - key
     - creds
     - transaction
     - environment
    """
    self.send_averageKey(key, creds, transaction, environment)
    return self.recv_averageKey()

  def send_averageKey(self, key, creds, transaction, environment):
    self._oprot.writeMessageBegin('averageKey', TMessageType.CALL, self._seqid)
    args = averageKey_args()
    args.key = key
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_averageKey(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = averageKey_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKey failed: unknown result")

  def averageKeyTime(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_averageKeyTime(key, timestamp, creds, transaction, environment)
    return self.recv_averageKeyTime()

  def send_averageKeyTime(self, key, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('averageKeyTime', TMessageType.CALL, self._seqid)
    args = averageKeyTime_args()
    args.key = key
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_averageKeyTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = averageKeyTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyTime failed: unknown result")

  def averageKeyTimestr(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_averageKeyTimestr(key, timestamp, creds, transaction, environment)
    return self.recv_averageKeyTimestr()

  def send_averageKeyTimestr(self, key, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('averageKeyTimestr', TMessageType.CALL, self._seqid)
    args = averageKeyTimestr_args()
    args.key = key
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_averageKeyTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = averageKeyTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyTimestr failed: unknown result")

  def averageKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_averageKeyCriteria(key, criteria, creds, transaction, environment)
    return self.recv_averageKeyCriteria()

  def send_averageKeyCriteria(self, key, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('averageKeyCriteria', TMessageType.CALL, self._seqid)
    args = averageKeyCriteria_args()
    args.key = key
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_averageKeyCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = averageKeyCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyCriteria failed: unknown result")

  def averageKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_averageKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_averageKeyCriteriaTime()

  def send_averageKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('averageKeyCriteriaTime', TMessageType.CALL, self._seqid)
    args = averageKeyCriteriaTime_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_averageKeyCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = averageKeyCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyCriteriaTime failed: unknown result")

  def averageKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_averageKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_averageKeyCriteriaTimestr()

  def send_averageKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('averageKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = averageKeyCriteriaTimestr_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_averageKeyCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = averageKeyCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyCriteriaTimestr failed: unknown result")

  def averageKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_averageKeyCcl(key, ccl, creds, transaction, environment)
    return self.recv_averageKeyCcl()

  def send_averageKeyCcl(self, key, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('averageKeyCcl', TMessageType.CALL, self._seqid)
    args = averageKeyCcl_args()
    args.key = key
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_averageKeyCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = averageKeyCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyCcl failed: unknown result")

  def averageKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_averageKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_averageKeyCclTime()

  def send_averageKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('averageKeyCclTime', TMessageType.CALL, self._seqid)
    args = averageKeyCclTime_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_averageKeyCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = averageKeyCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyCclTime failed: unknown result")

  def averageKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_averageKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_averageKeyCclTimestr()

  def send_averageKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('averageKeyCclTimestr', TMessageType.CALL, self._seqid)
    args = averageKeyCclTimestr_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_averageKeyCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = averageKeyCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "averageKeyCclTimestr failed: unknown result")

  def countKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_countKeyRecord(key, record, creds, transaction, environment)
    return self.recv_countKeyRecord()

  def send_countKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('countKeyRecord', TMessageType.CALL, self._seqid)
    args = countKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_countKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = countKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyRecord failed: unknown result")

  def countKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_countKeyRecordTime(key, record, timestamp, creds, transaction, environment)
    return self.recv_countKeyRecordTime()

  def send_countKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('countKeyRecordTime', TMessageType.CALL, self._seqid)
    args = countKeyRecordTime_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_countKeyRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = countKeyRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyRecordTime failed: unknown result")

  def countKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_countKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
    return self.recv_countKeyRecordTimestr()

  def send_countKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('countKeyRecordTimestr', TMessageType.CALL, self._seqid)
    args = countKeyRecordTimestr_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_countKeyRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = countKeyRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyRecordTimestr failed: unknown result")

  def countKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    self.send_countKeyRecords(key, records, creds, transaction, environment)
    return self.recv_countKeyRecords()

  def send_countKeyRecords(self, key, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('countKeyRecords', TMessageType.CALL, self._seqid)
    args = countKeyRecords_args()
    args.key = key
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_countKeyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = countKeyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyRecords failed: unknown result")

  def countKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_countKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
    return self.recv_countKeyRecordsTime()

  def send_countKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('countKeyRecordsTime', TMessageType.CALL, self._seqid)
    args = countKeyRecordsTime_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_countKeyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = countKeyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyRecordsTime failed: unknown result")

  def countKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_countKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
    return self.recv_countKeyRecordsTimestr()

  def send_countKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('countKeyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = countKeyRecordsTimestr_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_countKeyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = countKeyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyRecordsTimestr failed: unknown result")

  def countKey(self, key, creds, transaction, environment):
    """
    Parameters:
     - key
     - creds
     - transaction
     - environment
    """
    self.send_countKey(key, creds, transaction, environment)
    return self.recv_countKey()

  def send_countKey(self, key, creds, transaction, environment):
    self._oprot.writeMessageBegin('countKey', TMessageType.CALL, self._seqid)
    args = countKey_args()
    args.key = key
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_countKey(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = countKey_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "countKey failed: unknown result")

  def countKeyTime(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_countKeyTime(key, timestamp, creds, transaction, environment)
    return self.recv_countKeyTime()

  def send_countKeyTime(self, key, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('countKeyTime', TMessageType.CALL, self._seqid)
    args = countKeyTime_args()
    args.key = key
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_countKeyTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = countKeyTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyTime failed: unknown result")

  def countKeyTimestr(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_countKeyTimestr(key, timestamp, creds, transaction, environment)
    return self.recv_countKeyTimestr()

  def send_countKeyTimestr(self, key, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('countKeyTimestr', TMessageType.CALL, self._seqid)
    args = countKeyTimestr_args()
    args.key = key
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_countKeyTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = countKeyTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyTimestr failed: unknown result")

  def countKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_countKeyCriteria(key, criteria, creds, transaction, environment)
    return self.recv_countKeyCriteria()

  def send_countKeyCriteria(self, key, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('countKeyCriteria', TMessageType.CALL, self._seqid)
    args = countKeyCriteria_args()
    args.key = key
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_countKeyCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = countKeyCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyCriteria failed: unknown result")

  def countKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_countKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_countKeyCriteriaTime()

  def send_countKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('countKeyCriteriaTime', TMessageType.CALL, self._seqid)
    args = countKeyCriteriaTime_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_countKeyCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = countKeyCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyCriteriaTime failed: unknown result")

  def countKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_countKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_countKeyCriteriaTimestr()

  def send_countKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('countKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = countKeyCriteriaTimestr_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_countKeyCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = countKeyCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyCriteriaTimestr failed: unknown result")

  def countKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_countKeyCcl(key, ccl, creds, transaction, environment)
    return self.recv_countKeyCcl()

  def send_countKeyCcl(self, key, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('countKeyCcl', TMessageType.CALL, self._seqid)
    args = countKeyCcl_args()
    args.key = key
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_countKeyCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = countKeyCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyCcl failed: unknown result")

  def countKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_countKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_countKeyCclTime()

  def send_countKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('countKeyCclTime', TMessageType.CALL, self._seqid)
    args = countKeyCclTime_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_countKeyCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = countKeyCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyCclTime failed: unknown result")

  def countKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_countKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_countKeyCclTimestr()

  def send_countKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('countKeyCclTimestr', TMessageType.CALL, self._seqid)
    args = countKeyCclTimestr_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_countKeyCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = countKeyCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "countKeyCclTimestr failed: unknown result")

  def maxKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_maxKeyRecord(key, record, creds, transaction, environment)
    return self.recv_maxKeyRecord()

  def send_maxKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('maxKeyRecord', TMessageType.CALL, self._seqid)
    args = maxKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_maxKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = maxKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyRecord failed: unknown result")

  def maxKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_maxKeyRecordTime(key, record, timestamp, creds, transaction, environment)
    return self.recv_maxKeyRecordTime()

  def send_maxKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('maxKeyRecordTime', TMessageType.CALL, self._seqid)
    args = maxKeyRecordTime_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_maxKeyRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = maxKeyRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyRecordTime failed: unknown result")

  def maxKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_maxKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
    return self.recv_maxKeyRecordTimestr()

  def send_maxKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('maxKeyRecordTimestr', TMessageType.CALL, self._seqid)
    args = maxKeyRecordTimestr_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_maxKeyRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = maxKeyRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyRecordTimestr failed: unknown result")

  def maxKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    self.send_maxKeyRecords(key, records, creds, transaction, environment)
    return self.recv_maxKeyRecords()

  def send_maxKeyRecords(self, key, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('maxKeyRecords', TMessageType.CALL, self._seqid)
    args = maxKeyRecords_args()
    args.key = key
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_maxKeyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = maxKeyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyRecords failed: unknown result")

  def maxKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_maxKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
    return self.recv_maxKeyRecordsTime()

  def send_maxKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('maxKeyRecordsTime', TMessageType.CALL, self._seqid)
    args = maxKeyRecordsTime_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_maxKeyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = maxKeyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyRecordsTime failed: unknown result")

  def maxKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_maxKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
    return self.recv_maxKeyRecordsTimestr()

  def send_maxKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('maxKeyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = maxKeyRecordsTimestr_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_maxKeyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = maxKeyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyRecordsTimestr failed: unknown result")

  def maxKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_maxKeyCriteria(key, criteria, creds, transaction, environment)
    return self.recv_maxKeyCriteria()

  def send_maxKeyCriteria(self, key, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('maxKeyCriteria', TMessageType.CALL, self._seqid)
    args = maxKeyCriteria_args()
    args.key = key
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_maxKeyCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = maxKeyCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyCriteria failed: unknown result")

  def maxKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_maxKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_maxKeyCriteriaTime()

  def send_maxKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('maxKeyCriteriaTime', TMessageType.CALL, self._seqid)
    args = maxKeyCriteriaTime_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_maxKeyCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = maxKeyCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyCriteriaTime failed: unknown result")

  def maxKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_maxKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_maxKeyCriteriaTimestr()

  def send_maxKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('maxKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = maxKeyCriteriaTimestr_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_maxKeyCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = maxKeyCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyCriteriaTimestr failed: unknown result")

  def maxKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_maxKeyCcl(key, ccl, creds, transaction, environment)
    return self.recv_maxKeyCcl()

  def send_maxKeyCcl(self, key, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('maxKeyCcl', TMessageType.CALL, self._seqid)
    args = maxKeyCcl_args()
    args.key = key
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_maxKeyCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = maxKeyCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyCcl failed: unknown result")

  def maxKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_maxKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_maxKeyCclTime()

  def send_maxKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('maxKeyCclTime', TMessageType.CALL, self._seqid)
    args = maxKeyCclTime_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_maxKeyCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = maxKeyCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyCclTime failed: unknown result")

  def maxKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_maxKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_maxKeyCclTimestr()

  def send_maxKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('maxKeyCclTimestr', TMessageType.CALL, self._seqid)
    args = maxKeyCclTimestr_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_maxKeyCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = maxKeyCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyCclTimestr failed: unknown result")

  def maxKey(self, key, creds, transaction, environment):
    """
    Parameters:
     - key
     - creds
     - transaction
     - environment
    """
    self.send_maxKey(key, creds, transaction, environment)
    return self.recv_maxKey()

  def send_maxKey(self, key, creds, transaction, environment):
    self._oprot.writeMessageBegin('maxKey', TMessageType.CALL, self._seqid)
    args = maxKey_args()
    args.key = key
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_maxKey(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = maxKey_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKey failed: unknown result")

  def maxKeyTime(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_maxKeyTime(key, timestamp, creds, transaction, environment)
    return self.recv_maxKeyTime()

  def send_maxKeyTime(self, key, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('maxKeyTime', TMessageType.CALL, self._seqid)
    args = maxKeyTime_args()
    args.key = key
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_maxKeyTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = maxKeyTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyTime failed: unknown result")

  def maxKeyTimestr(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_maxKeyTimestr(key, timestamp, creds, transaction, environment)
    return self.recv_maxKeyTimestr()

  def send_maxKeyTimestr(self, key, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('maxKeyTimestr', TMessageType.CALL, self._seqid)
    args = maxKeyTimestr_args()
    args.key = key
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_maxKeyTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = maxKeyTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "maxKeyTimestr failed: unknown result")

  def minKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_minKeyRecord(key, record, creds, transaction, environment)
    return self.recv_minKeyRecord()

  def send_minKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('minKeyRecord', TMessageType.CALL, self._seqid)
    args = minKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_minKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = minKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyRecord failed: unknown result")

  def minKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_minKeyRecordTime(key, record, timestamp, creds, transaction, environment)
    return self.recv_minKeyRecordTime()

  def send_minKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('minKeyRecordTime', TMessageType.CALL, self._seqid)
    args = minKeyRecordTime_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_minKeyRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = minKeyRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyRecordTime failed: unknown result")

  def minKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_minKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
    return self.recv_minKeyRecordTimestr()

  def send_minKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('minKeyRecordTimestr', TMessageType.CALL, self._seqid)
    args = minKeyRecordTimestr_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_minKeyRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = minKeyRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyRecordTimestr failed: unknown result")

  def minKey(self, key, creds, transaction, environment):
    """
    Parameters:
     - key
     - creds
     - transaction
     - environment
    """
    self.send_minKey(key, creds, transaction, environment)
    return self.recv_minKey()

  def send_minKey(self, key, creds, transaction, environment):
    self._oprot.writeMessageBegin('minKey', TMessageType.CALL, self._seqid)
    args = minKey_args()
    args.key = key
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_minKey(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = minKey_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "minKey failed: unknown result")

  def minKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_minKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
    return self.recv_minKeyRecordsTime()

  def send_minKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('minKeyRecordsTime', TMessageType.CALL, self._seqid)
    args = minKeyRecordsTime_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_minKeyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = minKeyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyRecordsTime failed: unknown result")

  def minKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_minKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
    return self.recv_minKeyRecordsTimestr()

  def send_minKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('minKeyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = minKeyRecordsTimestr_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_minKeyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = minKeyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyRecordsTimestr failed: unknown result")

  def minKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_minKeyCriteria(key, criteria, creds, transaction, environment)
    return self.recv_minKeyCriteria()

  def send_minKeyCriteria(self, key, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('minKeyCriteria', TMessageType.CALL, self._seqid)
    args = minKeyCriteria_args()
    args.key = key
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_minKeyCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = minKeyCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyCriteria failed: unknown result")

  def minKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_minKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_minKeyCriteriaTime()

  def send_minKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('minKeyCriteriaTime', TMessageType.CALL, self._seqid)
    args = minKeyCriteriaTime_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_minKeyCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = minKeyCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyCriteriaTime failed: unknown result")

  def minKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_minKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_minKeyCriteriaTimestr()

  def send_minKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('minKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = minKeyCriteriaTimestr_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_minKeyCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = minKeyCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyCriteriaTimestr failed: unknown result")

  def minKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_minKeyCcl(key, ccl, creds, transaction, environment)
    return self.recv_minKeyCcl()

  def send_minKeyCcl(self, key, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('minKeyCcl', TMessageType.CALL, self._seqid)
    args = minKeyCcl_args()
    args.key = key
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_minKeyCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = minKeyCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyCcl failed: unknown result")

  def minKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_minKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_minKeyCclTime()

  def send_minKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('minKeyCclTime', TMessageType.CALL, self._seqid)
    args = minKeyCclTime_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_minKeyCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = minKeyCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyCclTime failed: unknown result")

  def minKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_minKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_minKeyCclTimestr()

  def send_minKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('minKeyCclTimestr', TMessageType.CALL, self._seqid)
    args = minKeyCclTimestr_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_minKeyCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = minKeyCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyCclTimestr failed: unknown result")

  def minKeyTime(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_minKeyTime(key, timestamp, creds, transaction, environment)
    return self.recv_minKeyTime()

  def send_minKeyTime(self, key, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('minKeyTime', TMessageType.CALL, self._seqid)
    args = minKeyTime_args()
    args.key = key
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_minKeyTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = minKeyTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyTime failed: unknown result")

  def minKeyTimestr(self, key, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_minKeyTimestr(key, timestamp, creds, transaction, environment)
    return self.recv_minKeyTimestr()

  def send_minKeyTimestr(self, key, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('minKeyTimestr', TMessageType.CALL, self._seqid)
    args = minKeyTimestr_args()
    args.key = key
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_minKeyTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = minKeyTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyTimestr failed: unknown result")

  def minKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    self.send_minKeyRecords(key, records, creds, transaction, environment)
    return self.recv_minKeyRecords()

  def send_minKeyRecords(self, key, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('minKeyRecords', TMessageType.CALL, self._seqid)
    args = minKeyRecords_args()
    args.key = key
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_minKeyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = minKeyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "minKeyRecords failed: unknown result")

  def navigateKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeyRecord(key, record, creds, transaction, environment)
    return self.recv_navigateKeyRecord()

  def send_navigateKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeyRecord', TMessageType.CALL, self._seqid)
    args = navigateKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyRecord failed: unknown result")

  def navigateKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeyRecordTime(key, record, timestamp, creds, transaction, environment)
    return self.recv_navigateKeyRecordTime()

  def send_navigateKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeyRecordTime', TMessageType.CALL, self._seqid)
    args = navigateKeyRecordTime_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeyRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeyRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyRecordTime failed: unknown result")

  def navigateKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
    return self.recv_navigateKeyRecordTimestr()

  def send_navigateKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeyRecordTimestr', TMessageType.CALL, self._seqid)
    args = navigateKeyRecordTimestr_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeyRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeyRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyRecordTimestr failed: unknown result")

  def navigateKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeysRecord(keys, record, creds, transaction, environment)
    return self.recv_navigateKeysRecord()

  def send_navigateKeysRecord(self, keys, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeysRecord', TMessageType.CALL, self._seqid)
    args = navigateKeysRecord_args()
    args.keys = keys
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeysRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeysRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysRecord failed: unknown result")

  def navigateKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeysRecordTime(keys, record, timestamp, creds, transaction, environment)
    return self.recv_navigateKeysRecordTime()

  def send_navigateKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeysRecordTime', TMessageType.CALL, self._seqid)
    args = navigateKeysRecordTime_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeysRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeysRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysRecordTime failed: unknown result")

  def navigateKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeysRecordTimestr(keys, record, timestamp, creds, transaction, environment)
    return self.recv_navigateKeysRecordTimestr()

  def send_navigateKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeysRecordTimestr', TMessageType.CALL, self._seqid)
    args = navigateKeysRecordTimestr_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeysRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeysRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysRecordTimestr failed: unknown result")

  def navigateKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeysRecords(keys, records, creds, transaction, environment)
    return self.recv_navigateKeysRecords()

  def send_navigateKeysRecords(self, keys, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeysRecords', TMessageType.CALL, self._seqid)
    args = navigateKeysRecords_args()
    args.keys = keys
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeysRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeysRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysRecords failed: unknown result")

  def navigateKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeyRecords(key, records, creds, transaction, environment)
    return self.recv_navigateKeyRecords()

  def send_navigateKeyRecords(self, key, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeyRecords', TMessageType.CALL, self._seqid)
    args = navigateKeyRecords_args()
    args.key = key
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyRecords failed: unknown result")

  def navigateKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
    return self.recv_navigateKeyRecordsTime()

  def send_navigateKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeyRecordsTime', TMessageType.CALL, self._seqid)
    args = navigateKeyRecordsTime_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyRecordsTime failed: unknown result")

  def navigateKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
    return self.recv_navigateKeyRecordsTimestr()

  def send_navigateKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = navigateKeyRecordsTimestr_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyRecordsTimestr failed: unknown result")

  def navigateKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeysRecordsTime(keys, records, timestamp, creds, transaction, environment)
    return self.recv_navigateKeysRecordsTime()

  def send_navigateKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeysRecordsTime', TMessageType.CALL, self._seqid)
    args = navigateKeysRecordsTime_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeysRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeysRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysRecordsTime failed: unknown result")

  def navigateKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeysRecordsTimestr(keys, records, timestamp, creds, transaction, environment)
    return self.recv_navigateKeysRecordsTimestr()

  def send_navigateKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeysRecordsTimestr', TMessageType.CALL, self._seqid)
    args = navigateKeysRecordsTimestr_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeysRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeysRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysRecordsTimestr failed: unknown result")

  def navigateKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeyCcl(key, ccl, creds, transaction, environment)
    return self.recv_navigateKeyCcl()

  def send_navigateKeyCcl(self, key, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeyCcl', TMessageType.CALL, self._seqid)
    args = navigateKeyCcl_args()
    args.key = key
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeyCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeyCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyCcl failed: unknown result")

  def navigateKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_navigateKeyCclTime()

  def send_navigateKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeyCclTime', TMessageType.CALL, self._seqid)
    args = navigateKeyCclTime_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeyCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeyCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyCclTime failed: unknown result")

  def navigateKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_navigateKeyCclTimestr()

  def send_navigateKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeyCclTimestr', TMessageType.CALL, self._seqid)
    args = navigateKeyCclTimestr_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeyCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeyCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyCclTimestr failed: unknown result")

  def navigateKeysCcl(self, keys, ccl, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeysCcl(keys, ccl, creds, transaction, environment)
    return self.recv_navigateKeysCcl()

  def send_navigateKeysCcl(self, keys, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeysCcl', TMessageType.CALL, self._seqid)
    args = navigateKeysCcl_args()
    args.keys = keys
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeysCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeysCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysCcl failed: unknown result")

  def navigateKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeysCclTime(keys, ccl, timestamp, creds, transaction, environment)
    return self.recv_navigateKeysCclTime()

  def send_navigateKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeysCclTime', TMessageType.CALL, self._seqid)
    args = navigateKeysCclTime_args()
    args.keys = keys
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeysCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeysCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysCclTime failed: unknown result")

  def navigateKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeysCclTimestr(keys, ccl, timestamp, creds, transaction, environment)
    return self.recv_navigateKeysCclTimestr()

  def send_navigateKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeysCclTimestr', TMessageType.CALL, self._seqid)
    args = navigateKeysCclTimestr_args()
    args.keys = keys
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeysCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeysCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysCclTimestr failed: unknown result")

  def navigateKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeyCriteria(key, criteria, creds, transaction, environment)
    return self.recv_navigateKeyCriteria()

  def send_navigateKeyCriteria(self, key, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeyCriteria', TMessageType.CALL, self._seqid)
    args = navigateKeyCriteria_args()
    args.key = key
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeyCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeyCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyCriteria failed: unknown result")

  def navigateKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_navigateKeyCriteriaTime()

  def send_navigateKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeyCriteriaTime', TMessageType.CALL, self._seqid)
    args = navigateKeyCriteriaTime_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeyCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeyCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyCriteriaTime failed: unknown result")

  def navigateKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_navigateKeyCriteriaTimestr()

  def send_navigateKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = navigateKeyCriteriaTimestr_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeyCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeyCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeyCriteriaTimestr failed: unknown result")

  def navigateKeysCriteria(self, keys, criteria, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeysCriteria(keys, criteria, creds, transaction, environment)
    return self.recv_navigateKeysCriteria()

  def send_navigateKeysCriteria(self, keys, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeysCriteria', TMessageType.CALL, self._seqid)
    args = navigateKeysCriteria_args()
    args.keys = keys
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeysCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeysCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysCriteria failed: unknown result")

  def navigateKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeysCriteriaTime(keys, criteria, timestamp, creds, transaction, environment)
    return self.recv_navigateKeysCriteriaTime()

  def send_navigateKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeysCriteriaTime', TMessageType.CALL, self._seqid)
    args = navigateKeysCriteriaTime_args()
    args.keys = keys
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeysCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeysCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysCriteriaTime failed: unknown result")

  def navigateKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_navigateKeysCriteriaTimestr(keys, criteria, timestamp, creds, transaction, environment)
    return self.recv_navigateKeysCriteriaTimestr()

  def send_navigateKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('navigateKeysCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = navigateKeysCriteriaTimestr_args()
    args.keys = keys
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_navigateKeysCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = navigateKeysCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "navigateKeysCriteriaTimestr failed: unknown result")

  def getServerEnvironment(self, creds, token, environment):
    """
    Parameters:
     - creds
     - token
     - environment
    """
    self.send_getServerEnvironment(creds, token, environment)
    return self.recv_getServerEnvironment()

  def send_getServerEnvironment(self, creds, token, environment):
    self._oprot.writeMessageBegin('getServerEnvironment', TMessageType.CALL, self._seqid)
    args = getServerEnvironment_args()
    args.creds = creds
    args.token = token
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getServerEnvironment(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getServerEnvironment_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getServerEnvironment failed: unknown result")

  def getServerVersion(self):
    self.send_getServerVersion()
    return self.recv_getServerVersion()

  def send_getServerVersion(self):
    self._oprot.writeMessageBegin('getServerVersion', TMessageType.CALL, self._seqid)
    args = getServerVersion_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getServerVersion(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getServerVersion_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getServerVersion failed: unknown result")

  def time(self, creds, token, environment):
    """
    Parameters:
     - creds
     - token
     - environment
    """
    self.send_time(creds, token, environment)
    return self.recv_time()

  def send_time(self, creds, token, environment):
    self._oprot.writeMessageBegin('time', TMessageType.CALL, self._seqid)
    args = time_args()
    args.creds = creds
    args.token = token
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "time failed: unknown result")

  def timePhrase(self, phrase, creds, token, environment):
    """
    Parameters:
     - phrase
     - creds
     - token
     - environment
    """
    self.send_timePhrase(phrase, creds, token, environment)
    return self.recv_timePhrase()

  def send_timePhrase(self, phrase, creds, token, environment):
    self._oprot.writeMessageBegin('timePhrase', TMessageType.CALL, self._seqid)
    args = timePhrase_args()
    args.phrase = phrase
    args.creds = creds
    args.token = token
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_timePhrase(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = timePhrase_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "timePhrase failed: unknown result")


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["abort"] = Processor.process_abort
    self._processMap["addKeyValue"] = Processor.process_addKeyValue
    self._processMap["addKeyValueRecord"] = Processor.process_addKeyValueRecord
    self._processMap["addKeyValueRecords"] = Processor.process_addKeyValueRecords
    self._processMap["auditRecord"] = Processor.process_auditRecord
    self._processMap["auditRecordStart"] = Processor.process_auditRecordStart
    self._processMap["auditRecordStartstr"] = Processor.process_auditRecordStartstr
    self._processMap["auditRecordStartEnd"] = Processor.process_auditRecordStartEnd
    self._processMap["auditRecordStartstrEndstr"] = Processor.process_auditRecordStartstrEndstr
    self._processMap["auditKeyRecord"] = Processor.process_auditKeyRecord
    self._processMap["auditKeyRecordStart"] = Processor.process_auditKeyRecordStart
    self._processMap["auditKeyRecordStartstr"] = Processor.process_auditKeyRecordStartstr
    self._processMap["auditKeyRecordStartEnd"] = Processor.process_auditKeyRecordStartEnd
    self._processMap["auditKeyRecordStartstrEndstr"] = Processor.process_auditKeyRecordStartstrEndstr
    self._processMap["browseKey"] = Processor.process_browseKey
    self._processMap["browseKeys"] = Processor.process_browseKeys
    self._processMap["browseKeyTime"] = Processor.process_browseKeyTime
    self._processMap["browseKeyTimestr"] = Processor.process_browseKeyTimestr
    self._processMap["browseKeysTime"] = Processor.process_browseKeysTime
    self._processMap["browseKeysTimestr"] = Processor.process_browseKeysTimestr
    self._processMap["chronologizeKeyRecord"] = Processor.process_chronologizeKeyRecord
    self._processMap["chronologizeKeyRecordStart"] = Processor.process_chronologizeKeyRecordStart
    self._processMap["chronologizeKeyRecordStartstr"] = Processor.process_chronologizeKeyRecordStartstr
    self._processMap["chronologizeKeyRecordStartEnd"] = Processor.process_chronologizeKeyRecordStartEnd
    self._processMap["chronologizeKeyRecordStartstrEndstr"] = Processor.process_chronologizeKeyRecordStartstrEndstr
    self._processMap["clearRecord"] = Processor.process_clearRecord
    self._processMap["clearRecords"] = Processor.process_clearRecords
    self._processMap["clearKeyRecord"] = Processor.process_clearKeyRecord
    self._processMap["clearKeysRecord"] = Processor.process_clearKeysRecord
    self._processMap["clearKeyRecords"] = Processor.process_clearKeyRecords
    self._processMap["clearKeysRecords"] = Processor.process_clearKeysRecords
    self._processMap["commit"] = Processor.process_commit
    self._processMap["describe"] = Processor.process_describe
    self._processMap["describeTime"] = Processor.process_describeTime
    self._processMap["describeTimestr"] = Processor.process_describeTimestr
    self._processMap["describeRecord"] = Processor.process_describeRecord
    self._processMap["describeRecordTime"] = Processor.process_describeRecordTime
    self._processMap["describeRecordTimestr"] = Processor.process_describeRecordTimestr
    self._processMap["describeRecords"] = Processor.process_describeRecords
    self._processMap["describeRecordsTime"] = Processor.process_describeRecordsTime
    self._processMap["describeRecordsTimestr"] = Processor.process_describeRecordsTimestr
    self._processMap["diffRecordStart"] = Processor.process_diffRecordStart
    self._processMap["diffRecordStartstr"] = Processor.process_diffRecordStartstr
    self._processMap["diffRecordStartEnd"] = Processor.process_diffRecordStartEnd
    self._processMap["diffRecordStartstrEndstr"] = Processor.process_diffRecordStartstrEndstr
    self._processMap["diffKeyRecordStart"] = Processor.process_diffKeyRecordStart
    self._processMap["diffKeyRecordStartstr"] = Processor.process_diffKeyRecordStartstr
    self._processMap["diffKeyRecordStartEnd"] = Processor.process_diffKeyRecordStartEnd
    self._processMap["diffKeyRecordStartstrEndstr"] = Processor.process_diffKeyRecordStartstrEndstr
    self._processMap["diffKeyStart"] = Processor.process_diffKeyStart
    self._processMap["diffKeyStartstr"] = Processor.process_diffKeyStartstr
    self._processMap["diffKeyStartEnd"] = Processor.process_diffKeyStartEnd
    self._processMap["diffKeyStartstrEndstr"] = Processor.process_diffKeyStartstrEndstr
    self._processMap["invokePlugin"] = Processor.process_invokePlugin
    self._processMap["login"] = Processor.process_login
    self._processMap["logout"] = Processor.process_logout
    self._processMap["stage"] = Processor.process_stage
    self._processMap["insertJson"] = Processor.process_insertJson
    self._processMap["insertJsonRecord"] = Processor.process_insertJsonRecord
    self._processMap["insertJsonRecords"] = Processor.process_insertJsonRecords
    self._processMap["removeKeyValueRecord"] = Processor.process_removeKeyValueRecord
    self._processMap["removeKeyValueRecords"] = Processor.process_removeKeyValueRecords
    self._processMap["setKeyValueRecord"] = Processor.process_setKeyValueRecord
    self._processMap["setKeyValue"] = Processor.process_setKeyValue
    self._processMap["setKeyValueRecords"] = Processor.process_setKeyValueRecords
    self._processMap["reconcileKeyRecordValues"] = Processor.process_reconcileKeyRecordValues
    self._processMap["inventory"] = Processor.process_inventory
    self._processMap["selectRecord"] = Processor.process_selectRecord
    self._processMap["selectRecords"] = Processor.process_selectRecords
    self._processMap["selectRecordTime"] = Processor.process_selectRecordTime
    self._processMap["selectRecordTimestr"] = Processor.process_selectRecordTimestr
    self._processMap["selectRecordsTime"] = Processor.process_selectRecordsTime
    self._processMap["selectRecordsTimestr"] = Processor.process_selectRecordsTimestr
    self._processMap["selectKeyRecord"] = Processor.process_selectKeyRecord
    self._processMap["selectKeyRecordTime"] = Processor.process_selectKeyRecordTime
    self._processMap["selectKeyRecordTimestr"] = Processor.process_selectKeyRecordTimestr
    self._processMap["selectKeysRecord"] = Processor.process_selectKeysRecord
    self._processMap["selectKeysRecordTime"] = Processor.process_selectKeysRecordTime
    self._processMap["selectKeysRecordTimestr"] = Processor.process_selectKeysRecordTimestr
    self._processMap["selectKeysRecords"] = Processor.process_selectKeysRecords
    self._processMap["selectKeyRecords"] = Processor.process_selectKeyRecords
    self._processMap["selectKeyRecordsTime"] = Processor.process_selectKeyRecordsTime
    self._processMap["selectKeyRecordsTimestr"] = Processor.process_selectKeyRecordsTimestr
    self._processMap["selectKeysRecordsTime"] = Processor.process_selectKeysRecordsTime
    self._processMap["selectKeysRecordsTimestr"] = Processor.process_selectKeysRecordsTimestr
    self._processMap["selectCriteria"] = Processor.process_selectCriteria
    self._processMap["selectCcl"] = Processor.process_selectCcl
    self._processMap["selectCriteriaTime"] = Processor.process_selectCriteriaTime
    self._processMap["selectCriteriaTimestr"] = Processor.process_selectCriteriaTimestr
    self._processMap["selectCclTime"] = Processor.process_selectCclTime
    self._processMap["selectCclTimestr"] = Processor.process_selectCclTimestr
    self._processMap["selectKeyCriteria"] = Processor.process_selectKeyCriteria
    self._processMap["selectKeyCcl"] = Processor.process_selectKeyCcl
    self._processMap["selectKeyCriteriaTime"] = Processor.process_selectKeyCriteriaTime
    self._processMap["selectKeyCriteriaTimestr"] = Processor.process_selectKeyCriteriaTimestr
    self._processMap["selectKeyCclTime"] = Processor.process_selectKeyCclTime
    self._processMap["selectKeyCclTimestr"] = Processor.process_selectKeyCclTimestr
    self._processMap["selectKeysCriteria"] = Processor.process_selectKeysCriteria
    self._processMap["selectKeysCcl"] = Processor.process_selectKeysCcl
    self._processMap["selectKeysCriteriaTime"] = Processor.process_selectKeysCriteriaTime
    self._processMap["selectKeysCriteriaTimestr"] = Processor.process_selectKeysCriteriaTimestr
    self._processMap["selectKeysCclTime"] = Processor.process_selectKeysCclTime
    self._processMap["selectKeysCclTimestr"] = Processor.process_selectKeysCclTimestr
    self._processMap["getKeyRecord"] = Processor.process_getKeyRecord
    self._processMap["getKeyRecordTime"] = Processor.process_getKeyRecordTime
    self._processMap["getKeyRecordTimestr"] = Processor.process_getKeyRecordTimestr
    self._processMap["getKeysRecord"] = Processor.process_getKeysRecord
    self._processMap["getKeysRecordTime"] = Processor.process_getKeysRecordTime
    self._processMap["getKeysRecordTimestr"] = Processor.process_getKeysRecordTimestr
    self._processMap["getKeysRecords"] = Processor.process_getKeysRecords
    self._processMap["getKeyRecords"] = Processor.process_getKeyRecords
    self._processMap["getKeyRecordsTime"] = Processor.process_getKeyRecordsTime
    self._processMap["getKeyRecordsTimestr"] = Processor.process_getKeyRecordsTimestr
    self._processMap["getKeysRecordsTime"] = Processor.process_getKeysRecordsTime
    self._processMap["getKeysRecordsTimestr"] = Processor.process_getKeysRecordsTimestr
    self._processMap["getKeyCriteria"] = Processor.process_getKeyCriteria
    self._processMap["getCriteria"] = Processor.process_getCriteria
    self._processMap["getCcl"] = Processor.process_getCcl
    self._processMap["getCriteriaTime"] = Processor.process_getCriteriaTime
    self._processMap["getCriteriaTimestr"] = Processor.process_getCriteriaTimestr
    self._processMap["getCclTime"] = Processor.process_getCclTime
    self._processMap["getCclTimestr"] = Processor.process_getCclTimestr
    self._processMap["getKeyCcl"] = Processor.process_getKeyCcl
    self._processMap["getKeyCriteriaTime"] = Processor.process_getKeyCriteriaTime
    self._processMap["getKeyCriteriaTimestr"] = Processor.process_getKeyCriteriaTimestr
    self._processMap["getKeyCclTime"] = Processor.process_getKeyCclTime
    self._processMap["getKeyCclTimestr"] = Processor.process_getKeyCclTimestr
    self._processMap["getKeysCriteria"] = Processor.process_getKeysCriteria
    self._processMap["getKeysCcl"] = Processor.process_getKeysCcl
    self._processMap["getKeysCriteriaTime"] = Processor.process_getKeysCriteriaTime
    self._processMap["getKeysCriteriaTimestr"] = Processor.process_getKeysCriteriaTimestr
    self._processMap["getKeysCclTime"] = Processor.process_getKeysCclTime
    self._processMap["getKeysCclTimestr"] = Processor.process_getKeysCclTimestr
    self._processMap["verifyKeyValueRecord"] = Processor.process_verifyKeyValueRecord
    self._processMap["verifyKeyValueRecordTime"] = Processor.process_verifyKeyValueRecordTime
    self._processMap["verifyKeyValueRecordTimestr"] = Processor.process_verifyKeyValueRecordTimestr
    self._processMap["jsonifyRecords"] = Processor.process_jsonifyRecords
    self._processMap["jsonifyRecordsTime"] = Processor.process_jsonifyRecordsTime
    self._processMap["jsonifyRecordsTimestr"] = Processor.process_jsonifyRecordsTimestr
    self._processMap["findCriteria"] = Processor.process_findCriteria
    self._processMap["findCcl"] = Processor.process_findCcl
    self._processMap["findKeyOperatorValues"] = Processor.process_findKeyOperatorValues
    self._processMap["findKeyOperatorValuesTime"] = Processor.process_findKeyOperatorValuesTime
    self._processMap["findKeyOperatorValuesTimestr"] = Processor.process_findKeyOperatorValuesTimestr
    self._processMap["findKeyOperatorstrValues"] = Processor.process_findKeyOperatorstrValues
    self._processMap["findKeyOperatorstrValuesTime"] = Processor.process_findKeyOperatorstrValuesTime
    self._processMap["findKeyOperatorstrValuesTimestr"] = Processor.process_findKeyOperatorstrValuesTimestr
    self._processMap["search"] = Processor.process_search
    self._processMap["revertKeysRecordsTime"] = Processor.process_revertKeysRecordsTime
    self._processMap["revertKeysRecordsTimestr"] = Processor.process_revertKeysRecordsTimestr
    self._processMap["revertKeysRecordTime"] = Processor.process_revertKeysRecordTime
    self._processMap["revertKeysRecordTimestr"] = Processor.process_revertKeysRecordTimestr
    self._processMap["revertKeyRecordsTime"] = Processor.process_revertKeyRecordsTime
    self._processMap["revertKeyRecordsTimestr"] = Processor.process_revertKeyRecordsTimestr
    self._processMap["revertKeyRecordTime"] = Processor.process_revertKeyRecordTime
    self._processMap["revertKeyRecordTimestr"] = Processor.process_revertKeyRecordTimestr
    self._processMap["pingRecords"] = Processor.process_pingRecords
    self._processMap["pingRecord"] = Processor.process_pingRecord
    self._processMap["verifyAndSwap"] = Processor.process_verifyAndSwap
    self._processMap["verifyOrSet"] = Processor.process_verifyOrSet
    self._processMap["findOrAddKeyValue"] = Processor.process_findOrAddKeyValue
    self._processMap["findOrInsertCriteriaJson"] = Processor.process_findOrInsertCriteriaJson
    self._processMap["findOrInsertCclJson"] = Processor.process_findOrInsertCclJson
    self._processMap["sumKeyRecord"] = Processor.process_sumKeyRecord
    self._processMap["sumKeyRecordTime"] = Processor.process_sumKeyRecordTime
    self._processMap["sumKeyRecordTimestr"] = Processor.process_sumKeyRecordTimestr
    self._processMap["sumKeyRecords"] = Processor.process_sumKeyRecords
    self._processMap["sumKeyRecordsTime"] = Processor.process_sumKeyRecordsTime
    self._processMap["sumKeyRecordsTimestr"] = Processor.process_sumKeyRecordsTimestr
    self._processMap["sumKey"] = Processor.process_sumKey
    self._processMap["sumKeyTime"] = Processor.process_sumKeyTime
    self._processMap["sumKeyTimestr"] = Processor.process_sumKeyTimestr
    self._processMap["sumKeyCriteria"] = Processor.process_sumKeyCriteria
    self._processMap["sumKeyCriteriaTime"] = Processor.process_sumKeyCriteriaTime
    self._processMap["sumKeyCriteriaTimestr"] = Processor.process_sumKeyCriteriaTimestr
    self._processMap["sumKeyCcl"] = Processor.process_sumKeyCcl
    self._processMap["sumKeyCclTime"] = Processor.process_sumKeyCclTime
    self._processMap["sumKeyCclTimestr"] = Processor.process_sumKeyCclTimestr
    self._processMap["averageKeyRecord"] = Processor.process_averageKeyRecord
    self._processMap["averageKeyRecordTime"] = Processor.process_averageKeyRecordTime
    self._processMap["averageKeyRecordTimestr"] = Processor.process_averageKeyRecordTimestr
    self._processMap["averageKeyRecords"] = Processor.process_averageKeyRecords
    self._processMap["averageKeyRecordsTime"] = Processor.process_averageKeyRecordsTime
    self._processMap["averageKeyRecordsTimestr"] = Processor.process_averageKeyRecordsTimestr
    self._processMap["averageKey"] = Processor.process_averageKey
    self._processMap["averageKeyTime"] = Processor.process_averageKeyTime
    self._processMap["averageKeyTimestr"] = Processor.process_averageKeyTimestr
    self._processMap["averageKeyCriteria"] = Processor.process_averageKeyCriteria
    self._processMap["averageKeyCriteriaTime"] = Processor.process_averageKeyCriteriaTime
    self._processMap["averageKeyCriteriaTimestr"] = Processor.process_averageKeyCriteriaTimestr
    self._processMap["averageKeyCcl"] = Processor.process_averageKeyCcl
    self._processMap["averageKeyCclTime"] = Processor.process_averageKeyCclTime
    self._processMap["averageKeyCclTimestr"] = Processor.process_averageKeyCclTimestr
    self._processMap["countKeyRecord"] = Processor.process_countKeyRecord
    self._processMap["countKeyRecordTime"] = Processor.process_countKeyRecordTime
    self._processMap["countKeyRecordTimestr"] = Processor.process_countKeyRecordTimestr
    self._processMap["countKeyRecords"] = Processor.process_countKeyRecords
    self._processMap["countKeyRecordsTime"] = Processor.process_countKeyRecordsTime
    self._processMap["countKeyRecordsTimestr"] = Processor.process_countKeyRecordsTimestr
    self._processMap["countKey"] = Processor.process_countKey
    self._processMap["countKeyTime"] = Processor.process_countKeyTime
    self._processMap["countKeyTimestr"] = Processor.process_countKeyTimestr
    self._processMap["countKeyCriteria"] = Processor.process_countKeyCriteria
    self._processMap["countKeyCriteriaTime"] = Processor.process_countKeyCriteriaTime
    self._processMap["countKeyCriteriaTimestr"] = Processor.process_countKeyCriteriaTimestr
    self._processMap["countKeyCcl"] = Processor.process_countKeyCcl
    self._processMap["countKeyCclTime"] = Processor.process_countKeyCclTime
    self._processMap["countKeyCclTimestr"] = Processor.process_countKeyCclTimestr
    self._processMap["maxKeyRecord"] = Processor.process_maxKeyRecord
    self._processMap["maxKeyRecordTime"] = Processor.process_maxKeyRecordTime
    self._processMap["maxKeyRecordTimestr"] = Processor.process_maxKeyRecordTimestr
    self._processMap["maxKeyRecords"] = Processor.process_maxKeyRecords
    self._processMap["maxKeyRecordsTime"] = Processor.process_maxKeyRecordsTime
    self._processMap["maxKeyRecordsTimestr"] = Processor.process_maxKeyRecordsTimestr
    self._processMap["maxKeyCriteria"] = Processor.process_maxKeyCriteria
    self._processMap["maxKeyCriteriaTime"] = Processor.process_maxKeyCriteriaTime
    self._processMap["maxKeyCriteriaTimestr"] = Processor.process_maxKeyCriteriaTimestr
    self._processMap["maxKeyCcl"] = Processor.process_maxKeyCcl
    self._processMap["maxKeyCclTime"] = Processor.process_maxKeyCclTime
    self._processMap["maxKeyCclTimestr"] = Processor.process_maxKeyCclTimestr
    self._processMap["maxKey"] = Processor.process_maxKey
    self._processMap["maxKeyTime"] = Processor.process_maxKeyTime
    self._processMap["maxKeyTimestr"] = Processor.process_maxKeyTimestr
    self._processMap["minKeyRecord"] = Processor.process_minKeyRecord
    self._processMap["minKeyRecordTime"] = Processor.process_minKeyRecordTime
    self._processMap["minKeyRecordTimestr"] = Processor.process_minKeyRecordTimestr
    self._processMap["minKey"] = Processor.process_minKey
    self._processMap["minKeyRecordsTime"] = Processor.process_minKeyRecordsTime
    self._processMap["minKeyRecordsTimestr"] = Processor.process_minKeyRecordsTimestr
    self._processMap["minKeyCriteria"] = Processor.process_minKeyCriteria
    self._processMap["minKeyCriteriaTime"] = Processor.process_minKeyCriteriaTime
    self._processMap["minKeyCriteriaTimestr"] = Processor.process_minKeyCriteriaTimestr
    self._processMap["minKeyCcl"] = Processor.process_minKeyCcl
    self._processMap["minKeyCclTime"] = Processor.process_minKeyCclTime
    self._processMap["minKeyCclTimestr"] = Processor.process_minKeyCclTimestr
    self._processMap["minKeyTime"] = Processor.process_minKeyTime
    self._processMap["minKeyTimestr"] = Processor.process_minKeyTimestr
    self._processMap["minKeyRecords"] = Processor.process_minKeyRecords
    self._processMap["navigateKeyRecord"] = Processor.process_navigateKeyRecord
    self._processMap["navigateKeyRecordTime"] = Processor.process_navigateKeyRecordTime
    self._processMap["navigateKeyRecordTimestr"] = Processor.process_navigateKeyRecordTimestr
    self._processMap["navigateKeysRecord"] = Processor.process_navigateKeysRecord
    self._processMap["navigateKeysRecordTime"] = Processor.process_navigateKeysRecordTime
    self._processMap["navigateKeysRecordTimestr"] = Processor.process_navigateKeysRecordTimestr
    self._processMap["navigateKeysRecords"] = Processor.process_navigateKeysRecords
    self._processMap["navigateKeyRecords"] = Processor.process_navigateKeyRecords
    self._processMap["navigateKeyRecordsTime"] = Processor.process_navigateKeyRecordsTime
    self._processMap["navigateKeyRecordsTimestr"] = Processor.process_navigateKeyRecordsTimestr
    self._processMap["navigateKeysRecordsTime"] = Processor.process_navigateKeysRecordsTime
    self._processMap["navigateKeysRecordsTimestr"] = Processor.process_navigateKeysRecordsTimestr
    self._processMap["navigateKeyCcl"] = Processor.process_navigateKeyCcl
    self._processMap["navigateKeyCclTime"] = Processor.process_navigateKeyCclTime
    self._processMap["navigateKeyCclTimestr"] = Processor.process_navigateKeyCclTimestr
    self._processMap["navigateKeysCcl"] = Processor.process_navigateKeysCcl
    self._processMap["navigateKeysCclTime"] = Processor.process_navigateKeysCclTime
    self._processMap["navigateKeysCclTimestr"] = Processor.process_navigateKeysCclTimestr
    self._processMap["navigateKeyCriteria"] = Processor.process_navigateKeyCriteria
    self._processMap["navigateKeyCriteriaTime"] = Processor.process_navigateKeyCriteriaTime
    self._processMap["navigateKeyCriteriaTimestr"] = Processor.process_navigateKeyCriteriaTimestr
    self._processMap["navigateKeysCriteria"] = Processor.process_navigateKeysCriteria
    self._processMap["navigateKeysCriteriaTime"] = Processor.process_navigateKeysCriteriaTime
    self._processMap["navigateKeysCriteriaTimestr"] = Processor.process_navigateKeysCriteriaTimestr
    self._processMap["getServerEnvironment"] = Processor.process_getServerEnvironment
    self._processMap["getServerVersion"] = Processor.process_getServerVersion
    self._processMap["time"] = Processor.process_time
    self._processMap["timePhrase"] = Processor.process_timePhrase

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_abort(self, seqid, iprot, oprot):
    args = abort_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = abort_result()
    try:
      self._handler.abort(args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("abort", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addKeyValue(self, seqid, iprot, oprot):
    args = addKeyValue_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addKeyValue_result()
    try:
      result.success = self._handler.addKeyValue(args.key, args.value, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("addKeyValue", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addKeyValueRecord(self, seqid, iprot, oprot):
    args = addKeyValueRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addKeyValueRecord_result()
    try:
      result.success = self._handler.addKeyValueRecord(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("addKeyValueRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addKeyValueRecords(self, seqid, iprot, oprot):
    args = addKeyValueRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addKeyValueRecords_result()
    try:
      result.success = self._handler.addKeyValueRecords(args.key, args.value, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("addKeyValueRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditRecord(self, seqid, iprot, oprot):
    args = auditRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditRecord_result()
    try:
      result.success = self._handler.auditRecord(args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditRecordStart(self, seqid, iprot, oprot):
    args = auditRecordStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditRecordStart_result()
    try:
      result.success = self._handler.auditRecordStart(args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditRecordStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditRecordStartstr(self, seqid, iprot, oprot):
    args = auditRecordStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditRecordStartstr_result()
    try:
      result.success = self._handler.auditRecordStartstr(args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditRecordStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditRecordStartEnd(self, seqid, iprot, oprot):
    args = auditRecordStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditRecordStartEnd_result()
    try:
      result.success = self._handler.auditRecordStartEnd(args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditRecordStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditRecordStartstrEndstr(self, seqid, iprot, oprot):
    args = auditRecordStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditRecordStartstrEndstr_result()
    try:
      result.success = self._handler.auditRecordStartstrEndstr(args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditRecordStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditKeyRecord(self, seqid, iprot, oprot):
    args = auditKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditKeyRecord_result()
    try:
      result.success = self._handler.auditKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditKeyRecordStart(self, seqid, iprot, oprot):
    args = auditKeyRecordStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditKeyRecordStart_result()
    try:
      result.success = self._handler.auditKeyRecordStart(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditKeyRecordStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditKeyRecordStartstr(self, seqid, iprot, oprot):
    args = auditKeyRecordStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditKeyRecordStartstr_result()
    try:
      result.success = self._handler.auditKeyRecordStartstr(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditKeyRecordStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditKeyRecordStartEnd(self, seqid, iprot, oprot):
    args = auditKeyRecordStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditKeyRecordStartEnd_result()
    try:
      result.success = self._handler.auditKeyRecordStartEnd(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditKeyRecordStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditKeyRecordStartstrEndstr(self, seqid, iprot, oprot):
    args = auditKeyRecordStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditKeyRecordStartstrEndstr_result()
    try:
      result.success = self._handler.auditKeyRecordStartstrEndstr(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditKeyRecordStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKey(self, seqid, iprot, oprot):
    args = browseKey_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKey_result()
    try:
      result.success = self._handler.browseKey(args.key, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKey", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKeys(self, seqid, iprot, oprot):
    args = browseKeys_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKeys_result()
    try:
      result.success = self._handler.browseKeys(args.keys, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKeys", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKeyTime(self, seqid, iprot, oprot):
    args = browseKeyTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKeyTime_result()
    try:
      result.success = self._handler.browseKeyTime(args.key, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKeyTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKeyTimestr(self, seqid, iprot, oprot):
    args = browseKeyTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKeyTimestr_result()
    try:
      result.success = self._handler.browseKeyTimestr(args.key, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKeyTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKeysTime(self, seqid, iprot, oprot):
    args = browseKeysTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKeysTime_result()
    try:
      result.success = self._handler.browseKeysTime(args.keys, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKeysTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKeysTimestr(self, seqid, iprot, oprot):
    args = browseKeysTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKeysTimestr_result()
    try:
      result.success = self._handler.browseKeysTimestr(args.keys, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKeysTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chronologizeKeyRecord(self, seqid, iprot, oprot):
    args = chronologizeKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chronologizeKeyRecord_result()
    try:
      result.success = self._handler.chronologizeKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("chronologizeKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chronologizeKeyRecordStart(self, seqid, iprot, oprot):
    args = chronologizeKeyRecordStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chronologizeKeyRecordStart_result()
    try:
      result.success = self._handler.chronologizeKeyRecordStart(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("chronologizeKeyRecordStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chronologizeKeyRecordStartstr(self, seqid, iprot, oprot):
    args = chronologizeKeyRecordStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chronologizeKeyRecordStartstr_result()
    try:
      result.success = self._handler.chronologizeKeyRecordStartstr(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("chronologizeKeyRecordStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chronologizeKeyRecordStartEnd(self, seqid, iprot, oprot):
    args = chronologizeKeyRecordStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chronologizeKeyRecordStartEnd_result()
    try:
      result.success = self._handler.chronologizeKeyRecordStartEnd(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("chronologizeKeyRecordStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chronologizeKeyRecordStartstrEndstr(self, seqid, iprot, oprot):
    args = chronologizeKeyRecordStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chronologizeKeyRecordStartstrEndstr_result()
    try:
      result.success = self._handler.chronologizeKeyRecordStartstrEndstr(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("chronologizeKeyRecordStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearRecord(self, seqid, iprot, oprot):
    args = clearRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearRecord_result()
    try:
      self._handler.clearRecord(args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearRecords(self, seqid, iprot, oprot):
    args = clearRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearRecords_result()
    try:
      self._handler.clearRecords(args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearKeyRecord(self, seqid, iprot, oprot):
    args = clearKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearKeyRecord_result()
    try:
      self._handler.clearKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearKeysRecord(self, seqid, iprot, oprot):
    args = clearKeysRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearKeysRecord_result()
    try:
      self._handler.clearKeysRecord(args.keys, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearKeysRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearKeyRecords(self, seqid, iprot, oprot):
    args = clearKeyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearKeyRecords_result()
    try:
      self._handler.clearKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearKeyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearKeysRecords(self, seqid, iprot, oprot):
    args = clearKeysRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearKeysRecords_result()
    try:
      self._handler.clearKeysRecords(args.keys, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearKeysRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_commit(self, seqid, iprot, oprot):
    args = commit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = commit_result()
    try:
      result.success = self._handler.commit(args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("commit", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describe(self, seqid, iprot, oprot):
    args = describe_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describe_result()
    try:
      result.success = self._handler.describe(args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describe", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeTime(self, seqid, iprot, oprot):
    args = describeTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeTime_result()
    try:
      result.success = self._handler.describeTime(args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeTimestr(self, seqid, iprot, oprot):
    args = describeTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeTimestr_result()
    try:
      result.success = self._handler.describeTimestr(args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecord(self, seqid, iprot, oprot):
    args = describeRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecord_result()
    try:
      result.success = self._handler.describeRecord(args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecordTime(self, seqid, iprot, oprot):
    args = describeRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecordTime_result()
    try:
      result.success = self._handler.describeRecordTime(args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecordTimestr(self, seqid, iprot, oprot):
    args = describeRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecordTimestr_result()
    try:
      result.success = self._handler.describeRecordTimestr(args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecords(self, seqid, iprot, oprot):
    args = describeRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecords_result()
    try:
      result.success = self._handler.describeRecords(args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecordsTime(self, seqid, iprot, oprot):
    args = describeRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecordsTime_result()
    try:
      result.success = self._handler.describeRecordsTime(args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecordsTimestr(self, seqid, iprot, oprot):
    args = describeRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecordsTimestr_result()
    try:
      result.success = self._handler.describeRecordsTimestr(args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffRecordStart(self, seqid, iprot, oprot):
    args = diffRecordStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffRecordStart_result()
    try:
      result.success = self._handler.diffRecordStart(args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffRecordStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffRecordStartstr(self, seqid, iprot, oprot):
    args = diffRecordStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffRecordStartstr_result()
    try:
      result.success = self._handler.diffRecordStartstr(args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffRecordStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffRecordStartEnd(self, seqid, iprot, oprot):
    args = diffRecordStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffRecordStartEnd_result()
    try:
      result.success = self._handler.diffRecordStartEnd(args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffRecordStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffRecordStartstrEndstr(self, seqid, iprot, oprot):
    args = diffRecordStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffRecordStartstrEndstr_result()
    try:
      result.success = self._handler.diffRecordStartstrEndstr(args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffRecordStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyRecordStart(self, seqid, iprot, oprot):
    args = diffKeyRecordStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyRecordStart_result()
    try:
      result.success = self._handler.diffKeyRecordStart(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyRecordStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyRecordStartstr(self, seqid, iprot, oprot):
    args = diffKeyRecordStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyRecordStartstr_result()
    try:
      result.success = self._handler.diffKeyRecordStartstr(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyRecordStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyRecordStartEnd(self, seqid, iprot, oprot):
    args = diffKeyRecordStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyRecordStartEnd_result()
    try:
      result.success = self._handler.diffKeyRecordStartEnd(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyRecordStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyRecordStartstrEndstr(self, seqid, iprot, oprot):
    args = diffKeyRecordStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyRecordStartstrEndstr_result()
    try:
      result.success = self._handler.diffKeyRecordStartstrEndstr(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyRecordStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyStart(self, seqid, iprot, oprot):
    args = diffKeyStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyStart_result()
    try:
      result.success = self._handler.diffKeyStart(args.key, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyStartstr(self, seqid, iprot, oprot):
    args = diffKeyStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyStartstr_result()
    try:
      result.success = self._handler.diffKeyStartstr(args.key, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyStartEnd(self, seqid, iprot, oprot):
    args = diffKeyStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyStartEnd_result()
    try:
      result.success = self._handler.diffKeyStartEnd(args.key, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyStartstrEndstr(self, seqid, iprot, oprot):
    args = diffKeyStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyStartstrEndstr_result()
    try:
      result.success = self._handler.diffKeyStartstrEndstr(args.key, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_invokePlugin(self, seqid, iprot, oprot):
    args = invokePlugin_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = invokePlugin_result()
    try:
      result.success = self._handler.invokePlugin(args.id, args.method, args.params, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("invokePlugin", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_login(self, seqid, iprot, oprot):
    args = login_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = login_result()
    try:
      result.success = self._handler.login(args.username, args.password, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("login", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_logout(self, seqid, iprot, oprot):
    args = logout_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = logout_result()
    try:
      self._handler.logout(args.token, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("logout", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stage(self, seqid, iprot, oprot):
    args = stage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stage_result()
    try:
      result.success = self._handler.stage(args.token, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("stage", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_insertJson(self, seqid, iprot, oprot):
    args = insertJson_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = insertJson_result()
    try:
      result.success = self._handler.insertJson(args.json, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("insertJson", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_insertJsonRecord(self, seqid, iprot, oprot):
    args = insertJsonRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = insertJsonRecord_result()
    try:
      result.success = self._handler.insertJsonRecord(args.json, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("insertJsonRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_insertJsonRecords(self, seqid, iprot, oprot):
    args = insertJsonRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = insertJsonRecords_result()
    try:
      result.success = self._handler.insertJsonRecords(args.json, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("insertJsonRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_removeKeyValueRecord(self, seqid, iprot, oprot):
    args = removeKeyValueRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeKeyValueRecord_result()
    try:
      result.success = self._handler.removeKeyValueRecord(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("removeKeyValueRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_removeKeyValueRecords(self, seqid, iprot, oprot):
    args = removeKeyValueRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeKeyValueRecords_result()
    try:
      result.success = self._handler.removeKeyValueRecords(args.key, args.value, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("removeKeyValueRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setKeyValueRecord(self, seqid, iprot, oprot):
    args = setKeyValueRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setKeyValueRecord_result()
    try:
      self._handler.setKeyValueRecord(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("setKeyValueRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setKeyValue(self, seqid, iprot, oprot):
    args = setKeyValue_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setKeyValue_result()
    try:
      result.success = self._handler.setKeyValue(args.key, args.value, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("setKeyValue", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setKeyValueRecords(self, seqid, iprot, oprot):
    args = setKeyValueRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setKeyValueRecords_result()
    try:
      self._handler.setKeyValueRecords(args.key, args.value, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("setKeyValueRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_reconcileKeyRecordValues(self, seqid, iprot, oprot):
    args = reconcileKeyRecordValues_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = reconcileKeyRecordValues_result()
    try:
      self._handler.reconcileKeyRecordValues(args.key, args.record, args.values, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("reconcileKeyRecordValues", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_inventory(self, seqid, iprot, oprot):
    args = inventory_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = inventory_result()
    try:
      result.success = self._handler.inventory(args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("inventory", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecord(self, seqid, iprot, oprot):
    args = selectRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecord_result()
    try:
      result.success = self._handler.selectRecord(args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecords(self, seqid, iprot, oprot):
    args = selectRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecords_result()
    try:
      result.success = self._handler.selectRecords(args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecordTime(self, seqid, iprot, oprot):
    args = selectRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecordTime_result()
    try:
      result.success = self._handler.selectRecordTime(args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecordTimestr(self, seqid, iprot, oprot):
    args = selectRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecordTimestr_result()
    try:
      result.success = self._handler.selectRecordTimestr(args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecordsTime(self, seqid, iprot, oprot):
    args = selectRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecordsTime_result()
    try:
      result.success = self._handler.selectRecordsTime(args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecordsTimestr(self, seqid, iprot, oprot):
    args = selectRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecordsTimestr_result()
    try:
      result.success = self._handler.selectRecordsTimestr(args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecord(self, seqid, iprot, oprot):
    args = selectKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecord_result()
    try:
      result.success = self._handler.selectKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecordTime(self, seqid, iprot, oprot):
    args = selectKeyRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecordTime_result()
    try:
      result.success = self._handler.selectKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecordTimestr(self, seqid, iprot, oprot):
    args = selectKeyRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecordTimestr_result()
    try:
      result.success = self._handler.selectKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecord(self, seqid, iprot, oprot):
    args = selectKeysRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecord_result()
    try:
      result.success = self._handler.selectKeysRecord(args.keys, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecordTime(self, seqid, iprot, oprot):
    args = selectKeysRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecordTime_result()
    try:
      result.success = self._handler.selectKeysRecordTime(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecordTimestr(self, seqid, iprot, oprot):
    args = selectKeysRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecordTimestr_result()
    try:
      result.success = self._handler.selectKeysRecordTimestr(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecords(self, seqid, iprot, oprot):
    args = selectKeysRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecords_result()
    try:
      result.success = self._handler.selectKeysRecords(args.keys, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecords(self, seqid, iprot, oprot):
    args = selectKeyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecords_result()
    try:
      result.success = self._handler.selectKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecordsTime(self, seqid, iprot, oprot):
    args = selectKeyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecordsTime_result()
    try:
      result.success = self._handler.selectKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecordsTimestr(self, seqid, iprot, oprot):
    args = selectKeyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecordsTimestr_result()
    try:
      result.success = self._handler.selectKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecordsTime(self, seqid, iprot, oprot):
    args = selectKeysRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecordsTime_result()
    try:
      result.success = self._handler.selectKeysRecordsTime(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecordsTimestr(self, seqid, iprot, oprot):
    args = selectKeysRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecordsTimestr_result()
    try:
      result.success = self._handler.selectKeysRecordsTimestr(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCriteria(self, seqid, iprot, oprot):
    args = selectCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCriteria_result()
    try:
      result.success = self._handler.selectCriteria(args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCcl(self, seqid, iprot, oprot):
    args = selectCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCcl_result()
    try:
      result.success = self._handler.selectCcl(args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCriteriaTime(self, seqid, iprot, oprot):
    args = selectCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCriteriaTime_result()
    try:
      result.success = self._handler.selectCriteriaTime(args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCriteriaTimestr(self, seqid, iprot, oprot):
    args = selectCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCriteriaTimestr_result()
    try:
      result.success = self._handler.selectCriteriaTimestr(args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCclTime(self, seqid, iprot, oprot):
    args = selectCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCclTime_result()
    try:
      result.success = self._handler.selectCclTime(args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCclTimestr(self, seqid, iprot, oprot):
    args = selectCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCclTimestr_result()
    try:
      result.success = self._handler.selectCclTimestr(args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCriteria(self, seqid, iprot, oprot):
    args = selectKeyCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCriteria_result()
    try:
      result.success = self._handler.selectKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCcl(self, seqid, iprot, oprot):
    args = selectKeyCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCcl_result()
    try:
      result.success = self._handler.selectKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCriteriaTime(self, seqid, iprot, oprot):
    args = selectKeyCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCriteriaTime_result()
    try:
      result.success = self._handler.selectKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCriteriaTimestr(self, seqid, iprot, oprot):
    args = selectKeyCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCriteriaTimestr_result()
    try:
      result.success = self._handler.selectKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCclTime(self, seqid, iprot, oprot):
    args = selectKeyCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCclTime_result()
    try:
      result.success = self._handler.selectKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCclTimestr(self, seqid, iprot, oprot):
    args = selectKeyCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCclTimestr_result()
    try:
      result.success = self._handler.selectKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCriteria(self, seqid, iprot, oprot):
    args = selectKeysCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCriteria_result()
    try:
      result.success = self._handler.selectKeysCriteria(args.keys, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCcl(self, seqid, iprot, oprot):
    args = selectKeysCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCcl_result()
    try:
      result.success = self._handler.selectKeysCcl(args.keys, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCriteriaTime(self, seqid, iprot, oprot):
    args = selectKeysCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCriteriaTime_result()
    try:
      result.success = self._handler.selectKeysCriteriaTime(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCriteriaTimestr(self, seqid, iprot, oprot):
    args = selectKeysCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCriteriaTimestr_result()
    try:
      result.success = self._handler.selectKeysCriteriaTimestr(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCclTime(self, seqid, iprot, oprot):
    args = selectKeysCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCclTime_result()
    try:
      result.success = self._handler.selectKeysCclTime(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCclTimestr(self, seqid, iprot, oprot):
    args = selectKeysCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCclTimestr_result()
    try:
      result.success = self._handler.selectKeysCclTimestr(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecord(self, seqid, iprot, oprot):
    args = getKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecord_result()
    try:
      result.success = self._handler.getKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecordTime(self, seqid, iprot, oprot):
    args = getKeyRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecordTime_result()
    try:
      result.success = self._handler.getKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecordTimestr(self, seqid, iprot, oprot):
    args = getKeyRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecordTimestr_result()
    try:
      result.success = self._handler.getKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecord(self, seqid, iprot, oprot):
    args = getKeysRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecord_result()
    try:
      result.success = self._handler.getKeysRecord(args.keys, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecordTime(self, seqid, iprot, oprot):
    args = getKeysRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecordTime_result()
    try:
      result.success = self._handler.getKeysRecordTime(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecordTimestr(self, seqid, iprot, oprot):
    args = getKeysRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecordTimestr_result()
    try:
      result.success = self._handler.getKeysRecordTimestr(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecords(self, seqid, iprot, oprot):
    args = getKeysRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecords_result()
    try:
      result.success = self._handler.getKeysRecords(args.keys, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecords(self, seqid, iprot, oprot):
    args = getKeyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecords_result()
    try:
      result.success = self._handler.getKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecordsTime(self, seqid, iprot, oprot):
    args = getKeyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecordsTime_result()
    try:
      result.success = self._handler.getKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecordsTimestr(self, seqid, iprot, oprot):
    args = getKeyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecordsTimestr_result()
    try:
      result.success = self._handler.getKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecordsTime(self, seqid, iprot, oprot):
    args = getKeysRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecordsTime_result()
    try:
      result.success = self._handler.getKeysRecordsTime(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecordsTimestr(self, seqid, iprot, oprot):
    args = getKeysRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecordsTimestr_result()
    try:
      result.success = self._handler.getKeysRecordsTimestr(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCriteria(self, seqid, iprot, oprot):
    args = getKeyCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCriteria_result()
    try:
      result.success = self._handler.getKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCriteria(self, seqid, iprot, oprot):
    args = getCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCriteria_result()
    try:
      result.success = self._handler.getCriteria(args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCcl(self, seqid, iprot, oprot):
    args = getCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCcl_result()
    try:
      result.success = self._handler.getCcl(args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCriteriaTime(self, seqid, iprot, oprot):
    args = getCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCriteriaTime_result()
    try:
      result.success = self._handler.getCriteriaTime(args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCriteriaTimestr(self, seqid, iprot, oprot):
    args = getCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCriteriaTimestr_result()
    try:
      result.success = self._handler.getCriteriaTimestr(args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCclTime(self, seqid, iprot, oprot):
    args = getCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCclTime_result()
    try:
      result.success = self._handler.getCclTime(args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCclTimestr(self, seqid, iprot, oprot):
    args = getCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCclTimestr_result()
    try:
      result.success = self._handler.getCclTimestr(args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCcl(self, seqid, iprot, oprot):
    args = getKeyCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCcl_result()
    try:
      result.success = self._handler.getKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCriteriaTime(self, seqid, iprot, oprot):
    args = getKeyCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCriteriaTime_result()
    try:
      result.success = self._handler.getKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCriteriaTimestr(self, seqid, iprot, oprot):
    args = getKeyCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCriteriaTimestr_result()
    try:
      result.success = self._handler.getKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCclTime(self, seqid, iprot, oprot):
    args = getKeyCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCclTime_result()
    try:
      result.success = self._handler.getKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCclTimestr(self, seqid, iprot, oprot):
    args = getKeyCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCclTimestr_result()
    try:
      result.success = self._handler.getKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCriteria(self, seqid, iprot, oprot):
    args = getKeysCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCriteria_result()
    try:
      result.success = self._handler.getKeysCriteria(args.keys, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCcl(self, seqid, iprot, oprot):
    args = getKeysCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCcl_result()
    try:
      result.success = self._handler.getKeysCcl(args.keys, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCriteriaTime(self, seqid, iprot, oprot):
    args = getKeysCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCriteriaTime_result()
    try:
      result.success = self._handler.getKeysCriteriaTime(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCriteriaTimestr(self, seqid, iprot, oprot):
    args = getKeysCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCriteriaTimestr_result()
    try:
      result.success = self._handler.getKeysCriteriaTimestr(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCclTime(self, seqid, iprot, oprot):
    args = getKeysCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCclTime_result()
    try:
      result.success = self._handler.getKeysCclTime(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCclTimestr(self, seqid, iprot, oprot):
    args = getKeysCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCclTimestr_result()
    try:
      result.success = self._handler.getKeysCclTimestr(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_verifyKeyValueRecord(self, seqid, iprot, oprot):
    args = verifyKeyValueRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = verifyKeyValueRecord_result()
    try:
      result.success = self._handler.verifyKeyValueRecord(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("verifyKeyValueRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_verifyKeyValueRecordTime(self, seqid, iprot, oprot):
    args = verifyKeyValueRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = verifyKeyValueRecordTime_result()
    try:
      result.success = self._handler.verifyKeyValueRecordTime(args.key, args.value, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("verifyKeyValueRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_verifyKeyValueRecordTimestr(self, seqid, iprot, oprot):
    args = verifyKeyValueRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = verifyKeyValueRecordTimestr_result()
    try:
      result.success = self._handler.verifyKeyValueRecordTimestr(args.key, args.value, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("verifyKeyValueRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_jsonifyRecords(self, seqid, iprot, oprot):
    args = jsonifyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = jsonifyRecords_result()
    try:
      result.success = self._handler.jsonifyRecords(args.records, args.identifier, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("jsonifyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_jsonifyRecordsTime(self, seqid, iprot, oprot):
    args = jsonifyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = jsonifyRecordsTime_result()
    try:
      result.success = self._handler.jsonifyRecordsTime(args.records, args.timestamp, args.identifier, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("jsonifyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_jsonifyRecordsTimestr(self, seqid, iprot, oprot):
    args = jsonifyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = jsonifyRecordsTimestr_result()
    try:
      result.success = self._handler.jsonifyRecordsTimestr(args.records, args.timestamp, args.identifier, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("jsonifyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findCriteria(self, seqid, iprot, oprot):
    args = findCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findCriteria_result()
    try:
      result.success = self._handler.findCriteria(args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findCcl(self, seqid, iprot, oprot):
    args = findCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findCcl_result()
    try:
      result.success = self._handler.findCcl(args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorValues(self, seqid, iprot, oprot):
    args = findKeyOperatorValues_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorValues_result()
    try:
      result.success = self._handler.findKeyOperatorValues(args.key, args.operator, args.values, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorValues", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorValuesTime(self, seqid, iprot, oprot):
    args = findKeyOperatorValuesTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorValuesTime_result()
    try:
      result.success = self._handler.findKeyOperatorValuesTime(args.key, args.operator, args.values, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorValuesTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorValuesTimestr(self, seqid, iprot, oprot):
    args = findKeyOperatorValuesTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorValuesTimestr_result()
    try:
      result.success = self._handler.findKeyOperatorValuesTimestr(args.key, args.operator, args.values, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorValuesTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorstrValues(self, seqid, iprot, oprot):
    args = findKeyOperatorstrValues_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorstrValues_result()
    try:
      result.success = self._handler.findKeyOperatorstrValues(args.key, args.operator, args.values, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorstrValues", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorstrValuesTime(self, seqid, iprot, oprot):
    args = findKeyOperatorstrValuesTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorstrValuesTime_result()
    try:
      result.success = self._handler.findKeyOperatorstrValuesTime(args.key, args.operator, args.values, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorstrValuesTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorstrValuesTimestr(self, seqid, iprot, oprot):
    args = findKeyOperatorstrValuesTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorstrValuesTimestr_result()
    try:
      result.success = self._handler.findKeyOperatorstrValuesTimestr(args.key, args.operator, args.values, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorstrValuesTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_search(self, seqid, iprot, oprot):
    args = search_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = search_result()
    try:
      result.success = self._handler.search(args.key, args.query, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("search", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeysRecordsTime(self, seqid, iprot, oprot):
    args = revertKeysRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeysRecordsTime_result()
    try:
      self._handler.revertKeysRecordsTime(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeysRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeysRecordsTimestr(self, seqid, iprot, oprot):
    args = revertKeysRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeysRecordsTimestr_result()
    try:
      self._handler.revertKeysRecordsTimestr(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeysRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeysRecordTime(self, seqid, iprot, oprot):
    args = revertKeysRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeysRecordTime_result()
    try:
      self._handler.revertKeysRecordTime(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeysRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeysRecordTimestr(self, seqid, iprot, oprot):
    args = revertKeysRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeysRecordTimestr_result()
    try:
      self._handler.revertKeysRecordTimestr(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeysRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeyRecordsTime(self, seqid, iprot, oprot):
    args = revertKeyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeyRecordsTime_result()
    try:
      self._handler.revertKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeyRecordsTimestr(self, seqid, iprot, oprot):
    args = revertKeyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeyRecordsTimestr_result()
    try:
      self._handler.revertKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeyRecordTime(self, seqid, iprot, oprot):
    args = revertKeyRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeyRecordTime_result()
    try:
      self._handler.revertKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeyRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeyRecordTimestr(self, seqid, iprot, oprot):
    args = revertKeyRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeyRecordTimestr_result()
    try:
      self._handler.revertKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeyRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_pingRecords(self, seqid, iprot, oprot):
    args = pingRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = pingRecords_result()
    try:
      result.success = self._handler.pingRecords(args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("pingRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_pingRecord(self, seqid, iprot, oprot):
    args = pingRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = pingRecord_result()
    try:
      result.success = self._handler.pingRecord(args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("pingRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_verifyAndSwap(self, seqid, iprot, oprot):
    args = verifyAndSwap_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = verifyAndSwap_result()
    try:
      result.success = self._handler.verifyAndSwap(args.key, args.expected, args.record, args.replacement, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("verifyAndSwap", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_verifyOrSet(self, seqid, iprot, oprot):
    args = verifyOrSet_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = verifyOrSet_result()
    try:
      self._handler.verifyOrSet(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("verifyOrSet", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findOrAddKeyValue(self, seqid, iprot, oprot):
    args = findOrAddKeyValue_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findOrAddKeyValue_result()
    try:
      result.success = self._handler.findOrAddKeyValue(args.key, args.value, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except DuplicateEntryException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except InvalidArgumentException as ex4:
      msg_type = TMessageType.REPLY
      result.ex4 = ex4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findOrAddKeyValue", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findOrInsertCriteriaJson(self, seqid, iprot, oprot):
    args = findOrInsertCriteriaJson_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findOrInsertCriteriaJson_result()
    try:
      result.success = self._handler.findOrInsertCriteriaJson(args.criteria, args.json, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except DuplicateEntryException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findOrInsertCriteriaJson", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findOrInsertCclJson(self, seqid, iprot, oprot):
    args = findOrInsertCclJson_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findOrInsertCclJson_result()
    try:
      result.success = self._handler.findOrInsertCclJson(args.ccl, args.json, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except DuplicateEntryException as ex4:
      msg_type = TMessageType.REPLY
      result.ex4 = ex4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findOrInsertCclJson", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sumKeyRecord(self, seqid, iprot, oprot):
    args = sumKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sumKeyRecord_result()
    try:
      result.success = self._handler.sumKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("sumKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sumKeyRecordTime(self, seqid, iprot, oprot):
    args = sumKeyRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sumKeyRecordTime_result()
    try:
      result.success = self._handler.sumKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("sumKeyRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sumKeyRecordTimestr(self, seqid, iprot, oprot):
    args = sumKeyRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sumKeyRecordTimestr_result()
    try:
      result.success = self._handler.sumKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("sumKeyRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sumKeyRecords(self, seqid, iprot, oprot):
    args = sumKeyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sumKeyRecords_result()
    try:
      result.success = self._handler.sumKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("sumKeyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sumKeyRecordsTime(self, seqid, iprot, oprot):
    args = sumKeyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sumKeyRecordsTime_result()
    try:
      result.success = self._handler.sumKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("sumKeyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sumKeyRecordsTimestr(self, seqid, iprot, oprot):
    args = sumKeyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sumKeyRecordsTimestr_result()
    try:
      result.success = self._handler.sumKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("sumKeyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sumKey(self, seqid, iprot, oprot):
    args = sumKey_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sumKey_result()
    try:
      result.success = self._handler.sumKey(args.key, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("sumKey", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sumKeyTime(self, seqid, iprot, oprot):
    args = sumKeyTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sumKeyTime_result()
    try:
      result.success = self._handler.sumKeyTime(args.key, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("sumKeyTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sumKeyTimestr(self, seqid, iprot, oprot):
    args = sumKeyTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sumKeyTimestr_result()
    try:
      result.success = self._handler.sumKeyTimestr(args.key, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("sumKeyTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sumKeyCriteria(self, seqid, iprot, oprot):
    args = sumKeyCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sumKeyCriteria_result()
    try:
      result.success = self._handler.sumKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("sumKeyCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sumKeyCriteriaTime(self, seqid, iprot, oprot):
    args = sumKeyCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sumKeyCriteriaTime_result()
    try:
      result.success = self._handler.sumKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("sumKeyCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sumKeyCriteriaTimestr(self, seqid, iprot, oprot):
    args = sumKeyCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sumKeyCriteriaTimestr_result()
    try:
      result.success = self._handler.sumKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("sumKeyCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sumKeyCcl(self, seqid, iprot, oprot):
    args = sumKeyCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sumKeyCcl_result()
    try:
      result.success = self._handler.sumKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("sumKeyCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sumKeyCclTime(self, seqid, iprot, oprot):
    args = sumKeyCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sumKeyCclTime_result()
    try:
      result.success = self._handler.sumKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("sumKeyCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sumKeyCclTimestr(self, seqid, iprot, oprot):
    args = sumKeyCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sumKeyCclTimestr_result()
    try:
      result.success = self._handler.sumKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("sumKeyCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_averageKeyRecord(self, seqid, iprot, oprot):
    args = averageKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = averageKeyRecord_result()
    try:
      result.success = self._handler.averageKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("averageKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_averageKeyRecordTime(self, seqid, iprot, oprot):
    args = averageKeyRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = averageKeyRecordTime_result()
    try:
      result.success = self._handler.averageKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("averageKeyRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_averageKeyRecordTimestr(self, seqid, iprot, oprot):
    args = averageKeyRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = averageKeyRecordTimestr_result()
    try:
      result.success = self._handler.averageKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("averageKeyRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_averageKeyRecords(self, seqid, iprot, oprot):
    args = averageKeyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = averageKeyRecords_result()
    try:
      result.success = self._handler.averageKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("averageKeyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_averageKeyRecordsTime(self, seqid, iprot, oprot):
    args = averageKeyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = averageKeyRecordsTime_result()
    try:
      result.success = self._handler.averageKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("averageKeyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_averageKeyRecordsTimestr(self, seqid, iprot, oprot):
    args = averageKeyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = averageKeyRecordsTimestr_result()
    try:
      result.success = self._handler.averageKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("averageKeyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_averageKey(self, seqid, iprot, oprot):
    args = averageKey_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = averageKey_result()
    try:
      result.success = self._handler.averageKey(args.key, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("averageKey", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_averageKeyTime(self, seqid, iprot, oprot):
    args = averageKeyTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = averageKeyTime_result()
    try:
      result.success = self._handler.averageKeyTime(args.key, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("averageKeyTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_averageKeyTimestr(self, seqid, iprot, oprot):
    args = averageKeyTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = averageKeyTimestr_result()
    try:
      result.success = self._handler.averageKeyTimestr(args.key, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("averageKeyTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_averageKeyCriteria(self, seqid, iprot, oprot):
    args = averageKeyCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = averageKeyCriteria_result()
    try:
      result.success = self._handler.averageKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("averageKeyCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_averageKeyCriteriaTime(self, seqid, iprot, oprot):
    args = averageKeyCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = averageKeyCriteriaTime_result()
    try:
      result.success = self._handler.averageKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("averageKeyCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_averageKeyCriteriaTimestr(self, seqid, iprot, oprot):
    args = averageKeyCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = averageKeyCriteriaTimestr_result()
    try:
      result.success = self._handler.averageKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("averageKeyCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_averageKeyCcl(self, seqid, iprot, oprot):
    args = averageKeyCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = averageKeyCcl_result()
    try:
      result.success = self._handler.averageKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("averageKeyCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_averageKeyCclTime(self, seqid, iprot, oprot):
    args = averageKeyCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = averageKeyCclTime_result()
    try:
      result.success = self._handler.averageKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("averageKeyCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_averageKeyCclTimestr(self, seqid, iprot, oprot):
    args = averageKeyCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = averageKeyCclTimestr_result()
    try:
      result.success = self._handler.averageKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("averageKeyCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_countKeyRecord(self, seqid, iprot, oprot):
    args = countKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = countKeyRecord_result()
    try:
      result.success = self._handler.countKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("countKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_countKeyRecordTime(self, seqid, iprot, oprot):
    args = countKeyRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = countKeyRecordTime_result()
    try:
      result.success = self._handler.countKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("countKeyRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_countKeyRecordTimestr(self, seqid, iprot, oprot):
    args = countKeyRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = countKeyRecordTimestr_result()
    try:
      result.success = self._handler.countKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("countKeyRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_countKeyRecords(self, seqid, iprot, oprot):
    args = countKeyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = countKeyRecords_result()
    try:
      result.success = self._handler.countKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("countKeyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_countKeyRecordsTime(self, seqid, iprot, oprot):
    args = countKeyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = countKeyRecordsTime_result()
    try:
      result.success = self._handler.countKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("countKeyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_countKeyRecordsTimestr(self, seqid, iprot, oprot):
    args = countKeyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = countKeyRecordsTimestr_result()
    try:
      result.success = self._handler.countKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("countKeyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_countKey(self, seqid, iprot, oprot):
    args = countKey_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = countKey_result()
    try:
      result.success = self._handler.countKey(args.key, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("countKey", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_countKeyTime(self, seqid, iprot, oprot):
    args = countKeyTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = countKeyTime_result()
    try:
      result.success = self._handler.countKeyTime(args.key, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("countKeyTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_countKeyTimestr(self, seqid, iprot, oprot):
    args = countKeyTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = countKeyTimestr_result()
    try:
      result.success = self._handler.countKeyTimestr(args.key, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("countKeyTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_countKeyCriteria(self, seqid, iprot, oprot):
    args = countKeyCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = countKeyCriteria_result()
    try:
      result.success = self._handler.countKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("countKeyCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_countKeyCriteriaTime(self, seqid, iprot, oprot):
    args = countKeyCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = countKeyCriteriaTime_result()
    try:
      result.success = self._handler.countKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("countKeyCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_countKeyCriteriaTimestr(self, seqid, iprot, oprot):
    args = countKeyCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = countKeyCriteriaTimestr_result()
    try:
      result.success = self._handler.countKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("countKeyCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_countKeyCcl(self, seqid, iprot, oprot):
    args = countKeyCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = countKeyCcl_result()
    try:
      result.success = self._handler.countKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("countKeyCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_countKeyCclTime(self, seqid, iprot, oprot):
    args = countKeyCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = countKeyCclTime_result()
    try:
      result.success = self._handler.countKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("countKeyCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_countKeyCclTimestr(self, seqid, iprot, oprot):
    args = countKeyCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = countKeyCclTimestr_result()
    try:
      result.success = self._handler.countKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("countKeyCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_maxKeyRecord(self, seqid, iprot, oprot):
    args = maxKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = maxKeyRecord_result()
    try:
      result.success = self._handler.maxKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("maxKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_maxKeyRecordTime(self, seqid, iprot, oprot):
    args = maxKeyRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = maxKeyRecordTime_result()
    try:
      result.success = self._handler.maxKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("maxKeyRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_maxKeyRecordTimestr(self, seqid, iprot, oprot):
    args = maxKeyRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = maxKeyRecordTimestr_result()
    try:
      result.success = self._handler.maxKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("maxKeyRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_maxKeyRecords(self, seqid, iprot, oprot):
    args = maxKeyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = maxKeyRecords_result()
    try:
      result.success = self._handler.maxKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("maxKeyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_maxKeyRecordsTime(self, seqid, iprot, oprot):
    args = maxKeyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = maxKeyRecordsTime_result()
    try:
      result.success = self._handler.maxKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("maxKeyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_maxKeyRecordsTimestr(self, seqid, iprot, oprot):
    args = maxKeyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = maxKeyRecordsTimestr_result()
    try:
      result.success = self._handler.maxKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("maxKeyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_maxKeyCriteria(self, seqid, iprot, oprot):
    args = maxKeyCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = maxKeyCriteria_result()
    try:
      result.success = self._handler.maxKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("maxKeyCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_maxKeyCriteriaTime(self, seqid, iprot, oprot):
    args = maxKeyCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = maxKeyCriteriaTime_result()
    try:
      result.success = self._handler.maxKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("maxKeyCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_maxKeyCriteriaTimestr(self, seqid, iprot, oprot):
    args = maxKeyCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = maxKeyCriteriaTimestr_result()
    try:
      result.success = self._handler.maxKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("maxKeyCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_maxKeyCcl(self, seqid, iprot, oprot):
    args = maxKeyCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = maxKeyCcl_result()
    try:
      result.success = self._handler.maxKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("maxKeyCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_maxKeyCclTime(self, seqid, iprot, oprot):
    args = maxKeyCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = maxKeyCclTime_result()
    try:
      result.success = self._handler.maxKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("maxKeyCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_maxKeyCclTimestr(self, seqid, iprot, oprot):
    args = maxKeyCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = maxKeyCclTimestr_result()
    try:
      result.success = self._handler.maxKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("maxKeyCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_maxKey(self, seqid, iprot, oprot):
    args = maxKey_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = maxKey_result()
    try:
      result.success = self._handler.maxKey(args.key, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("maxKey", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_maxKeyTime(self, seqid, iprot, oprot):
    args = maxKeyTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = maxKeyTime_result()
    try:
      result.success = self._handler.maxKeyTime(args.key, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("maxKeyTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_maxKeyTimestr(self, seqid, iprot, oprot):
    args = maxKeyTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = maxKeyTimestr_result()
    try:
      result.success = self._handler.maxKeyTimestr(args.key, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("maxKeyTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_minKeyRecord(self, seqid, iprot, oprot):
    args = minKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = minKeyRecord_result()
    try:
      result.success = self._handler.minKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("minKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_minKeyRecordTime(self, seqid, iprot, oprot):
    args = minKeyRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = minKeyRecordTime_result()
    try:
      result.success = self._handler.minKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("minKeyRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_minKeyRecordTimestr(self, seqid, iprot, oprot):
    args = minKeyRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = minKeyRecordTimestr_result()
    try:
      result.success = self._handler.minKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("minKeyRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_minKey(self, seqid, iprot, oprot):
    args = minKey_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = minKey_result()
    try:
      result.success = self._handler.minKey(args.key, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("minKey", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_minKeyRecordsTime(self, seqid, iprot, oprot):
    args = minKeyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = minKeyRecordsTime_result()
    try:
      result.success = self._handler.minKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("minKeyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_minKeyRecordsTimestr(self, seqid, iprot, oprot):
    args = minKeyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = minKeyRecordsTimestr_result()
    try:
      result.success = self._handler.minKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("minKeyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_minKeyCriteria(self, seqid, iprot, oprot):
    args = minKeyCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = minKeyCriteria_result()
    try:
      result.success = self._handler.minKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("minKeyCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_minKeyCriteriaTime(self, seqid, iprot, oprot):
    args = minKeyCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = minKeyCriteriaTime_result()
    try:
      result.success = self._handler.minKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("minKeyCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_minKeyCriteriaTimestr(self, seqid, iprot, oprot):
    args = minKeyCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = minKeyCriteriaTimestr_result()
    try:
      result.success = self._handler.minKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("minKeyCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_minKeyCcl(self, seqid, iprot, oprot):
    args = minKeyCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = minKeyCcl_result()
    try:
      result.success = self._handler.minKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("minKeyCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_minKeyCclTime(self, seqid, iprot, oprot):
    args = minKeyCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = minKeyCclTime_result()
    try:
      result.success = self._handler.minKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("minKeyCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_minKeyCclTimestr(self, seqid, iprot, oprot):
    args = minKeyCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = minKeyCclTimestr_result()
    try:
      result.success = self._handler.minKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("minKeyCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_minKeyTime(self, seqid, iprot, oprot):
    args = minKeyTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = minKeyTime_result()
    try:
      result.success = self._handler.minKeyTime(args.key, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("minKeyTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_minKeyTimestr(self, seqid, iprot, oprot):
    args = minKeyTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = minKeyTimestr_result()
    try:
      result.success = self._handler.minKeyTimestr(args.key, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("minKeyTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_minKeyRecords(self, seqid, iprot, oprot):
    args = minKeyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = minKeyRecords_result()
    try:
      result.success = self._handler.minKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("minKeyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeyRecord(self, seqid, iprot, oprot):
    args = navigateKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeyRecord_result()
    try:
      result.success = self._handler.navigateKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeyRecordTime(self, seqid, iprot, oprot):
    args = navigateKeyRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeyRecordTime_result()
    try:
      result.success = self._handler.navigateKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeyRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeyRecordTimestr(self, seqid, iprot, oprot):
    args = navigateKeyRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeyRecordTimestr_result()
    try:
      result.success = self._handler.navigateKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeyRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeysRecord(self, seqid, iprot, oprot):
    args = navigateKeysRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeysRecord_result()
    try:
      result.success = self._handler.navigateKeysRecord(args.keys, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeysRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeysRecordTime(self, seqid, iprot, oprot):
    args = navigateKeysRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeysRecordTime_result()
    try:
      result.success = self._handler.navigateKeysRecordTime(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeysRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeysRecordTimestr(self, seqid, iprot, oprot):
    args = navigateKeysRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeysRecordTimestr_result()
    try:
      result.success = self._handler.navigateKeysRecordTimestr(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeysRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeysRecords(self, seqid, iprot, oprot):
    args = navigateKeysRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeysRecords_result()
    try:
      result.success = self._handler.navigateKeysRecords(args.keys, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeysRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeyRecords(self, seqid, iprot, oprot):
    args = navigateKeyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeyRecords_result()
    try:
      result.success = self._handler.navigateKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeyRecordsTime(self, seqid, iprot, oprot):
    args = navigateKeyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeyRecordsTime_result()
    try:
      result.success = self._handler.navigateKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeyRecordsTimestr(self, seqid, iprot, oprot):
    args = navigateKeyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeyRecordsTimestr_result()
    try:
      result.success = self._handler.navigateKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeysRecordsTime(self, seqid, iprot, oprot):
    args = navigateKeysRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeysRecordsTime_result()
    try:
      result.success = self._handler.navigateKeysRecordsTime(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeysRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeysRecordsTimestr(self, seqid, iprot, oprot):
    args = navigateKeysRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeysRecordsTimestr_result()
    try:
      result.success = self._handler.navigateKeysRecordsTimestr(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeysRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeyCcl(self, seqid, iprot, oprot):
    args = navigateKeyCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeyCcl_result()
    try:
      result.success = self._handler.navigateKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeyCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeyCclTime(self, seqid, iprot, oprot):
    args = navigateKeyCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeyCclTime_result()
    try:
      result.success = self._handler.navigateKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeyCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeyCclTimestr(self, seqid, iprot, oprot):
    args = navigateKeyCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeyCclTimestr_result()
    try:
      result.success = self._handler.navigateKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeyCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeysCcl(self, seqid, iprot, oprot):
    args = navigateKeysCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeysCcl_result()
    try:
      result.success = self._handler.navigateKeysCcl(args.keys, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeysCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeysCclTime(self, seqid, iprot, oprot):
    args = navigateKeysCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeysCclTime_result()
    try:
      result.success = self._handler.navigateKeysCclTime(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeysCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeysCclTimestr(self, seqid, iprot, oprot):
    args = navigateKeysCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeysCclTimestr_result()
    try:
      result.success = self._handler.navigateKeysCclTimestr(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeysCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeyCriteria(self, seqid, iprot, oprot):
    args = navigateKeyCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeyCriteria_result()
    try:
      result.success = self._handler.navigateKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeyCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeyCriteriaTime(self, seqid, iprot, oprot):
    args = navigateKeyCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeyCriteriaTime_result()
    try:
      result.success = self._handler.navigateKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeyCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeyCriteriaTimestr(self, seqid, iprot, oprot):
    args = navigateKeyCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeyCriteriaTimestr_result()
    try:
      result.success = self._handler.navigateKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeyCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeysCriteria(self, seqid, iprot, oprot):
    args = navigateKeysCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeysCriteria_result()
    try:
      result.success = self._handler.navigateKeysCriteria(args.keys, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeysCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeysCriteriaTime(self, seqid, iprot, oprot):
    args = navigateKeysCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeysCriteriaTime_result()
    try:
      result.success = self._handler.navigateKeysCriteriaTime(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeysCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_navigateKeysCriteriaTimestr(self, seqid, iprot, oprot):
    args = navigateKeysCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = navigateKeysCriteriaTimestr_result()
    try:
      result.success = self._handler.navigateKeysCriteriaTimestr(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("navigateKeysCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getServerEnvironment(self, seqid, iprot, oprot):
    args = getServerEnvironment_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getServerEnvironment_result()
    try:
      result.success = self._handler.getServerEnvironment(args.creds, args.token, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getServerEnvironment", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getServerVersion(self, seqid, iprot, oprot):
    args = getServerVersion_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getServerVersion_result()
    try:
      result.success = self._handler.getServerVersion()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getServerVersion", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time(self, seqid, iprot, oprot):
    args = time_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time_result()
    try:
      result.success = self._handler.time(args.creds, args.token, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("time", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_timePhrase(self, seqid, iprot, oprot):
    args = timePhrase_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = timePhrase_result()
    try:
      result.success = self._handler.timePhrase(args.phrase, args.creds, args.token, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("timePhrase", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class abort_args:
  """
  Attributes:
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, creds=None, transaction=None, environment=None,):
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abort_args')
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 1)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 2)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abort_result:
  """
  Attributes:
   - ex
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, ex=None,):
    self.ex = ex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abort_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValue_args:
  """
  Attributes:
   - key
   - value
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, value=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValue_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValue_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValue_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValueRecord_args:
  """
  Attributes:
   - key
   - value
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValueRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValueRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValueRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValueRecords_args:
  """
  Attributes:
   - key
   - value
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.LIST, 'records', (TType.I64,None), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.records = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in range(_size0):
            _elem5 = iprot.readI64()
            self.records.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValueRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter6 in self.records:
        oprot.writeI64(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValueRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.BOOL,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin()
          for _i11 in range(_size7):
            _key12 = iprot.readI64()
            _val13 = iprot.readBool()
            self.success[_key12] = _val13
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValueRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.BOOL, len(self.success))
      for kiter14,viter15 in list(self.success.items()):
        oprot.writeI64(kiter14)
        oprot.writeBool(viter15)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecord_args:
  """
  Attributes:
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, record=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype17, _vtype18, _size16 ) = iprot.readMapBegin()
          for _i20 in range(_size16):
            _key21 = iprot.readI64()
            _val22 = iprot.readString()
            self.success[_key21] = _val22
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter23,viter24 in list(self.success.items()):
        oprot.writeI64(kiter23)
        oprot.writeString(viter24)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStart_args:
  """
  Attributes:
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStart_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype26, _vtype27, _size25 ) = iprot.readMapBegin()
          for _i29 in range(_size25):
            _key30 = iprot.readI64()
            _val31 = iprot.readString()
            self.success[_key30] = _val31
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter32,viter33 in list(self.success.items()):
        oprot.writeI64(kiter32)
        oprot.writeString(viter33)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartstr_args:
  """
  Attributes:
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartstr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype35, _vtype36, _size34 ) = iprot.readMapBegin()
          for _i38 in range(_size34):
            _key39 = iprot.readI64()
            _val40 = iprot.readString()
            self.success[_key39] = _val40
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter41,viter42 in list(self.success.items()):
        oprot.writeI64(kiter41)
        oprot.writeString(viter42)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartEnd_args:
  """
  Attributes:
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.I64, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartEnd_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 3)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype44, _vtype45, _size43 ) = iprot.readMapBegin()
          for _i47 in range(_size43):
            _key48 = iprot.readI64()
            _val49 = iprot.readString()
            self.success[_key48] = _val49
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter50,viter51 in list(self.success.items()):
        oprot.writeI64(kiter50)
        oprot.writeString(viter51)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartstrEndstr_args:
  """
  Attributes:
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRING, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartstrEndstr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 3)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype53, _vtype54, _size52 ) = iprot.readMapBegin()
          for _i56 in range(_size52):
            _key57 = iprot.readI64()
            _val58 = iprot.readString()
            self.success[_key57] = _val58
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter59,viter60 in list(self.success.items()):
        oprot.writeI64(kiter59)
        oprot.writeString(viter60)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype62, _vtype63, _size61 ) = iprot.readMapBegin()
          for _i65 in range(_size61):
            _key66 = iprot.readI64()
            _val67 = iprot.readString()
            self.success[_key66] = _val67
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter68,viter69 in list(self.success.items()):
        oprot.writeI64(kiter68)
        oprot.writeString(viter69)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStart_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStart_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype71, _vtype72, _size70 ) = iprot.readMapBegin()
          for _i74 in range(_size70):
            _key75 = iprot.readI64()
            _val76 = iprot.readString()
            self.success[_key75] = _val76
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter77,viter78 in list(self.success.items()):
        oprot.writeI64(kiter77)
        oprot.writeString(viter78)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype80, _vtype81, _size79 ) = iprot.readMapBegin()
          for _i83 in range(_size79):
            _key84 = iprot.readI64()
            _val85 = iprot.readString()
            self.success[_key84] = _val85
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter86,viter87 in list(self.success.items()):
        oprot.writeI64(kiter86)
        oprot.writeString(viter87)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartEnd_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.I64, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartEnd_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 4)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype89, _vtype90, _size88 ) = iprot.readMapBegin()
          for _i92 in range(_size88):
            _key93 = iprot.readI64()
            _val94 = iprot.readString()
            self.success[_key93] = _val94
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter95,viter96 in list(self.success.items()):
        oprot.writeI64(kiter95)
        oprot.writeString(viter96)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartstrEndstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRING, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartstrEndstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 4)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype98, _vtype99, _size97 ) = iprot.readMapBegin()
          for _i101 in range(_size97):
            _key102 = iprot.readI64()
            _val103 = iprot.readString()
            self.success[_key102] = _val103
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter104,viter105 in list(self.success.items()):
        oprot.writeI64(kiter104)
        oprot.writeString(viter105)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKey_args:
  """
  Attributes:
   - key
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, key=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKey_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKey_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype107, _vtype108, _size106 ) = iprot.readMapBegin()
          for _i110 in range(_size106):
            _key111 = TObject()
            _key111.read(iprot)
            _val112 = []
            (_etype116, _size113) = iprot.readSetBegin()
            for _i117 in range(_size113):
              _elem118 = iprot.readI64()
              _val112.append(_elem118)
            iprot.readSetEnd()
            self.success[_key111] = _val112
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKey_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.SET, len(self.success))
      for kiter119,viter120 in list(self.success.items()):
        kiter119.write(oprot)
        oprot.writeSetBegin(TType.I64, len(viter120))
        for iter121 in viter120:
          oprot.writeI64(iter121)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeys_args:
  """
  Attributes:
   - keys
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, keys=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype125, _size122) = iprot.readListBegin()
          for _i126 in range(_size122):
            _elem127 = iprot.readString()
            self.keys.append(_elem127)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeys_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter128 in self.keys:
        oprot.writeString(iter128)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeys_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype130, _vtype131, _size129 ) = iprot.readMapBegin()
          for _i133 in range(_size129):
            _key134 = iprot.readString()
            _val135 = {}
            (_ktype137, _vtype138, _size136 ) = iprot.readMapBegin()
            for _i140 in range(_size136):
              _key141 = TObject()
              _key141.read(iprot)
              _val142 = []
              (_etype146, _size143) = iprot.readSetBegin()
              for _i147 in range(_size143):
                _elem148 = iprot.readI64()
                _val142.append(_elem148)
              iprot.readSetEnd()
              _val135[_key141] = _val142
            iprot.readMapEnd()
            self.success[_key134] = _val135
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeys_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter149,viter150 in list(self.success.items()):
        oprot.writeString(kiter149)
        oprot.writeMapBegin(TType.STRUCT, TType.SET, len(viter150))
        for kiter151,viter152 in list(viter150.items()):
          kiter151.write(oprot)
          oprot.writeSetBegin(TType.I64, len(viter152))
          for iter153 in viter152:
            oprot.writeI64(iter153)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeyTime_args:
  """
  Attributes:
   - key
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeyTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeyTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype155, _vtype156, _size154 ) = iprot.readMapBegin()
          for _i158 in range(_size154):
            _key159 = TObject()
            _key159.read(iprot)
            _val160 = []
            (_etype164, _size161) = iprot.readSetBegin()
            for _i165 in range(_size161):
              _elem166 = iprot.readI64()
              _val160.append(_elem166)
            iprot.readSetEnd()
            self.success[_key159] = _val160
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeyTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.SET, len(self.success))
      for kiter167,viter168 in list(self.success.items()):
        kiter167.write(oprot)
        oprot.writeSetBegin(TType.I64, len(viter168))
        for iter169 in viter168:
          oprot.writeI64(iter169)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeyTimestr_args:
  """
  Attributes:
   - key
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeyTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeyTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype171, _vtype172, _size170 ) = iprot.readMapBegin()
          for _i174 in range(_size170):
            _key175 = TObject()
            _key175.read(iprot)
            _val176 = []
            (_etype180, _size177) = iprot.readSetBegin()
            for _i181 in range(_size177):
              _elem182 = iprot.readI64()
              _val176.append(_elem182)
            iprot.readSetEnd()
            self.success[_key175] = _val176
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeyTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.SET, len(self.success))
      for kiter183,viter184 in list(self.success.items()):
        kiter183.write(oprot)
        oprot.writeSetBegin(TType.I64, len(viter184))
        for iter185 in viter184:
          oprot.writeI64(iter185)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeysTime_args:
  """
  Attributes:
   - keys
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype189, _size186) = iprot.readListBegin()
          for _i190 in range(_size186):
            _elem191 = iprot.readString()
            self.keys.append(_elem191)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeysTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter192 in self.keys:
        oprot.writeString(iter192)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeysTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype194, _vtype195, _size193 ) = iprot.readMapBegin()
          for _i197 in range(_size193):
            _key198 = iprot.readString()
            _val199 = {}
            (_ktype201, _vtype202, _size200 ) = iprot.readMapBegin()
            for _i204 in range(_size200):
              _key205 = TObject()
              _key205.read(iprot)
              _val206 = []
              (_etype210, _size207) = iprot.readSetBegin()
              for _i211 in range(_size207):
                _elem212 = iprot.readI64()
                _val206.append(_elem212)
              iprot.readSetEnd()
              _val199[_key205] = _val206
            iprot.readMapEnd()
            self.success[_key198] = _val199
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeysTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter213,viter214 in list(self.success.items()):
        oprot.writeString(kiter213)
        oprot.writeMapBegin(TType.STRUCT, TType.SET, len(viter214))
        for kiter215,viter216 in list(viter214.items()):
          kiter215.write(oprot)
          oprot.writeSetBegin(TType.I64, len(viter216))
          for iter217 in viter216:
            oprot.writeI64(iter217)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeysTimestr_args:
  """
  Attributes:
   - keys
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype221, _size218) = iprot.readListBegin()
          for _i222 in range(_size218):
            _elem223 = iprot.readString()
            self.keys.append(_elem223)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeysTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter224 in self.keys:
        oprot.writeString(iter224)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeysTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype226, _vtype227, _size225 ) = iprot.readMapBegin()
          for _i229 in range(_size225):
            _key230 = iprot.readString()
            _val231 = {}
            (_ktype233, _vtype234, _size232 ) = iprot.readMapBegin()
            for _i236 in range(_size232):
              _key237 = TObject()
              _key237.read(iprot)
              _val238 = []
              (_etype242, _size239) = iprot.readSetBegin()
              for _i243 in range(_size239):
                _elem244 = iprot.readI64()
                _val238.append(_elem244)
              iprot.readSetEnd()
              _val231[_key237] = _val238
            iprot.readMapEnd()
            self.success[_key230] = _val231
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeysTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter245,viter246 in list(self.success.items()):
        oprot.writeString(kiter245)
        oprot.writeMapBegin(TType.STRUCT, TType.SET, len(viter246))
        for kiter247,viter248 in list(viter246.items()):
          kiter247.write(oprot)
          oprot.writeSetBegin(TType.I64, len(viter248))
          for iter249 in viter248:
            oprot.writeI64(iter249)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype251, _vtype252, _size250 ) = iprot.readMapBegin()
          for _i254 in range(_size250):
            _key255 = iprot.readI64()
            _val256 = []
            (_etype260, _size257) = iprot.readSetBegin()
            for _i261 in range(_size257):
              _elem262 = TObject()
              _elem262.read(iprot)
              _val256.append(_elem262)
            iprot.readSetEnd()
            self.success[_key255] = _val256
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter263,viter264 in list(self.success.items()):
        oprot.writeI64(kiter263)
        oprot.writeSetBegin(TType.STRUCT, len(viter264))
        for iter265 in viter264:
          iter265.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStart_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStart_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype267, _vtype268, _size266 ) = iprot.readMapBegin()
          for _i270 in range(_size266):
            _key271 = iprot.readI64()
            _val272 = []
            (_etype276, _size273) = iprot.readSetBegin()
            for _i277 in range(_size273):
              _elem278 = TObject()
              _elem278.read(iprot)
              _val272.append(_elem278)
            iprot.readSetEnd()
            self.success[_key271] = _val272
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter279,viter280 in list(self.success.items()):
        oprot.writeI64(kiter279)
        oprot.writeSetBegin(TType.STRUCT, len(viter280))
        for iter281 in viter280:
          iter281.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype283, _vtype284, _size282 ) = iprot.readMapBegin()
          for _i286 in range(_size282):
            _key287 = iprot.readI64()
            _val288 = []
            (_etype292, _size289) = iprot.readSetBegin()
            for _i293 in range(_size289):
              _elem294 = TObject()
              _elem294.read(iprot)
              _val288.append(_elem294)
            iprot.readSetEnd()
            self.success[_key287] = _val288
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter295,viter296 in list(self.success.items()):
        oprot.writeI64(kiter295)
        oprot.writeSetBegin(TType.STRUCT, len(viter296))
        for iter297 in viter296:
          iter297.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartEnd_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.I64, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartEnd_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 4)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype299, _vtype300, _size298 ) = iprot.readMapBegin()
          for _i302 in range(_size298):
            _key303 = iprot.readI64()
            _val304 = []
            (_etype308, _size305) = iprot.readSetBegin()
            for _i309 in range(_size305):
              _elem310 = TObject()
              _elem310.read(iprot)
              _val304.append(_elem310)
            iprot.readSetEnd()
            self.success[_key303] = _val304
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter311,viter312 in list(self.success.items()):
        oprot.writeI64(kiter311)
        oprot.writeSetBegin(TType.STRUCT, len(viter312))
        for iter313 in viter312:
          iter313.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartstrEndstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRING, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartstrEndstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 4)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype315, _vtype316, _size314 ) = iprot.readMapBegin()
          for _i318 in range(_size314):
            _key319 = iprot.readI64()
            _val320 = []
            (_etype324, _size321) = iprot.readSetBegin()
            for _i325 in range(_size321):
              _elem326 = TObject()
              _elem326.read(iprot)
              _val320.append(_elem326)
            iprot.readSetEnd()
            self.success[_key319] = _val320
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter327,viter328 in list(self.success.items()):
        oprot.writeI64(kiter327)
        oprot.writeSetBegin(TType.STRUCT, len(viter328))
        for iter329 in viter328:
          iter329.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearRecord_args:
  """
  Attributes:
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, record=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearRecord_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearRecord_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearRecords_args:
  """
  Attributes:
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, records=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype333, _size330) = iprot.readListBegin()
          for _i334 in range(_size330):
            _elem335 = iprot.readI64()
            self.records.append(_elem335)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearRecords_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter336 in self.records:
        oprot.writeI64(iter336)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearRecords_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearRecords_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeyRecord_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeyRecord_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeysRecord_args:
  """
  Attributes:
   - keys
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, record=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype340, _size337) = iprot.readListBegin()
          for _i341 in range(_size337):
            _elem342 = iprot.readString()
            self.keys.append(_elem342)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeysRecord_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter343 in self.keys:
        oprot.writeString(iter343)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeysRecord_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeysRecord_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeyRecords_args:
  """
  Attributes:
   - key
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype347, _size344) = iprot.readListBegin()
          for _i348 in range(_size344):
            _elem349 = iprot.readI64()
            self.records.append(_elem349)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeyRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter350 in self.records:
        oprot.writeI64(iter350)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeyRecords_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeyRecords_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeysRecords_args:
  """
  Attributes:
   - keys
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, records=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype354, _size351) = iprot.readListBegin()
          for _i355 in range(_size351):
            _elem356 = iprot.readString()
            self.keys.append(_elem356)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype360, _size357) = iprot.readListBegin()
          for _i361 in range(_size357):
            _elem362 = iprot.readI64()
            self.records.append(_elem362)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeysRecords_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter363 in self.keys:
        oprot.writeString(iter363)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter364 in self.records:
        oprot.writeI64(iter364)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeysRecords_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeysRecords_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commit_args:
  """
  Attributes:
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, creds=None, transaction=None, environment=None,):
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commit_args')
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 1)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 2)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commit_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describe_args:
  """
  Attributes:
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, creds=None, transaction=None, environment=None,):
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describe_args')
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 1)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 2)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describe_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype368, _size365) = iprot.readSetBegin()
          for _i369 in range(_size365):
            _elem370 = iprot.readString()
            self.success.append(_elem370)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describe_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter371 in self.success:
        oprot.writeString(iter371)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeTime_args:
  """
  Attributes:
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'timestamp', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, timestamp=None, creds=None, transaction=None, environment=None,):
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeTime_args')
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 1)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype375, _size372) = iprot.readSetBegin()
          for _i376 in range(_size372):
            _elem377 = iprot.readString()
            self.success.append(_elem377)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter378 in self.success:
        oprot.writeString(iter378)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeTimestr_args:
  """
  Attributes:
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'timestamp', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, timestamp=None, creds=None, transaction=None, environment=None,):
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeTimestr_args')
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 1)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype382, _size379) = iprot.readSetBegin()
          for _i383 in range(_size379):
            _elem384 = iprot.readString()
            self.success.append(_elem384)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter385 in self.success:
        oprot.writeString(iter385)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecord_args:
  """
  Attributes:
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, record=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype389, _size386) = iprot.readSetBegin()
          for _i390 in range(_size386):
            _elem391 = iprot.readString()
            self.success.append(_elem391)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter392 in self.success:
        oprot.writeString(iter392)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordTime_args:
  """
  Attributes:
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordTime_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype396, _size393) = iprot.readSetBegin()
          for _i397 in range(_size393):
            _elem398 = iprot.readString()
            self.success.append(_elem398)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter399 in self.success:
        oprot.writeString(iter399)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordTimestr_args:
  """
  Attributes:
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordTimestr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype403, _size400) = iprot.readSetBegin()
          for _i404 in range(_size400):
            _elem405 = iprot.readString()
            self.success.append(_elem405)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter406 in self.success:
        oprot.writeString(iter406)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecords_args:
  """
  Attributes:
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, records=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype410, _size407) = iprot.readListBegin()
          for _i411 in range(_size407):
            _elem412 = iprot.readI64()
            self.records.append(_elem412)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecords_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter413 in self.records:
        oprot.writeI64(iter413)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype415, _vtype416, _size414 ) = iprot.readMapBegin()
          for _i418 in range(_size414):
            _key419 = iprot.readI64()
            _val420 = []
            (_etype424, _size421) = iprot.readSetBegin()
            for _i425 in range(_size421):
              _elem426 = iprot.readString()
              _val420.append(_elem426)
            iprot.readSetEnd()
            self.success[_key419] = _val420
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter427,viter428 in list(self.success.items()):
        oprot.writeI64(kiter427)
        oprot.writeSetBegin(TType.STRING, len(viter428))
        for iter429 in viter428:
          oprot.writeString(iter429)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordsTime_args:
  """
  Attributes:
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype433, _size430) = iprot.readListBegin()
          for _i434 in range(_size430):
            _elem435 = iprot.readI64()
            self.records.append(_elem435)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordsTime_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter436 in self.records:
        oprot.writeI64(iter436)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype438, _vtype439, _size437 ) = iprot.readMapBegin()
          for _i441 in range(_size437):
            _key442 = iprot.readI64()
            _val443 = []
            (_etype447, _size444) = iprot.readSetBegin()
            for _i448 in range(_size444):
              _elem449 = iprot.readString()
              _val443.append(_elem449)
            iprot.readSetEnd()
            self.success[_key442] = _val443
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter450,viter451 in list(self.success.items()):
        oprot.writeI64(kiter450)
        oprot.writeSetBegin(TType.STRING, len(viter451))
        for iter452 in viter451:
          oprot.writeString(iter452)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordsTimestr_args:
  """
  Attributes:
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype456, _size453) = iprot.readListBegin()
          for _i457 in range(_size453):
            _elem458 = iprot.readI64()
            self.records.append(_elem458)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordsTimestr_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter459 in self.records:
        oprot.writeI64(iter459)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype461, _vtype462, _size460 ) = iprot.readMapBegin()
          for _i464 in range(_size460):
            _key465 = iprot.readI64()
            _val466 = []
            (_etype470, _size467) = iprot.readSetBegin()
            for _i471 in range(_size467):
              _elem472 = iprot.readString()
              _val466.append(_elem472)
            iprot.readSetEnd()
            self.success[_key465] = _val466
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter473,viter474 in list(self.success.items()):
        oprot.writeI64(kiter473)
        oprot.writeSetBegin(TType.STRING, len(viter474))
        for iter475 in viter474:
          oprot.writeString(iter475)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStart_args:
  """
  Attributes:
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStart_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype477, _vtype478, _size476 ) = iprot.readMapBegin()
          for _i480 in range(_size476):
            _key481 = iprot.readString()
            _val482 = {}
            (_ktype484, _vtype485, _size483 ) = iprot.readMapBegin()
            for _i487 in range(_size483):
              _key488 = iprot.readI32()
              _val489 = []
              (_etype493, _size490) = iprot.readSetBegin()
              for _i494 in range(_size490):
                _elem495 = TObject()
                _elem495.read(iprot)
                _val489.append(_elem495)
              iprot.readSetEnd()
              _val482[_key488] = _val489
            iprot.readMapEnd()
            self.success[_key481] = _val482
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter496,viter497 in list(self.success.items()):
        oprot.writeString(kiter496)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter497))
        for kiter498,viter499 in list(viter497.items()):
          oprot.writeI32(kiter498)
          oprot.writeSetBegin(TType.STRUCT, len(viter499))
          for iter500 in viter499:
            iter500.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartstr_args:
  """
  Attributes:
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartstr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype502, _vtype503, _size501 ) = iprot.readMapBegin()
          for _i505 in range(_size501):
            _key506 = iprot.readString()
            _val507 = {}
            (_ktype509, _vtype510, _size508 ) = iprot.readMapBegin()
            for _i512 in range(_size508):
              _key513 = iprot.readI32()
              _val514 = []
              (_etype518, _size515) = iprot.readSetBegin()
              for _i519 in range(_size515):
                _elem520 = TObject()
                _elem520.read(iprot)
                _val514.append(_elem520)
              iprot.readSetEnd()
              _val507[_key513] = _val514
            iprot.readMapEnd()
            self.success[_key506] = _val507
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter521,viter522 in list(self.success.items()):
        oprot.writeString(kiter521)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter522))
        for kiter523,viter524 in list(viter522.items()):
          oprot.writeI32(kiter523)
          oprot.writeSetBegin(TType.STRUCT, len(viter524))
          for iter525 in viter524:
            iter525.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartEnd_args:
  """
  Attributes:
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.I64, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartEnd_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 3)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype527, _vtype528, _size526 ) = iprot.readMapBegin()
          for _i530 in range(_size526):
            _key531 = iprot.readString()
            _val532 = {}
            (_ktype534, _vtype535, _size533 ) = iprot.readMapBegin()
            for _i537 in range(_size533):
              _key538 = iprot.readI32()
              _val539 = []
              (_etype543, _size540) = iprot.readSetBegin()
              for _i544 in range(_size540):
                _elem545 = TObject()
                _elem545.read(iprot)
                _val539.append(_elem545)
              iprot.readSetEnd()
              _val532[_key538] = _val539
            iprot.readMapEnd()
            self.success[_key531] = _val532
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter546,viter547 in list(self.success.items()):
        oprot.writeString(kiter546)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter547))
        for kiter548,viter549 in list(viter547.items()):
          oprot.writeI32(kiter548)
          oprot.writeSetBegin(TType.STRUCT, len(viter549))
          for iter550 in viter549:
            iter550.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartstrEndstr_args:
  """
  Attributes:
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRING, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartstrEndstr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 3)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype552, _vtype553, _size551 ) = iprot.readMapBegin()
          for _i555 in range(_size551):
            _key556 = iprot.readString()
            _val557 = {}
            (_ktype559, _vtype560, _size558 ) = iprot.readMapBegin()
            for _i562 in range(_size558):
              _key563 = iprot.readI32()
              _val564 = []
              (_etype568, _size565) = iprot.readSetBegin()
              for _i569 in range(_size565):
                _elem570 = TObject()
                _elem570.read(iprot)
                _val564.append(_elem570)
              iprot.readSetEnd()
              _val557[_key563] = _val564
            iprot.readMapEnd()
            self.success[_key556] = _val557
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter571,viter572 in list(self.success.items()):
        oprot.writeString(kiter571)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter572))
        for kiter573,viter574 in list(viter572.items()):
          oprot.writeI32(kiter573)
          oprot.writeSetBegin(TType.STRUCT, len(viter574))
          for iter575 in viter574:
            iter575.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStart_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStart_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype577, _vtype578, _size576 ) = iprot.readMapBegin()
          for _i580 in range(_size576):
            _key581 = iprot.readI32()
            _val582 = []
            (_etype586, _size583) = iprot.readSetBegin()
            for _i587 in range(_size583):
              _elem588 = TObject()
              _elem588.read(iprot)
              _val582.append(_elem588)
            iprot.readSetEnd()
            self.success[_key581] = _val582
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.SET, len(self.success))
      for kiter589,viter590 in list(self.success.items()):
        oprot.writeI32(kiter589)
        oprot.writeSetBegin(TType.STRUCT, len(viter590))
        for iter591 in viter590:
          iter591.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype593, _vtype594, _size592 ) = iprot.readMapBegin()
          for _i596 in range(_size592):
            _key597 = iprot.readI32()
            _val598 = []
            (_etype602, _size599) = iprot.readSetBegin()
            for _i603 in range(_size599):
              _elem604 = TObject()
              _elem604.read(iprot)
              _val598.append(_elem604)
            iprot.readSetEnd()
            self.success[_key597] = _val598
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.SET, len(self.success))
      for kiter605,viter606 in list(self.success.items()):
        oprot.writeI32(kiter605)
        oprot.writeSetBegin(TType.STRUCT, len(viter606))
        for iter607 in viter606:
          iter607.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartEnd_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.I64, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartEnd_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 4)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype609, _vtype610, _size608 ) = iprot.readMapBegin()
          for _i612 in range(_size608):
            _key613 = iprot.readI32()
            _val614 = []
            (_etype618, _size615) = iprot.readSetBegin()
            for _i619 in range(_size615):
              _elem620 = TObject()
              _elem620.read(iprot)
              _val614.append(_elem620)
            iprot.readSetEnd()
            self.success[_key613] = _val614
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.SET, len(self.success))
      for kiter621,viter622 in list(self.success.items()):
        oprot.writeI32(kiter621)
        oprot.writeSetBegin(TType.STRUCT, len(viter622))
        for iter623 in viter622:
          iter623.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartstrEndstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRING, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartstrEndstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 4)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype625, _vtype626, _size624 ) = iprot.readMapBegin()
          for _i628 in range(_size624):
            _key629 = iprot.readI32()
            _val630 = []
            (_etype634, _size631) = iprot.readSetBegin()
            for _i635 in range(_size631):
              _elem636 = TObject()
              _elem636.read(iprot)
              _val630.append(_elem636)
            iprot.readSetEnd()
            self.success[_key629] = _val630
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.SET, len(self.success))
      for kiter637,viter638 in list(self.success.items()):
        oprot.writeI32(kiter637)
        oprot.writeSetBegin(TType.STRUCT, len(viter638))
        for iter639 in viter638:
          iter639.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStart_args:
  """
  Attributes:
   - key
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStart_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.MAP,(TType.I32,None,TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype641, _vtype642, _size640 ) = iprot.readMapBegin()
          for _i644 in range(_size640):
            _key645 = TObject()
            _key645.read(iprot)
            _val646 = {}
            (_ktype648, _vtype649, _size647 ) = iprot.readMapBegin()
            for _i651 in range(_size647):
              _key652 = iprot.readI32()
              _val653 = []
              (_etype657, _size654) = iprot.readSetBegin()
              for _i658 in range(_size654):
                _elem659 = iprot.readI64()
                _val653.append(_elem659)
              iprot.readSetEnd()
              _val646[_key652] = _val653
            iprot.readMapEnd()
            self.success[_key645] = _val646
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.success))
      for kiter660,viter661 in list(self.success.items()):
        kiter660.write(oprot)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter661))
        for kiter662,viter663 in list(viter661.items()):
          oprot.writeI32(kiter662)
          oprot.writeSetBegin(TType.I64, len(viter663))
          for iter664 in viter663:
            oprot.writeI64(iter664)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartstr_args:
  """
  Attributes:
   - key
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.MAP,(TType.I32,None,TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype666, _vtype667, _size665 ) = iprot.readMapBegin()
          for _i669 in range(_size665):
            _key670 = TObject()
            _key670.read(iprot)
            _val671 = {}
            (_ktype673, _vtype674, _size672 ) = iprot.readMapBegin()
            for _i676 in range(_size672):
              _key677 = iprot.readI32()
              _val678 = []
              (_etype682, _size679) = iprot.readSetBegin()
              for _i683 in range(_size679):
                _elem684 = iprot.readI64()
                _val678.append(_elem684)
              iprot.readSetEnd()
              _val671[_key677] = _val678
            iprot.readMapEnd()
            self.success[_key670] = _val671
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.success))
      for kiter685,viter686 in list(self.success.items()):
        kiter685.write(oprot)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter686))
        for kiter687,viter688 in list(viter686.items()):
          oprot.writeI32(kiter687)
          oprot.writeSetBegin(TType.I64, len(viter688))
          for iter689 in viter688:
            oprot.writeI64(iter689)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartEnd_args:
  """
  Attributes:
   - key
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.I64, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartEnd_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 3)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.MAP,(TType.I32,None,TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype691, _vtype692, _size690 ) = iprot.readMapBegin()
          for _i694 in range(_size690):
            _key695 = TObject()
            _key695.read(iprot)
            _val696 = {}
            (_ktype698, _vtype699, _size697 ) = iprot.readMapBegin()
            for _i701 in range(_size697):
              _key702 = iprot.readI32()
              _val703 = []
              (_etype707, _size704) = iprot.readSetBegin()
              for _i708 in range(_size704):
                _elem709 = iprot.readI64()
                _val703.append(_elem709)
              iprot.readSetEnd()
              _val696[_key702] = _val703
            iprot.readMapEnd()
            self.success[_key695] = _val696
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.success))
      for kiter710,viter711 in list(self.success.items()):
        kiter710.write(oprot)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter711))
        for kiter712,viter713 in list(viter711.items()):
          oprot.writeI32(kiter712)
          oprot.writeSetBegin(TType.I64, len(viter713))
          for iter714 in viter713:
            oprot.writeI64(iter714)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartstrEndstr_args:
  """
  Attributes:
   - key
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRING, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartstrEndstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 3)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.MAP,(TType.I32,None,TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype716, _vtype717, _size715 ) = iprot.readMapBegin()
          for _i719 in range(_size715):
            _key720 = TObject()
            _key720.read(iprot)
            _val721 = {}
            (_ktype723, _vtype724, _size722 ) = iprot.readMapBegin()
            for _i726 in range(_size722):
              _key727 = iprot.readI32()
              _val728 = []
              (_etype732, _size729) = iprot.readSetBegin()
              for _i733 in range(_size729):
                _elem734 = iprot.readI64()
                _val728.append(_elem734)
              iprot.readSetEnd()
              _val721[_key727] = _val728
            iprot.readMapEnd()
            self.success[_key720] = _val721
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.success))
      for kiter735,viter736 in list(self.success.items()):
        kiter735.write(oprot)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter736))
        for kiter737,viter738 in list(viter736.items()):
          oprot.writeI32(kiter737)
          oprot.writeSetBegin(TType.I64, len(viter738))
          for iter739 in viter738:
            oprot.writeI64(iter739)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class invokePlugin_args:
  """
  Attributes:
   - id
   - method
   - params
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRING, 'method', None, None, ), # 2
    (3, TType.LIST, 'params', (TType.STRUCT,(concourse.thriftapi.complex.ttypes.ComplexTObject, concourse.thriftapi.complex.ttypes.ComplexTObject.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, id=None, method=None, params=None, creds=None, transaction=None, environment=None,):
    self.id = id
    self.method = method
    self.params = params
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.method = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.params = []
          (_etype743, _size740) = iprot.readListBegin()
          for _i744 in range(_size740):
            _elem745 = concourse.thriftapi.complex.ttypes.ComplexTObject()
            _elem745.read(iprot)
            self.params.append(_elem745)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('invokePlugin_args')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.method is not None:
      oprot.writeFieldBegin('method', TType.STRING, 2)
      oprot.writeString(self.method)
      oprot.writeFieldEnd()
    if self.params is not None:
      oprot.writeFieldBegin('params', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.params))
      for iter746 in self.params:
        iter746.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.method)
    value = (value * 31) ^ hash(self.params)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class invokePlugin_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (concourse.thriftapi.complex.ttypes.ComplexTObject, concourse.thriftapi.complex.ttypes.ComplexTObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = concourse.thriftapi.complex.ttypes.ComplexTObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('invokePlugin_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class login_args:
  """
  Attributes:
   - username
   - password
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'username', None, None, ), # 1
    (2, TType.STRING, 'password', None, None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, username=None, password=None, environment=None,):
    self.username = username
    self.password = password
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.username = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.password = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('login_args')
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 1)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 2)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.username)
    value = (value * 31) ^ hash(self.password)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class login_result:
  """
  Attributes:
   - success
   - ex
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessToken, AccessToken.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ex=None,):
    self.success = success
    self.ex = ex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessToken()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('login_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class logout_args:
  """
  Attributes:
   - token
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'environment', None, None, ), # 2
  )

  def __init__(self, token=None, environment=None,):
    self.token = token
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('logout_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 2)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class logout_result:
  """
  Attributes:
   - ex
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, ex=None,):
    self.ex = ex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('logout_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stage_args:
  """
  Attributes:
   - token
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'environment', None, None, ), # 2
  )

  def __init__(self, token=None, environment=None,):
    self.token = token
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stage_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 2)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stage_result:
  """
  Attributes:
   - success
   - ex
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TransactionToken, TransactionToken.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ex=None,):
    self.success = success
    self.ex = ex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TransactionToken()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stage_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJson_args:
  """
  Attributes:
   - json
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'json', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, json=None, creds=None, transaction=None, environment=None,):
    self.json = json
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.json = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJson_args')
    if self.json is not None:
      oprot.writeFieldBegin('json', TType.STRING, 1)
      oprot.writeString(self.json)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.json)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJson_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype750, _size747) = iprot.readSetBegin()
          for _i751 in range(_size747):
            _elem752 = iprot.readI64()
            self.success.append(_elem752)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJson_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter753 in self.success:
        oprot.writeI64(iter753)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJsonRecord_args:
  """
  Attributes:
   - json
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'json', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, json=None, record=None, creds=None, transaction=None, environment=None,):
    self.json = json
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.json = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJsonRecord_args')
    if self.json is not None:
      oprot.writeFieldBegin('json', TType.STRING, 1)
      oprot.writeString(self.json)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.json)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJsonRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJsonRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJsonRecords_args:
  """
  Attributes:
   - json
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'json', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, json=None, records=None, creds=None, transaction=None, environment=None,):
    self.json = json
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.json = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype757, _size754) = iprot.readListBegin()
          for _i758 in range(_size754):
            _elem759 = iprot.readI64()
            self.records.append(_elem759)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJsonRecords_args')
    if self.json is not None:
      oprot.writeFieldBegin('json', TType.STRING, 1)
      oprot.writeString(self.json)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter760 in self.records:
        oprot.writeI64(iter760)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.json)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJsonRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.BOOL,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype762, _vtype763, _size761 ) = iprot.readMapBegin()
          for _i765 in range(_size761):
            _key766 = iprot.readI64()
            _val767 = iprot.readBool()
            self.success[_key766] = _val767
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJsonRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.BOOL, len(self.success))
      for kiter768,viter769 in list(self.success.items()):
        oprot.writeI64(kiter768)
        oprot.writeBool(viter769)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeKeyValueRecord_args:
  """
  Attributes:
   - key
   - value
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeKeyValueRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeKeyValueRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeKeyValueRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeKeyValueRecords_args:
  """
  Attributes:
   - key
   - value
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.LIST, 'records', (TType.I64,None), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.records = []
          (_etype773, _size770) = iprot.readListBegin()
          for _i774 in range(_size770):
            _elem775 = iprot.readI64()
            self.records.append(_elem775)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeKeyValueRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter776 in self.records:
        oprot.writeI64(iter776)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeKeyValueRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.BOOL,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype778, _vtype779, _size777 ) = iprot.readMapBegin()
          for _i781 in range(_size777):
            _key782 = iprot.readI64()
            _val783 = iprot.readBool()
            self.success[_key782] = _val783
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeKeyValueRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.BOOL, len(self.success))
      for kiter784,viter785 in list(self.success.items()):
        oprot.writeI64(kiter784)
        oprot.writeBool(viter785)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValueRecord_args:
  """
  Attributes:
   - key
   - value
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValueRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValueRecord_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValueRecord_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValue_args:
  """
  Attributes:
   - key
   - value
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, value=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValue_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValue_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValue_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValueRecords_args:
  """
  Attributes:
   - key
   - value
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.LIST, 'records', (TType.I64,None), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.records = []
          (_etype789, _size786) = iprot.readListBegin()
          for _i790 in range(_size786):
            _elem791 = iprot.readI64()
            self.records.append(_elem791)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValueRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter792 in self.records:
        oprot.writeI64(iter792)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValueRecords_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValueRecords_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reconcileKeyRecordValues_args:
  """
  Attributes:
   - key
   - record
   - values
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.SET, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, values=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.values = values
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.values = []
          (_etype796, _size793) = iprot.readSetBegin()
          for _i797 in range(_size793):
            _elem798 = TObject()
            _elem798.read(iprot)
            self.values.append(_elem798)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reconcileKeyRecordValues_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.SET, 3)
      oprot.writeSetBegin(TType.STRUCT, len(self.values))
      for iter799 in self.values:
        iter799.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reconcileKeyRecordValues_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reconcileKeyRecordValues_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inventory_args:
  """
  Attributes:
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, creds=None, transaction=None, environment=None,):
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inventory_args')
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 1)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 2)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inventory_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype803, _size800) = iprot.readSetBegin()
          for _i804 in range(_size800):
            _elem805 = iprot.readI64()
            self.success.append(_elem805)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inventory_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter806 in self.success:
        oprot.writeI64(iter806)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecord_args:
  """
  Attributes:
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, record=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype808, _vtype809, _size807 ) = iprot.readMapBegin()
          for _i811 in range(_size807):
            _key812 = iprot.readString()
            _val813 = []
            (_etype817, _size814) = iprot.readSetBegin()
            for _i818 in range(_size814):
              _elem819 = TObject()
              _elem819.read(iprot)
              _val813.append(_elem819)
            iprot.readSetEnd()
            self.success[_key812] = _val813
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter820,viter821 in list(self.success.items()):
        oprot.writeString(kiter820)
        oprot.writeSetBegin(TType.STRUCT, len(viter821))
        for iter822 in viter821:
          iter822.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecords_args:
  """
  Attributes:
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, records=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype826, _size823) = iprot.readListBegin()
          for _i827 in range(_size823):
            _elem828 = iprot.readI64()
            self.records.append(_elem828)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecords_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter829 in self.records:
        oprot.writeI64(iter829)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype831, _vtype832, _size830 ) = iprot.readMapBegin()
          for _i834 in range(_size830):
            _key835 = iprot.readI64()
            _val836 = {}
            (_ktype838, _vtype839, _size837 ) = iprot.readMapBegin()
            for _i841 in range(_size837):
              _key842 = iprot.readString()
              _val843 = []
              (_etype847, _size844) = iprot.readSetBegin()
              for _i848 in range(_size844):
                _elem849 = TObject()
                _elem849.read(iprot)
                _val843.append(_elem849)
              iprot.readSetEnd()
              _val836[_key842] = _val843
            iprot.readMapEnd()
            self.success[_key835] = _val836
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter850,viter851 in list(self.success.items()):
        oprot.writeI64(kiter850)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter851))
        for kiter852,viter853 in list(viter851.items()):
          oprot.writeString(kiter852)
          oprot.writeSetBegin(TType.STRUCT, len(viter853))
          for iter854 in viter853:
            iter854.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordTime_args:
  """
  Attributes:
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordTime_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype856, _vtype857, _size855 ) = iprot.readMapBegin()
          for _i859 in range(_size855):
            _key860 = iprot.readString()
            _val861 = []
            (_etype865, _size862) = iprot.readSetBegin()
            for _i866 in range(_size862):
              _elem867 = TObject()
              _elem867.read(iprot)
              _val861.append(_elem867)
            iprot.readSetEnd()
            self.success[_key860] = _val861
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter868,viter869 in list(self.success.items()):
        oprot.writeString(kiter868)
        oprot.writeSetBegin(TType.STRUCT, len(viter869))
        for iter870 in viter869:
          iter870.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordTimestr_args:
  """
  Attributes:
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordTimestr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype872, _vtype873, _size871 ) = iprot.readMapBegin()
          for _i875 in range(_size871):
            _key876 = iprot.readString()
            _val877 = []
            (_etype881, _size878) = iprot.readSetBegin()
            for _i882 in range(_size878):
              _elem883 = TObject()
              _elem883.read(iprot)
              _val877.append(_elem883)
            iprot.readSetEnd()
            self.success[_key876] = _val877
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter884,viter885 in list(self.success.items()):
        oprot.writeString(kiter884)
        oprot.writeSetBegin(TType.STRUCT, len(viter885))
        for iter886 in viter885:
          iter886.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordsTime_args:
  """
  Attributes:
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype890, _size887) = iprot.readListBegin()
          for _i891 in range(_size887):
            _elem892 = iprot.readI64()
            self.records.append(_elem892)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordsTime_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter893 in self.records:
        oprot.writeI64(iter893)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype895, _vtype896, _size894 ) = iprot.readMapBegin()
          for _i898 in range(_size894):
            _key899 = iprot.readI64()
            _val900 = {}
            (_ktype902, _vtype903, _size901 ) = iprot.readMapBegin()
            for _i905 in range(_size901):
              _key906 = iprot.readString()
              _val907 = []
              (_etype911, _size908) = iprot.readSetBegin()
              for _i912 in range(_size908):
                _elem913 = TObject()
                _elem913.read(iprot)
                _val907.append(_elem913)
              iprot.readSetEnd()
              _val900[_key906] = _val907
            iprot.readMapEnd()
            self.success[_key899] = _val900
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter914,viter915 in list(self.success.items()):
        oprot.writeI64(kiter914)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter915))
        for kiter916,viter917 in list(viter915.items()):
          oprot.writeString(kiter916)
          oprot.writeSetBegin(TType.STRUCT, len(viter917))
          for iter918 in viter917:
            iter918.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordsTimestr_args:
  """
  Attributes:
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype922, _size919) = iprot.readListBegin()
          for _i923 in range(_size919):
            _elem924 = iprot.readI64()
            self.records.append(_elem924)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordsTimestr_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter925 in self.records:
        oprot.writeI64(iter925)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype927, _vtype928, _size926 ) = iprot.readMapBegin()
          for _i930 in range(_size926):
            _key931 = iprot.readI64()
            _val932 = {}
            (_ktype934, _vtype935, _size933 ) = iprot.readMapBegin()
            for _i937 in range(_size933):
              _key938 = iprot.readString()
              _val939 = []
              (_etype943, _size940) = iprot.readSetBegin()
              for _i944 in range(_size940):
                _elem945 = TObject()
                _elem945.read(iprot)
                _val939.append(_elem945)
              iprot.readSetEnd()
              _val932[_key938] = _val939
            iprot.readMapEnd()
            self.success[_key931] = _val932
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter946,viter947 in list(self.success.items()):
        oprot.writeI64(kiter946)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter947))
        for kiter948,viter949 in list(viter947.items()):
          oprot.writeString(kiter948)
          oprot.writeSetBegin(TType.STRUCT, len(viter949))
          for iter950 in viter949:
            iter950.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype954, _size951) = iprot.readSetBegin()
          for _i955 in range(_size951):
            _elem956 = TObject()
            _elem956.read(iprot)
            self.success.append(_elem956)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRUCT, len(self.success))
      for iter957 in self.success:
        iter957.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordTime_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype961, _size958) = iprot.readSetBegin()
          for _i962 in range(_size958):
            _elem963 = TObject()
            _elem963.read(iprot)
            self.success.append(_elem963)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRUCT, len(self.success))
      for iter964 in self.success:
        iter964.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordTimestr_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype968, _size965) = iprot.readSetBegin()
          for _i969 in range(_size965):
            _elem970 = TObject()
            _elem970.read(iprot)
            self.success.append(_elem970)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRUCT, len(self.success))
      for iter971 in self.success:
        iter971.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecord_args:
  """
  Attributes:
   - keys
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, record=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype975, _size972) = iprot.readListBegin()
          for _i976 in range(_size972):
            _elem977 = iprot.readString()
            self.keys.append(_elem977)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecord_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter978 in self.keys:
        oprot.writeString(iter978)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype980, _vtype981, _size979 ) = iprot.readMapBegin()
          for _i983 in range(_size979):
            _key984 = iprot.readString()
            _val985 = []
            (_etype989, _size986) = iprot.readSetBegin()
            for _i990 in range(_size986):
              _elem991 = TObject()
              _elem991.read(iprot)
              _val985.append(_elem991)
            iprot.readSetEnd()
            self.success[_key984] = _val985
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter992,viter993 in list(self.success.items()):
        oprot.writeString(kiter992)
        oprot.writeSetBegin(TType.STRUCT, len(viter993))
        for iter994 in viter993:
          iter994.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordTime_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype998, _size995) = iprot.readListBegin()
          for _i999 in range(_size995):
            _elem1000 = iprot.readString()
            self.keys.append(_elem1000)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1001 in self.keys:
        oprot.writeString(iter1001)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1003, _vtype1004, _size1002 ) = iprot.readMapBegin()
          for _i1006 in range(_size1002):
            _key1007 = iprot.readString()
            _val1008 = []
            (_etype1012, _size1009) = iprot.readSetBegin()
            for _i1013 in range(_size1009):
              _elem1014 = TObject()
              _elem1014.read(iprot)
              _val1008.append(_elem1014)
            iprot.readSetEnd()
            self.success[_key1007] = _val1008
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter1015,viter1016 in list(self.success.items()):
        oprot.writeString(kiter1015)
        oprot.writeSetBegin(TType.STRUCT, len(viter1016))
        for iter1017 in viter1016:
          iter1017.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordTimestr_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1021, _size1018) = iprot.readListBegin()
          for _i1022 in range(_size1018):
            _elem1023 = iprot.readString()
            self.keys.append(_elem1023)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1024 in self.keys:
        oprot.writeString(iter1024)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1026, _vtype1027, _size1025 ) = iprot.readMapBegin()
          for _i1029 in range(_size1025):
            _key1030 = iprot.readString()
            _val1031 = []
            (_etype1035, _size1032) = iprot.readSetBegin()
            for _i1036 in range(_size1032):
              _elem1037 = TObject()
              _elem1037.read(iprot)
              _val1031.append(_elem1037)
            iprot.readSetEnd()
            self.success[_key1030] = _val1031
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter1038,viter1039 in list(self.success.items()):
        oprot.writeString(kiter1038)
        oprot.writeSetBegin(TType.STRUCT, len(viter1039))
        for iter1040 in viter1039:
          iter1040.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecords_args:
  """
  Attributes:
   - keys
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, records=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1044, _size1041) = iprot.readListBegin()
          for _i1045 in range(_size1041):
            _elem1046 = iprot.readString()
            self.keys.append(_elem1046)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1050, _size1047) = iprot.readListBegin()
          for _i1051 in range(_size1047):
            _elem1052 = iprot.readI64()
            self.records.append(_elem1052)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecords_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1053 in self.keys:
        oprot.writeString(iter1053)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1054 in self.records:
        oprot.writeI64(iter1054)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1056, _vtype1057, _size1055 ) = iprot.readMapBegin()
          for _i1059 in range(_size1055):
            _key1060 = iprot.readI64()
            _val1061 = {}
            (_ktype1063, _vtype1064, _size1062 ) = iprot.readMapBegin()
            for _i1066 in range(_size1062):
              _key1067 = iprot.readString()
              _val1068 = []
              (_etype1072, _size1069) = iprot.readSetBegin()
              for _i1073 in range(_size1069):
                _elem1074 = TObject()
                _elem1074.read(iprot)
                _val1068.append(_elem1074)
              iprot.readSetEnd()
              _val1061[_key1067] = _val1068
            iprot.readMapEnd()
            self.success[_key1060] = _val1061
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1075,viter1076 in list(self.success.items()):
        oprot.writeI64(kiter1075)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1076))
        for kiter1077,viter1078 in list(viter1076.items()):
          oprot.writeString(kiter1077)
          oprot.writeSetBegin(TType.STRUCT, len(viter1078))
          for iter1079 in viter1078:
            iter1079.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecords_args:
  """
  Attributes:
   - key
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1083, _size1080) = iprot.readListBegin()
          for _i1084 in range(_size1080):
            _elem1085 = iprot.readI64()
            self.records.append(_elem1085)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1086 in self.records:
        oprot.writeI64(iter1086)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1088, _vtype1089, _size1087 ) = iprot.readMapBegin()
          for _i1091 in range(_size1087):
            _key1092 = iprot.readI64()
            _val1093 = []
            (_etype1097, _size1094) = iprot.readSetBegin()
            for _i1098 in range(_size1094):
              _elem1099 = TObject()
              _elem1099.read(iprot)
              _val1093.append(_elem1099)
            iprot.readSetEnd()
            self.success[_key1092] = _val1093
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1100,viter1101 in list(self.success.items()):
        oprot.writeI64(kiter1100)
        oprot.writeSetBegin(TType.STRUCT, len(viter1101))
        for iter1102 in viter1101:
          iter1102.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordsTime_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1106, _size1103) = iprot.readListBegin()
          for _i1107 in range(_size1103):
            _elem1108 = iprot.readI64()
            self.records.append(_elem1108)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordsTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1109 in self.records:
        oprot.writeI64(iter1109)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1111, _vtype1112, _size1110 ) = iprot.readMapBegin()
          for _i1114 in range(_size1110):
            _key1115 = iprot.readI64()
            _val1116 = []
            (_etype1120, _size1117) = iprot.readSetBegin()
            for _i1121 in range(_size1117):
              _elem1122 = TObject()
              _elem1122.read(iprot)
              _val1116.append(_elem1122)
            iprot.readSetEnd()
            self.success[_key1115] = _val1116
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1123,viter1124 in list(self.success.items()):
        oprot.writeI64(kiter1123)
        oprot.writeSetBegin(TType.STRUCT, len(viter1124))
        for iter1125 in viter1124:
          iter1125.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordsTimestr_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1129, _size1126) = iprot.readListBegin()
          for _i1130 in range(_size1126):
            _elem1131 = iprot.readI64()
            self.records.append(_elem1131)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordsTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1132 in self.records:
        oprot.writeI64(iter1132)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1134, _vtype1135, _size1133 ) = iprot.readMapBegin()
          for _i1137 in range(_size1133):
            _key1138 = iprot.readI64()
            _val1139 = []
            (_etype1143, _size1140) = iprot.readSetBegin()
            for _i1144 in range(_size1140):
              _elem1145 = TObject()
              _elem1145.read(iprot)
              _val1139.append(_elem1145)
            iprot.readSetEnd()
            self.success[_key1138] = _val1139
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1146,viter1147 in list(self.success.items()):
        oprot.writeI64(kiter1146)
        oprot.writeSetBegin(TType.STRUCT, len(viter1147))
        for iter1148 in viter1147:
          iter1148.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordsTime_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1152, _size1149) = iprot.readListBegin()
          for _i1153 in range(_size1149):
            _elem1154 = iprot.readString()
            self.keys.append(_elem1154)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1158, _size1155) = iprot.readListBegin()
          for _i1159 in range(_size1155):
            _elem1160 = iprot.readI64()
            self.records.append(_elem1160)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordsTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1161 in self.keys:
        oprot.writeString(iter1161)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1162 in self.records:
        oprot.writeI64(iter1162)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1164, _vtype1165, _size1163 ) = iprot.readMapBegin()
          for _i1167 in range(_size1163):
            _key1168 = iprot.readI64()
            _val1169 = {}
            (_ktype1171, _vtype1172, _size1170 ) = iprot.readMapBegin()
            for _i1174 in range(_size1170):
              _key1175 = iprot.readString()
              _val1176 = []
              (_etype1180, _size1177) = iprot.readSetBegin()
              for _i1181 in range(_size1177):
                _elem1182 = TObject()
                _elem1182.read(iprot)
                _val1176.append(_elem1182)
              iprot.readSetEnd()
              _val1169[_key1175] = _val1176
            iprot.readMapEnd()
            self.success[_key1168] = _val1169
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1183,viter1184 in list(self.success.items()):
        oprot.writeI64(kiter1183)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1184))
        for kiter1185,viter1186 in list(viter1184.items()):
          oprot.writeString(kiter1185)
          oprot.writeSetBegin(TType.STRUCT, len(viter1186))
          for iter1187 in viter1186:
            iter1187.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordsTimestr_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1191, _size1188) = iprot.readListBegin()
          for _i1192 in range(_size1188):
            _elem1193 = iprot.readString()
            self.keys.append(_elem1193)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1197, _size1194) = iprot.readListBegin()
          for _i1198 in range(_size1194):
            _elem1199 = iprot.readI64()
            self.records.append(_elem1199)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordsTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1200 in self.keys:
        oprot.writeString(iter1200)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1201 in self.records:
        oprot.writeI64(iter1201)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1203, _vtype1204, _size1202 ) = iprot.readMapBegin()
          for _i1206 in range(_size1202):
            _key1207 = iprot.readI64()
            _val1208 = {}
            (_ktype1210, _vtype1211, _size1209 ) = iprot.readMapBegin()
            for _i1213 in range(_size1209):
              _key1214 = iprot.readString()
              _val1215 = []
              (_etype1219, _size1216) = iprot.readSetBegin()
              for _i1220 in range(_size1216):
                _elem1221 = TObject()
                _elem1221.read(iprot)
                _val1215.append(_elem1221)
              iprot.readSetEnd()
              _val1208[_key1214] = _val1215
            iprot.readMapEnd()
            self.success[_key1207] = _val1208
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1222,viter1223 in list(self.success.items()):
        oprot.writeI64(kiter1222)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1223))
        for kiter1224,viter1225 in list(viter1223.items()):
          oprot.writeString(kiter1224)
          oprot.writeSetBegin(TType.STRUCT, len(viter1225))
          for iter1226 in viter1225:
            iter1226.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteria_args:
  """
  Attributes:
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, criteria=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteria_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1228, _vtype1229, _size1227 ) = iprot.readMapBegin()
          for _i1231 in range(_size1227):
            _key1232 = iprot.readI64()
            _val1233 = {}
            (_ktype1235, _vtype1236, _size1234 ) = iprot.readMapBegin()
            for _i1238 in range(_size1234):
              _key1239 = iprot.readString()
              _val1240 = []
              (_etype1244, _size1241) = iprot.readSetBegin()
              for _i1245 in range(_size1241):
                _elem1246 = TObject()
                _elem1246.read(iprot)
                _val1240.append(_elem1246)
              iprot.readSetEnd()
              _val1233[_key1239] = _val1240
            iprot.readMapEnd()
            self.success[_key1232] = _val1233
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1247,viter1248 in list(self.success.items()):
        oprot.writeI64(kiter1247)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1248))
        for kiter1249,viter1250 in list(viter1248.items()):
          oprot.writeString(kiter1249)
          oprot.writeSetBegin(TType.STRUCT, len(viter1250))
          for iter1251 in viter1250:
            iter1251.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCcl_args:
  """
  Attributes:
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, ccl=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCcl_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1253, _vtype1254, _size1252 ) = iprot.readMapBegin()
          for _i1256 in range(_size1252):
            _key1257 = iprot.readI64()
            _val1258 = {}
            (_ktype1260, _vtype1261, _size1259 ) = iprot.readMapBegin()
            for _i1263 in range(_size1259):
              _key1264 = iprot.readString()
              _val1265 = []
              (_etype1269, _size1266) = iprot.readSetBegin()
              for _i1270 in range(_size1266):
                _elem1271 = TObject()
                _elem1271.read(iprot)
                _val1265.append(_elem1271)
              iprot.readSetEnd()
              _val1258[_key1264] = _val1265
            iprot.readMapEnd()
            self.success[_key1257] = _val1258
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1272,viter1273 in list(self.success.items()):
        oprot.writeI64(kiter1272)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1273))
        for kiter1274,viter1275 in list(viter1273.items()):
          oprot.writeString(kiter1274)
          oprot.writeSetBegin(TType.STRUCT, len(viter1275))
          for iter1276 in viter1275:
            iter1276.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteriaTime_args:
  """
  Attributes:
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteriaTime_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1278, _vtype1279, _size1277 ) = iprot.readMapBegin()
          for _i1281 in range(_size1277):
            _key1282 = iprot.readI64()
            _val1283 = {}
            (_ktype1285, _vtype1286, _size1284 ) = iprot.readMapBegin()
            for _i1288 in range(_size1284):
              _key1289 = iprot.readString()
              _val1290 = []
              (_etype1294, _size1291) = iprot.readSetBegin()
              for _i1295 in range(_size1291):
                _elem1296 = TObject()
                _elem1296.read(iprot)
                _val1290.append(_elem1296)
              iprot.readSetEnd()
              _val1283[_key1289] = _val1290
            iprot.readMapEnd()
            self.success[_key1282] = _val1283
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1297,viter1298 in list(self.success.items()):
        oprot.writeI64(kiter1297)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1298))
        for kiter1299,viter1300 in list(viter1298.items()):
          oprot.writeString(kiter1299)
          oprot.writeSetBegin(TType.STRUCT, len(viter1300))
          for iter1301 in viter1300:
            iter1301.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteriaTimestr_args:
  """
  Attributes:
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteriaTimestr_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1303, _vtype1304, _size1302 ) = iprot.readMapBegin()
          for _i1306 in range(_size1302):
            _key1307 = iprot.readI64()
            _val1308 = {}
            (_ktype1310, _vtype1311, _size1309 ) = iprot.readMapBegin()
            for _i1313 in range(_size1309):
              _key1314 = iprot.readString()
              _val1315 = []
              (_etype1319, _size1316) = iprot.readSetBegin()
              for _i1320 in range(_size1316):
                _elem1321 = TObject()
                _elem1321.read(iprot)
                _val1315.append(_elem1321)
              iprot.readSetEnd()
              _val1308[_key1314] = _val1315
            iprot.readMapEnd()
            self.success[_key1307] = _val1308
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1322,viter1323 in list(self.success.items()):
        oprot.writeI64(kiter1322)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1323))
        for kiter1324,viter1325 in list(viter1323.items()):
          oprot.writeString(kiter1324)
          oprot.writeSetBegin(TType.STRUCT, len(viter1325))
          for iter1326 in viter1325:
            iter1326.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCclTime_args:
  """
  Attributes:
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCclTime_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1328, _vtype1329, _size1327 ) = iprot.readMapBegin()
          for _i1331 in range(_size1327):
            _key1332 = iprot.readI64()
            _val1333 = {}
            (_ktype1335, _vtype1336, _size1334 ) = iprot.readMapBegin()
            for _i1338 in range(_size1334):
              _key1339 = iprot.readString()
              _val1340 = []
              (_etype1344, _size1341) = iprot.readSetBegin()
              for _i1345 in range(_size1341):
                _elem1346 = TObject()
                _elem1346.read(iprot)
                _val1340.append(_elem1346)
              iprot.readSetEnd()
              _val1333[_key1339] = _val1340
            iprot.readMapEnd()
            self.success[_key1332] = _val1333
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1347,viter1348 in list(self.success.items()):
        oprot.writeI64(kiter1347)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1348))
        for kiter1349,viter1350 in list(viter1348.items()):
          oprot.writeString(kiter1349)
          oprot.writeSetBegin(TType.STRUCT, len(viter1350))
          for iter1351 in viter1350:
            iter1351.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCclTimestr_args:
  """
  Attributes:
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCclTimestr_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1353, _vtype1354, _size1352 ) = iprot.readMapBegin()
          for _i1356 in range(_size1352):
            _key1357 = iprot.readI64()
            _val1358 = {}
            (_ktype1360, _vtype1361, _size1359 ) = iprot.readMapBegin()
            for _i1363 in range(_size1359):
              _key1364 = iprot.readString()
              _val1365 = []
              (_etype1369, _size1366) = iprot.readSetBegin()
              for _i1370 in range(_size1366):
                _elem1371 = TObject()
                _elem1371.read(iprot)
                _val1365.append(_elem1371)
              iprot.readSetEnd()
              _val1358[_key1364] = _val1365
            iprot.readMapEnd()
            self.success[_key1357] = _val1358
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1372,viter1373 in list(self.success.items()):
        oprot.writeI64(kiter1372)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1373))
        for kiter1374,viter1375 in list(viter1373.items()):
          oprot.writeString(kiter1374)
          oprot.writeSetBegin(TType.STRUCT, len(viter1375))
          for iter1376 in viter1375:
            iter1376.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteria_args:
  """
  Attributes:
   - key
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteria_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1378, _vtype1379, _size1377 ) = iprot.readMapBegin()
          for _i1381 in range(_size1377):
            _key1382 = iprot.readI64()
            _val1383 = []
            (_etype1387, _size1384) = iprot.readSetBegin()
            for _i1388 in range(_size1384):
              _elem1389 = TObject()
              _elem1389.read(iprot)
              _val1383.append(_elem1389)
            iprot.readSetEnd()
            self.success[_key1382] = _val1383
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1390,viter1391 in list(self.success.items()):
        oprot.writeI64(kiter1390)
        oprot.writeSetBegin(TType.STRUCT, len(viter1391))
        for iter1392 in viter1391:
          iter1392.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCcl_args:
  """
  Attributes:
   - key
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCcl_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1394, _vtype1395, _size1393 ) = iprot.readMapBegin()
          for _i1397 in range(_size1393):
            _key1398 = iprot.readI64()
            _val1399 = []
            (_etype1403, _size1400) = iprot.readSetBegin()
            for _i1404 in range(_size1400):
              _elem1405 = TObject()
              _elem1405.read(iprot)
              _val1399.append(_elem1405)
            iprot.readSetEnd()
            self.success[_key1398] = _val1399
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1406,viter1407 in list(self.success.items()):
        oprot.writeI64(kiter1406)
        oprot.writeSetBegin(TType.STRUCT, len(viter1407))
        for iter1408 in viter1407:
          iter1408.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteriaTime_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteriaTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1410, _vtype1411, _size1409 ) = iprot.readMapBegin()
          for _i1413 in range(_size1409):
            _key1414 = iprot.readI64()
            _val1415 = []
            (_etype1419, _size1416) = iprot.readSetBegin()
            for _i1420 in range(_size1416):
              _elem1421 = TObject()
              _elem1421.read(iprot)
              _val1415.append(_elem1421)
            iprot.readSetEnd()
            self.success[_key1414] = _val1415
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1422,viter1423 in list(self.success.items()):
        oprot.writeI64(kiter1422)
        oprot.writeSetBegin(TType.STRUCT, len(viter1423))
        for iter1424 in viter1423:
          iter1424.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteriaTimestr_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteriaTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1426, _vtype1427, _size1425 ) = iprot.readMapBegin()
          for _i1429 in range(_size1425):
            _key1430 = iprot.readI64()
            _val1431 = []
            (_etype1435, _size1432) = iprot.readSetBegin()
            for _i1436 in range(_size1432):
              _elem1437 = TObject()
              _elem1437.read(iprot)
              _val1431.append(_elem1437)
            iprot.readSetEnd()
            self.success[_key1430] = _val1431
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1438,viter1439 in list(self.success.items()):
        oprot.writeI64(kiter1438)
        oprot.writeSetBegin(TType.STRUCT, len(viter1439))
        for iter1440 in viter1439:
          iter1440.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCclTime_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCclTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1442, _vtype1443, _size1441 ) = iprot.readMapBegin()
          for _i1445 in range(_size1441):
            _key1446 = iprot.readI64()
            _val1447 = []
            (_etype1451, _size1448) = iprot.readSetBegin()
            for _i1452 in range(_size1448):
              _elem1453 = TObject()
              _elem1453.read(iprot)
              _val1447.append(_elem1453)
            iprot.readSetEnd()
            self.success[_key1446] = _val1447
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1454,viter1455 in list(self.success.items()):
        oprot.writeI64(kiter1454)
        oprot.writeSetBegin(TType.STRUCT, len(viter1455))
        for iter1456 in viter1455:
          iter1456.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCclTimestr_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCclTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1458, _vtype1459, _size1457 ) = iprot.readMapBegin()
          for _i1461 in range(_size1457):
            _key1462 = iprot.readI64()
            _val1463 = []
            (_etype1467, _size1464) = iprot.readSetBegin()
            for _i1468 in range(_size1464):
              _elem1469 = TObject()
              _elem1469.read(iprot)
              _val1463.append(_elem1469)
            iprot.readSetEnd()
            self.success[_key1462] = _val1463
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1470,viter1471 in list(self.success.items()):
        oprot.writeI64(kiter1470)
        oprot.writeSetBegin(TType.STRUCT, len(viter1471))
        for iter1472 in viter1471:
          iter1472.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteria_args:
  """
  Attributes:
   - keys
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1476, _size1473) = iprot.readListBegin()
          for _i1477 in range(_size1473):
            _elem1478 = iprot.readString()
            self.keys.append(_elem1478)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteria_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1479 in self.keys:
        oprot.writeString(iter1479)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1481, _vtype1482, _size1480 ) = iprot.readMapBegin()
          for _i1484 in range(_size1480):
            _key1485 = iprot.readI64()
            _val1486 = {}
            (_ktype1488, _vtype1489, _size1487 ) = iprot.readMapBegin()
            for _i1491 in range(_size1487):
              _key1492 = iprot.readString()
              _val1493 = []
              (_etype1497, _size1494) = iprot.readSetBegin()
              for _i1498 in range(_size1494):
                _elem1499 = TObject()
                _elem1499.read(iprot)
                _val1493.append(_elem1499)
              iprot.readSetEnd()
              _val1486[_key1492] = _val1493
            iprot.readMapEnd()
            self.success[_key1485] = _val1486
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1500,viter1501 in list(self.success.items()):
        oprot.writeI64(kiter1500)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1501))
        for kiter1502,viter1503 in list(viter1501.items()):
          oprot.writeString(kiter1502)
          oprot.writeSetBegin(TType.STRUCT, len(viter1503))
          for iter1504 in viter1503:
            iter1504.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCcl_args:
  """
  Attributes:
   - keys
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1508, _size1505) = iprot.readListBegin()
          for _i1509 in range(_size1505):
            _elem1510 = iprot.readString()
            self.keys.append(_elem1510)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCcl_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1511 in self.keys:
        oprot.writeString(iter1511)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1513, _vtype1514, _size1512 ) = iprot.readMapBegin()
          for _i1516 in range(_size1512):
            _key1517 = iprot.readI64()
            _val1518 = {}
            (_ktype1520, _vtype1521, _size1519 ) = iprot.readMapBegin()
            for _i1523 in range(_size1519):
              _key1524 = iprot.readString()
              _val1525 = []
              (_etype1529, _size1526) = iprot.readSetBegin()
              for _i1530 in range(_size1526):
                _elem1531 = TObject()
                _elem1531.read(iprot)
                _val1525.append(_elem1531)
              iprot.readSetEnd()
              _val1518[_key1524] = _val1525
            iprot.readMapEnd()
            self.success[_key1517] = _val1518
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1532,viter1533 in list(self.success.items()):
        oprot.writeI64(kiter1532)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1533))
        for kiter1534,viter1535 in list(viter1533.items()):
          oprot.writeString(kiter1534)
          oprot.writeSetBegin(TType.STRUCT, len(viter1535))
          for iter1536 in viter1535:
            iter1536.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteriaTime_args:
  """
  Attributes:
   - keys
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1540, _size1537) = iprot.readListBegin()
          for _i1541 in range(_size1537):
            _elem1542 = iprot.readString()
            self.keys.append(_elem1542)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteriaTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1543 in self.keys:
        oprot.writeString(iter1543)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1545, _vtype1546, _size1544 ) = iprot.readMapBegin()
          for _i1548 in range(_size1544):
            _key1549 = iprot.readI64()
            _val1550 = {}
            (_ktype1552, _vtype1553, _size1551 ) = iprot.readMapBegin()
            for _i1555 in range(_size1551):
              _key1556 = iprot.readString()
              _val1557 = []
              (_etype1561, _size1558) = iprot.readSetBegin()
              for _i1562 in range(_size1558):
                _elem1563 = TObject()
                _elem1563.read(iprot)
                _val1557.append(_elem1563)
              iprot.readSetEnd()
              _val1550[_key1556] = _val1557
            iprot.readMapEnd()
            self.success[_key1549] = _val1550
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1564,viter1565 in list(self.success.items()):
        oprot.writeI64(kiter1564)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1565))
        for kiter1566,viter1567 in list(viter1565.items()):
          oprot.writeString(kiter1566)
          oprot.writeSetBegin(TType.STRUCT, len(viter1567))
          for iter1568 in viter1567:
            iter1568.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteriaTimestr_args:
  """
  Attributes:
   - keys
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1572, _size1569) = iprot.readListBegin()
          for _i1573 in range(_size1569):
            _elem1574 = iprot.readString()
            self.keys.append(_elem1574)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteriaTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1575 in self.keys:
        oprot.writeString(iter1575)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1577, _vtype1578, _size1576 ) = iprot.readMapBegin()
          for _i1580 in range(_size1576):
            _key1581 = iprot.readI64()
            _val1582 = {}
            (_ktype1584, _vtype1585, _size1583 ) = iprot.readMapBegin()
            for _i1587 in range(_size1583):
              _key1588 = iprot.readString()
              _val1589 = []
              (_etype1593, _size1590) = iprot.readSetBegin()
              for _i1594 in range(_size1590):
                _elem1595 = TObject()
                _elem1595.read(iprot)
                _val1589.append(_elem1595)
              iprot.readSetEnd()
              _val1582[_key1588] = _val1589
            iprot.readMapEnd()
            self.success[_key1581] = _val1582
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1596,viter1597 in list(self.success.items()):
        oprot.writeI64(kiter1596)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1597))
        for kiter1598,viter1599 in list(viter1597.items()):
          oprot.writeString(kiter1598)
          oprot.writeSetBegin(TType.STRUCT, len(viter1599))
          for iter1600 in viter1599:
            iter1600.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCclTime_args:
  """
  Attributes:
   - keys
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1604, _size1601) = iprot.readListBegin()
          for _i1605 in range(_size1601):
            _elem1606 = iprot.readString()
            self.keys.append(_elem1606)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCclTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1607 in self.keys:
        oprot.writeString(iter1607)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1609, _vtype1610, _size1608 ) = iprot.readMapBegin()
          for _i1612 in range(_size1608):
            _key1613 = iprot.readI64()
            _val1614 = {}
            (_ktype1616, _vtype1617, _size1615 ) = iprot.readMapBegin()
            for _i1619 in range(_size1615):
              _key1620 = iprot.readString()
              _val1621 = []
              (_etype1625, _size1622) = iprot.readSetBegin()
              for _i1626 in range(_size1622):
                _elem1627 = TObject()
                _elem1627.read(iprot)
                _val1621.append(_elem1627)
              iprot.readSetEnd()
              _val1614[_key1620] = _val1621
            iprot.readMapEnd()
            self.success[_key1613] = _val1614
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1628,viter1629 in list(self.success.items()):
        oprot.writeI64(kiter1628)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1629))
        for kiter1630,viter1631 in list(viter1629.items()):
          oprot.writeString(kiter1630)
          oprot.writeSetBegin(TType.STRUCT, len(viter1631))
          for iter1632 in viter1631:
            iter1632.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCclTimestr_args:
  """
  Attributes:
   - keys
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1636, _size1633) = iprot.readListBegin()
          for _i1637 in range(_size1633):
            _elem1638 = iprot.readString()
            self.keys.append(_elem1638)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCclTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1639 in self.keys:
        oprot.writeString(iter1639)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1641, _vtype1642, _size1640 ) = iprot.readMapBegin()
          for _i1644 in range(_size1640):
            _key1645 = iprot.readI64()
            _val1646 = {}
            (_ktype1648, _vtype1649, _size1647 ) = iprot.readMapBegin()
            for _i1651 in range(_size1647):
              _key1652 = iprot.readString()
              _val1653 = []
              (_etype1657, _size1654) = iprot.readSetBegin()
              for _i1658 in range(_size1654):
                _elem1659 = TObject()
                _elem1659.read(iprot)
                _val1653.append(_elem1659)
              iprot.readSetEnd()
              _val1646[_key1652] = _val1653
            iprot.readMapEnd()
            self.success[_key1645] = _val1646
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1660,viter1661 in list(self.success.items()):
        oprot.writeI64(kiter1660)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1661))
        for kiter1662,viter1663 in list(viter1661.items()):
          oprot.writeString(kiter1662)
          oprot.writeSetBegin(TType.STRUCT, len(viter1663))
          for iter1664 in viter1663:
            iter1664.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordTime_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordTimestr_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecord_args:
  """
  Attributes:
   - keys
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, record=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1668, _size1665) = iprot.readListBegin()
          for _i1669 in range(_size1665):
            _elem1670 = iprot.readString()
            self.keys.append(_elem1670)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecord_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1671 in self.keys:
        oprot.writeString(iter1671)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1673, _vtype1674, _size1672 ) = iprot.readMapBegin()
          for _i1676 in range(_size1672):
            _key1677 = iprot.readString()
            _val1678 = TObject()
            _val1678.read(iprot)
            self.success[_key1677] = _val1678
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter1679,viter1680 in list(self.success.items()):
        oprot.writeString(kiter1679)
        viter1680.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordTime_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1684, _size1681) = iprot.readListBegin()
          for _i1685 in range(_size1681):
            _elem1686 = iprot.readString()
            self.keys.append(_elem1686)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1687 in self.keys:
        oprot.writeString(iter1687)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1689, _vtype1690, _size1688 ) = iprot.readMapBegin()
          for _i1692 in range(_size1688):
            _key1693 = iprot.readString()
            _val1694 = TObject()
            _val1694.read(iprot)
            self.success[_key1693] = _val1694
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter1695,viter1696 in list(self.success.items()):
        oprot.writeString(kiter1695)
        viter1696.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordTimestr_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1700, _size1697) = iprot.readListBegin()
          for _i1701 in range(_size1697):
            _elem1702 = iprot.readString()
            self.keys.append(_elem1702)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1703 in self.keys:
        oprot.writeString(iter1703)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1705, _vtype1706, _size1704 ) = iprot.readMapBegin()
          for _i1708 in range(_size1704):
            _key1709 = iprot.readString()
            _val1710 = TObject()
            _val1710.read(iprot)
            self.success[_key1709] = _val1710
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter1711,viter1712 in list(self.success.items()):
        oprot.writeString(kiter1711)
        viter1712.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecords_args:
  """
  Attributes:
   - keys
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, records=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1716, _size1713) = iprot.readListBegin()
          for _i1717 in range(_size1713):
            _elem1718 = iprot.readString()
            self.keys.append(_elem1718)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1722, _size1719) = iprot.readListBegin()
          for _i1723 in range(_size1719):
            _elem1724 = iprot.readI64()
            self.records.append(_elem1724)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecords_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1725 in self.keys:
        oprot.writeString(iter1725)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1726 in self.records:
        oprot.writeI64(iter1726)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1728, _vtype1729, _size1727 ) = iprot.readMapBegin()
          for _i1731 in range(_size1727):
            _key1732 = iprot.readI64()
            _val1733 = {}
            (_ktype1735, _vtype1736, _size1734 ) = iprot.readMapBegin()
            for _i1738 in range(_size1734):
              _key1739 = iprot.readString()
              _val1740 = TObject()
              _val1740.read(iprot)
              _val1733[_key1739] = _val1740
            iprot.readMapEnd()
            self.success[_key1732] = _val1733
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1741,viter1742 in list(self.success.items()):
        oprot.writeI64(kiter1741)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1742))
        for kiter1743,viter1744 in list(viter1742.items()):
          oprot.writeString(kiter1743)
          viter1744.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecords_args:
  """
  Attributes:
   - key
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1748, _size1745) = iprot.readListBegin()
          for _i1749 in range(_size1745):
            _elem1750 = iprot.readI64()
            self.records.append(_elem1750)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1751 in self.records:
        oprot.writeI64(iter1751)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1753, _vtype1754, _size1752 ) = iprot.readMapBegin()
          for _i1756 in range(_size1752):
            _key1757 = iprot.readI64()
            _val1758 = TObject()
            _val1758.read(iprot)
            self.success[_key1757] = _val1758
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1759,viter1760 in list(self.success.items()):
        oprot.writeI64(kiter1759)
        viter1760.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordsTime_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1764, _size1761) = iprot.readListBegin()
          for _i1765 in range(_size1761):
            _elem1766 = iprot.readI64()
            self.records.append(_elem1766)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordsTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1767 in self.records:
        oprot.writeI64(iter1767)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1769, _vtype1770, _size1768 ) = iprot.readMapBegin()
          for _i1772 in range(_size1768):
            _key1773 = iprot.readI64()
            _val1774 = TObject()
            _val1774.read(iprot)
            self.success[_key1773] = _val1774
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1775,viter1776 in list(self.success.items()):
        oprot.writeI64(kiter1775)
        viter1776.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordsTimestr_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1780, _size1777) = iprot.readListBegin()
          for _i1781 in range(_size1777):
            _elem1782 = iprot.readI64()
            self.records.append(_elem1782)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordsTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1783 in self.records:
        oprot.writeI64(iter1783)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1785, _vtype1786, _size1784 ) = iprot.readMapBegin()
          for _i1788 in range(_size1784):
            _key1789 = iprot.readI64()
            _val1790 = TObject()
            _val1790.read(iprot)
            self.success[_key1789] = _val1790
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1791,viter1792 in list(self.success.items()):
        oprot.writeI64(kiter1791)
        viter1792.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordsTime_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1796, _size1793) = iprot.readListBegin()
          for _i1797 in range(_size1793):
            _elem1798 = iprot.readString()
            self.keys.append(_elem1798)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1802, _size1799) = iprot.readListBegin()
          for _i1803 in range(_size1799):
            _elem1804 = iprot.readI64()
            self.records.append(_elem1804)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordsTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1805 in self.keys:
        oprot.writeString(iter1805)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1806 in self.records:
        oprot.writeI64(iter1806)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1808, _vtype1809, _size1807 ) = iprot.readMapBegin()
          for _i1811 in range(_size1807):
            _key1812 = iprot.readI64()
            _val1813 = {}
            (_ktype1815, _vtype1816, _size1814 ) = iprot.readMapBegin()
            for _i1818 in range(_size1814):
              _key1819 = iprot.readString()
              _val1820 = TObject()
              _val1820.read(iprot)
              _val1813[_key1819] = _val1820
            iprot.readMapEnd()
            self.success[_key1812] = _val1813
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1821,viter1822 in list(self.success.items()):
        oprot.writeI64(kiter1821)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1822))
        for kiter1823,viter1824 in list(viter1822.items()):
          oprot.writeString(kiter1823)
          viter1824.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordsTimestr_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1828, _size1825) = iprot.readListBegin()
          for _i1829 in range(_size1825):
            _elem1830 = iprot.readString()
            self.keys.append(_elem1830)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1834, _size1831) = iprot.readListBegin()
          for _i1835 in range(_size1831):
            _elem1836 = iprot.readI64()
            self.records.append(_elem1836)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordsTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1837 in self.keys:
        oprot.writeString(iter1837)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1838 in self.records:
        oprot.writeI64(iter1838)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1840, _vtype1841, _size1839 ) = iprot.readMapBegin()
          for _i1843 in range(_size1839):
            _key1844 = iprot.readI64()
            _val1845 = {}
            (_ktype1847, _vtype1848, _size1846 ) = iprot.readMapBegin()
            for _i1850 in range(_size1846):
              _key1851 = iprot.readString()
              _val1852 = TObject()
              _val1852.read(iprot)
              _val1845[_key1851] = _val1852
            iprot.readMapEnd()
            self.success[_key1844] = _val1845
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1853,viter1854 in list(self.success.items()):
        oprot.writeI64(kiter1853)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1854))
        for kiter1855,viter1856 in list(viter1854.items()):
          oprot.writeString(kiter1855)
          viter1856.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteria_args:
  """
  Attributes:
   - key
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteria_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1858, _vtype1859, _size1857 ) = iprot.readMapBegin()
          for _i1861 in range(_size1857):
            _key1862 = iprot.readI64()
            _val1863 = TObject()
            _val1863.read(iprot)
            self.success[_key1862] = _val1863
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1864,viter1865 in list(self.success.items()):
        oprot.writeI64(kiter1864)
        viter1865.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteria_args:
  """
  Attributes:
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, criteria=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteria_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1867, _vtype1868, _size1866 ) = iprot.readMapBegin()
          for _i1870 in range(_size1866):
            _key1871 = iprot.readI64()
            _val1872 = {}
            (_ktype1874, _vtype1875, _size1873 ) = iprot.readMapBegin()
            for _i1877 in range(_size1873):
              _key1878 = iprot.readString()
              _val1879 = TObject()
              _val1879.read(iprot)
              _val1872[_key1878] = _val1879
            iprot.readMapEnd()
            self.success[_key1871] = _val1872
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1880,viter1881 in list(self.success.items()):
        oprot.writeI64(kiter1880)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1881))
        for kiter1882,viter1883 in list(viter1881.items()):
          oprot.writeString(kiter1882)
          viter1883.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCcl_args:
  """
  Attributes:
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, ccl=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCcl_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1885, _vtype1886, _size1884 ) = iprot.readMapBegin()
          for _i1888 in range(_size1884):
            _key1889 = iprot.readI64()
            _val1890 = {}
            (_ktype1892, _vtype1893, _size1891 ) = iprot.readMapBegin()
            for _i1895 in range(_size1891):
              _key1896 = iprot.readString()
              _val1897 = TObject()
              _val1897.read(iprot)
              _val1890[_key1896] = _val1897
            iprot.readMapEnd()
            self.success[_key1889] = _val1890
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1898,viter1899 in list(self.success.items()):
        oprot.writeI64(kiter1898)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1899))
        for kiter1900,viter1901 in list(viter1899.items()):
          oprot.writeString(kiter1900)
          viter1901.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteriaTime_args:
  """
  Attributes:
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteriaTime_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1903, _vtype1904, _size1902 ) = iprot.readMapBegin()
          for _i1906 in range(_size1902):
            _key1907 = iprot.readI64()
            _val1908 = {}
            (_ktype1910, _vtype1911, _size1909 ) = iprot.readMapBegin()
            for _i1913 in range(_size1909):
              _key1914 = iprot.readString()
              _val1915 = TObject()
              _val1915.read(iprot)
              _val1908[_key1914] = _val1915
            iprot.readMapEnd()
            self.success[_key1907] = _val1908
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1916,viter1917 in list(self.success.items()):
        oprot.writeI64(kiter1916)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1917))
        for kiter1918,viter1919 in list(viter1917.items()):
          oprot.writeString(kiter1918)
          viter1919.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteriaTimestr_args:
  """
  Attributes:
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteriaTimestr_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1921, _vtype1922, _size1920 ) = iprot.readMapBegin()
          for _i1924 in range(_size1920):
            _key1925 = iprot.readI64()
            _val1926 = {}
            (_ktype1928, _vtype1929, _size1927 ) = iprot.readMapBegin()
            for _i1931 in range(_size1927):
              _key1932 = iprot.readString()
              _val1933 = TObject()
              _val1933.read(iprot)
              _val1926[_key1932] = _val1933
            iprot.readMapEnd()
            self.success[_key1925] = _val1926
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1934,viter1935 in list(self.success.items()):
        oprot.writeI64(kiter1934)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1935))
        for kiter1936,viter1937 in list(viter1935.items()):
          oprot.writeString(kiter1936)
          viter1937.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCclTime_args:
  """
  Attributes:
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCclTime_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1939, _vtype1940, _size1938 ) = iprot.readMapBegin()
          for _i1942 in range(_size1938):
            _key1943 = iprot.readI64()
            _val1944 = {}
            (_ktype1946, _vtype1947, _size1945 ) = iprot.readMapBegin()
            for _i1949 in range(_size1945):
              _key1950 = iprot.readString()
              _val1951 = TObject()
              _val1951.read(iprot)
              _val1944[_key1950] = _val1951
            iprot.readMapEnd()
            self.success[_key1943] = _val1944
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1952,viter1953 in list(self.success.items()):
        oprot.writeI64(kiter1952)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1953))
        for kiter1954,viter1955 in list(viter1953.items()):
          oprot.writeString(kiter1954)
          viter1955.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCclTimestr_args:
  """
  Attributes:
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCclTimestr_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1957, _vtype1958, _size1956 ) = iprot.readMapBegin()
          for _i1960 in range(_size1956):
            _key1961 = iprot.readI64()
            _val1962 = {}
            (_ktype1964, _vtype1965, _size1963 ) = iprot.readMapBegin()
            for _i1967 in range(_size1963):
              _key1968 = iprot.readString()
              _val1969 = TObject()
              _val1969.read(iprot)
              _val1962[_key1968] = _val1969
            iprot.readMapEnd()
            self.success[_key1961] = _val1962
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1970,viter1971 in list(self.success.items()):
        oprot.writeI64(kiter1970)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1971))
        for kiter1972,viter1973 in list(viter1971.items()):
          oprot.writeString(kiter1972)
          viter1973.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCcl_args:
  """
  Attributes:
   - key
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCcl_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1975, _vtype1976, _size1974 ) = iprot.readMapBegin()
          for _i1978 in range(_size1974):
            _key1979 = iprot.readI64()
            _val1980 = TObject()
            _val1980.read(iprot)
            self.success[_key1979] = _val1980
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1981,viter1982 in list(self.success.items()):
        oprot.writeI64(kiter1981)
        viter1982.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteriaTime_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteriaTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1984, _vtype1985, _size1983 ) = iprot.readMapBegin()
          for _i1987 in range(_size1983):
            _key1988 = iprot.readI64()
            _val1989 = TObject()
            _val1989.read(iprot)
            self.success[_key1988] = _val1989
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1990,viter1991 in list(self.success.items()):
        oprot.writeI64(kiter1990)
        viter1991.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteriaTimestr_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteriaTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1993, _vtype1994, _size1992 ) = iprot.readMapBegin()
          for _i1996 in range(_size1992):
            _key1997 = iprot.readI64()
            _val1998 = TObject()
            _val1998.read(iprot)
            self.success[_key1997] = _val1998
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1999,viter2000 in list(self.success.items()):
        oprot.writeI64(kiter1999)
        viter2000.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCclTime_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCclTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2002, _vtype2003, _size2001 ) = iprot.readMapBegin()
          for _i2005 in range(_size2001):
            _key2006 = iprot.readI64()
            _val2007 = TObject()
            _val2007.read(iprot)
            self.success[_key2006] = _val2007
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter2008,viter2009 in list(self.success.items()):
        oprot.writeI64(kiter2008)
        viter2009.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCclTimestr_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCclTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2011, _vtype2012, _size2010 ) = iprot.readMapBegin()
          for _i2014 in range(_size2010):
            _key2015 = iprot.readI64()
            _val2016 = TObject()
            _val2016.read(iprot)
            self.success[_key2015] = _val2016
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter2017,viter2018 in list(self.success.items()):
        oprot.writeI64(kiter2017)
        viter2018.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteria_args:
  """
  Attributes:
   - keys
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2022, _size2019) = iprot.readListBegin()
          for _i2023 in range(_size2019):
            _elem2024 = iprot.readString()
            self.keys.append(_elem2024)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteria_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2025 in self.keys:
        oprot.writeString(iter2025)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2027, _vtype2028, _size2026 ) = iprot.readMapBegin()
          for _i2030 in range(_size2026):
            _key2031 = iprot.readI64()
            _val2032 = {}
            (_ktype2034, _vtype2035, _size2033 ) = iprot.readMapBegin()
            for _i2037 in range(_size2033):
              _key2038 = iprot.readString()
              _val2039 = TObject()
              _val2039.read(iprot)
              _val2032[_key2038] = _val2039
            iprot.readMapEnd()
            self.success[_key2031] = _val2032
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2040,viter2041 in list(self.success.items()):
        oprot.writeI64(kiter2040)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2041))
        for kiter2042,viter2043 in list(viter2041.items()):
          oprot.writeString(kiter2042)
          viter2043.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCcl_args:
  """
  Attributes:
   - keys
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2047, _size2044) = iprot.readListBegin()
          for _i2048 in range(_size2044):
            _elem2049 = iprot.readString()
            self.keys.append(_elem2049)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCcl_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2050 in self.keys:
        oprot.writeString(iter2050)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2052, _vtype2053, _size2051 ) = iprot.readMapBegin()
          for _i2055 in range(_size2051):
            _key2056 = iprot.readI64()
            _val2057 = {}
            (_ktype2059, _vtype2060, _size2058 ) = iprot.readMapBegin()
            for _i2062 in range(_size2058):
              _key2063 = iprot.readString()
              _val2064 = TObject()
              _val2064.read(iprot)
              _val2057[_key2063] = _val2064
            iprot.readMapEnd()
            self.success[_key2056] = _val2057
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2065,viter2066 in list(self.success.items()):
        oprot.writeI64(kiter2065)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2066))
        for kiter2067,viter2068 in list(viter2066.items()):
          oprot.writeString(kiter2067)
          viter2068.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteriaTime_args:
  """
  Attributes:
   - keys
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2072, _size2069) = iprot.readListBegin()
          for _i2073 in range(_size2069):
            _elem2074 = iprot.readString()
            self.keys.append(_elem2074)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteriaTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2075 in self.keys:
        oprot.writeString(iter2075)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2077, _vtype2078, _size2076 ) = iprot.readMapBegin()
          for _i2080 in range(_size2076):
            _key2081 = iprot.readI64()
            _val2082 = {}
            (_ktype2084, _vtype2085, _size2083 ) = iprot.readMapBegin()
            for _i2087 in range(_size2083):
              _key2088 = iprot.readString()
              _val2089 = TObject()
              _val2089.read(iprot)
              _val2082[_key2088] = _val2089
            iprot.readMapEnd()
            self.success[_key2081] = _val2082
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2090,viter2091 in list(self.success.items()):
        oprot.writeI64(kiter2090)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2091))
        for kiter2092,viter2093 in list(viter2091.items()):
          oprot.writeString(kiter2092)
          viter2093.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteriaTimestr_args:
  """
  Attributes:
   - keys
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2097, _size2094) = iprot.readListBegin()
          for _i2098 in range(_size2094):
            _elem2099 = iprot.readString()
            self.keys.append(_elem2099)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteriaTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2100 in self.keys:
        oprot.writeString(iter2100)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2102, _vtype2103, _size2101 ) = iprot.readMapBegin()
          for _i2105 in range(_size2101):
            _key2106 = iprot.readI64()
            _val2107 = {}
            (_ktype2109, _vtype2110, _size2108 ) = iprot.readMapBegin()
            for _i2112 in range(_size2108):
              _key2113 = iprot.readString()
              _val2114 = TObject()
              _val2114.read(iprot)
              _val2107[_key2113] = _val2114
            iprot.readMapEnd()
            self.success[_key2106] = _val2107
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2115,viter2116 in list(self.success.items()):
        oprot.writeI64(kiter2115)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2116))
        for kiter2117,viter2118 in list(viter2116.items()):
          oprot.writeString(kiter2117)
          viter2118.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCclTime_args:
  """
  Attributes:
   - keys
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2122, _size2119) = iprot.readListBegin()
          for _i2123 in range(_size2119):
            _elem2124 = iprot.readString()
            self.keys.append(_elem2124)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCclTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2125 in self.keys:
        oprot.writeString(iter2125)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2127, _vtype2128, _size2126 ) = iprot.readMapBegin()
          for _i2130 in range(_size2126):
            _key2131 = iprot.readI64()
            _val2132 = {}
            (_ktype2134, _vtype2135, _size2133 ) = iprot.readMapBegin()
            for _i2137 in range(_size2133):
              _key2138 = iprot.readString()
              _val2139 = TObject()
              _val2139.read(iprot)
              _val2132[_key2138] = _val2139
            iprot.readMapEnd()
            self.success[_key2131] = _val2132
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2140,viter2141 in list(self.success.items()):
        oprot.writeI64(kiter2140)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2141))
        for kiter2142,viter2143 in list(viter2141.items()):
          oprot.writeString(kiter2142)
          viter2143.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCclTimestr_args:
  """
  Attributes:
   - keys
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2147, _size2144) = iprot.readListBegin()
          for _i2148 in range(_size2144):
            _elem2149 = iprot.readString()
            self.keys.append(_elem2149)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCclTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2150 in self.keys:
        oprot.writeString(iter2150)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2152, _vtype2153, _size2151 ) = iprot.readMapBegin()
          for _i2155 in range(_size2151):
            _key2156 = iprot.readI64()
            _val2157 = {}
            (_ktype2159, _vtype2160, _size2158 ) = iprot.readMapBegin()
            for _i2162 in range(_size2158):
              _key2163 = iprot.readString()
              _val2164 = TObject()
              _val2164.read(iprot)
              _val2157[_key2163] = _val2164
            iprot.readMapEnd()
            self.success[_key2156] = _val2157
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2165,viter2166 in list(self.success.items()):
        oprot.writeI64(kiter2165)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2166))
        for kiter2167,viter2168 in list(viter2166.items()):
          oprot.writeString(kiter2167)
          viter2168.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecord_args:
  """
  Attributes:
   - key
   - value
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecordTime_args:
  """
  Attributes:
   - key
   - value
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.I64, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, value=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 4)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecordTimestr_args:
  """
  Attributes:
   - key
   - value
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRING, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, value=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 4)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecords_args:
  """
  Attributes:
   - records
   - identifier
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.BOOL, 'identifier', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, records=None, identifier=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.identifier = identifier
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype2172, _size2169) = iprot.readListBegin()
          for _i2173 in range(_size2169):
            _elem2174 = iprot.readI64()
            self.records.append(_elem2174)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.identifier = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecords_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2175 in self.records:
        oprot.writeI64(iter2175)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.identifier is not None:
      oprot.writeFieldBegin('identifier', TType.BOOL, 2)
      oprot.writeBool(self.identifier)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.identifier)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecordsTime_args:
  """
  Attributes:
   - records
   - timestamp
   - identifier
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.BOOL, 'identifier', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, records=None, timestamp=None, identifier=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.identifier = identifier
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype2179, _size2176) = iprot.readListBegin()
          for _i2180 in range(_size2176):
            _elem2181 = iprot.readI64()
            self.records.append(_elem2181)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.identifier = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecordsTime_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2182 in self.records:
        oprot.writeI64(iter2182)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.identifier is not None:
      oprot.writeFieldBegin('identifier', TType.BOOL, 3)
      oprot.writeBool(self.identifier)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.identifier)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecordsTimestr_args:
  """
  Attributes:
   - records
   - timestamp
   - identifier
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.BOOL, 'identifier', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, records=None, timestamp=None, identifier=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.identifier = identifier
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype2186, _size2183) = iprot.readListBegin()
          for _i2187 in range(_size2183):
            _elem2188 = iprot.readI64()
            self.records.append(_elem2188)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.identifier = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecordsTimestr_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2189 in self.records:
        oprot.writeI64(iter2189)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.identifier is not None:
      oprot.writeFieldBegin('identifier', TType.BOOL, 3)
      oprot.writeBool(self.identifier)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.identifier)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findCriteria_args:
  """
  Attributes:
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, criteria=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findCriteria_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2193, _size2190) = iprot.readSetBegin()
          for _i2194 in range(_size2190):
            _elem2195 = iprot.readI64()
            self.success.append(_elem2195)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2196 in self.success:
        oprot.writeI64(iter2196)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findCcl_args:
  """
  Attributes:
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, ccl=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findCcl_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2200, _size2197) = iprot.readSetBegin()
          for _i2201 in range(_size2197):
            _elem2202 = iprot.readI64()
            self.success.append(_elem2202)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2203 in self.success:
        oprot.writeI64(iter2203)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValues_args:
  """
  Attributes:
   - key
   - operator
   - values
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I32, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, operator=None, values=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.operator = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2207, _size2204) = iprot.readListBegin()
          for _i2208 in range(_size2204):
            _elem2209 = TObject()
            _elem2209.read(iprot)
            self.values.append(_elem2209)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValues_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.I32, 2)
      oprot.writeI32(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2210 in self.values:
        iter2210.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValues_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2214, _size2211) = iprot.readSetBegin()
          for _i2215 in range(_size2211):
            _elem2216 = iprot.readI64()
            self.success.append(_elem2216)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValues_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2217 in self.success:
        oprot.writeI64(iter2217)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValuesTime_args:
  """
  Attributes:
   - key
   - operator
   - values
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I32, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.I64, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, operator=None, values=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.operator = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2221, _size2218) = iprot.readListBegin()
          for _i2222 in range(_size2218):
            _elem2223 = TObject()
            _elem2223.read(iprot)
            self.values.append(_elem2223)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValuesTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.I32, 2)
      oprot.writeI32(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2224 in self.values:
        iter2224.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 4)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValuesTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2228, _size2225) = iprot.readSetBegin()
          for _i2229 in range(_size2225):
            _elem2230 = iprot.readI64()
            self.success.append(_elem2230)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValuesTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2231 in self.success:
        oprot.writeI64(iter2231)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValuesTimestr_args:
  """
  Attributes:
   - key
   - operator
   - values
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I32, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.STRING, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, operator=None, values=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.operator = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2235, _size2232) = iprot.readListBegin()
          for _i2236 in range(_size2232):
            _elem2237 = TObject()
            _elem2237.read(iprot)
            self.values.append(_elem2237)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValuesTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.I32, 2)
      oprot.writeI32(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2238 in self.values:
        iter2238.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 4)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValuesTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2242, _size2239) = iprot.readSetBegin()
          for _i2243 in range(_size2239):
            _elem2244 = iprot.readI64()
            self.success.append(_elem2244)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValuesTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2245 in self.success:
        oprot.writeI64(iter2245)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValues_args:
  """
  Attributes:
   - key
   - operator
   - values
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, operator=None, values=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.operator = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2249, _size2246) = iprot.readListBegin()
          for _i2250 in range(_size2246):
            _elem2251 = TObject()
            _elem2251.read(iprot)
            self.values.append(_elem2251)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValues_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.STRING, 2)
      oprot.writeString(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2252 in self.values:
        iter2252.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValues_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2256, _size2253) = iprot.readSetBegin()
          for _i2257 in range(_size2253):
            _elem2258 = iprot.readI64()
            self.success.append(_elem2258)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValues_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2259 in self.success:
        oprot.writeI64(iter2259)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValuesTime_args:
  """
  Attributes:
   - key
   - operator
   - values
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.I64, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, operator=None, values=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.operator = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2263, _size2260) = iprot.readListBegin()
          for _i2264 in range(_size2260):
            _elem2265 = TObject()
            _elem2265.read(iprot)
            self.values.append(_elem2265)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValuesTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.STRING, 2)
      oprot.writeString(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2266 in self.values:
        iter2266.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 4)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValuesTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2270, _size2267) = iprot.readSetBegin()
          for _i2271 in range(_size2267):
            _elem2272 = iprot.readI64()
            self.success.append(_elem2272)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValuesTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2273 in self.success:
        oprot.writeI64(iter2273)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValuesTimestr_args:
  """
  Attributes:
   - key
   - operator
   - values
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.STRING, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, operator=None, values=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.operator = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2277, _size2274) = iprot.readListBegin()
          for _i2278 in range(_size2274):
            _elem2279 = TObject()
            _elem2279.read(iprot)
            self.values.append(_elem2279)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValuesTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.STRING, 2)
      oprot.writeString(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2280 in self.values:
        iter2280.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 4)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValuesTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2284, _size2281) = iprot.readSetBegin()
          for _i2285 in range(_size2281):
            _elem2286 = iprot.readI64()
            self.success.append(_elem2286)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValuesTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2287 in self.success:
        oprot.writeI64(iter2287)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class search_args:
  """
  Attributes:
   - key
   - query
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'query', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, query=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.query = query
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.query = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('search_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.query is not None:
      oprot.writeFieldBegin('query', TType.STRING, 2)
      oprot.writeString(self.query)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.query)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class search_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2291, _size2288) = iprot.readSetBegin()
          for _i2292 in range(_size2288):
            _elem2293 = iprot.readI64()
            self.success.append(_elem2293)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('search_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2294 in self.success:
        oprot.writeI64(iter2294)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordsTime_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2298, _size2295) = iprot.readListBegin()
          for _i2299 in range(_size2295):
            _elem2300 = iprot.readString()
            self.keys.append(_elem2300)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2304, _size2301) = iprot.readListBegin()
          for _i2305 in range(_size2301):
            _elem2306 = iprot.readI64()
            self.records.append(_elem2306)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordsTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2307 in self.keys:
        oprot.writeString(iter2307)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2308 in self.records:
        oprot.writeI64(iter2308)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordsTime_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordsTime_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordsTimestr_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2312, _size2309) = iprot.readListBegin()
          for _i2313 in range(_size2309):
            _elem2314 = iprot.readString()
            self.keys.append(_elem2314)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2318, _size2315) = iprot.readListBegin()
          for _i2319 in range(_size2315):
            _elem2320 = iprot.readI64()
            self.records.append(_elem2320)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordsTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2321 in self.keys:
        oprot.writeString(iter2321)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2322 in self.records:
        oprot.writeI64(iter2322)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordsTimestr_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordsTimestr_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordTime_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2326, _size2323) = iprot.readListBegin()
          for _i2327 in range(_size2323):
            _elem2328 = iprot.readString()
            self.keys.append(_elem2328)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2329 in self.keys:
        oprot.writeString(iter2329)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordTime_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordTime_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordTimestr_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2333, _size2330) = iprot.readListBegin()
          for _i2334 in range(_size2330):
            _elem2335 = iprot.readString()
            self.keys.append(_elem2335)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2336 in self.keys:
        oprot.writeString(iter2336)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordTimestr_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordTimestr_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordsTime_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2340, _size2337) = iprot.readListBegin()
          for _i2341 in range(_size2337):
            _elem2342 = iprot.readI64()
            self.records.append(_elem2342)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordsTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2343 in self.records:
        oprot.writeI64(iter2343)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordsTime_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordsTime_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordsTimestr_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2347, _size2344) = iprot.readListBegin()
          for _i2348 in range(_size2344):
            _elem2349 = iprot.readI64()
            self.records.append(_elem2349)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordsTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2350 in self.records:
        oprot.writeI64(iter2350)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordsTimestr_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordsTimestr_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordTime_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordTime_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordTime_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordTimestr_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordTimestr_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordTimestr_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingRecords_args:
  """
  Attributes:
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, records=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype2354, _size2351) = iprot.readListBegin()
          for _i2355 in range(_size2351):
            _elem2356 = iprot.readI64()
            self.records.append(_elem2356)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingRecords_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2357 in self.records:
        oprot.writeI64(iter2357)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.BOOL,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2359, _vtype2360, _size2358 ) = iprot.readMapBegin()
          for _i2362 in range(_size2358):
            _key2363 = iprot.readI64()
            _val2364 = iprot.readBool()
            self.success[_key2363] = _val2364
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.BOOL, len(self.success))
      for kiter2365,viter2366 in list(self.success.items()):
        oprot.writeI64(kiter2365)
        oprot.writeBool(viter2366)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingRecord_args:
  """
  Attributes:
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, record=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyAndSwap_args:
  """
  Attributes:
   - key
   - expected
   - record
   - replacement
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'expected', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'replacement', (TObject, TObject.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, expected=None, record=None, replacement=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.expected = expected
    self.record = record
    self.replacement = replacement
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.expected = TObject()
          self.expected.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.replacement = TObject()
          self.replacement.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyAndSwap_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.expected is not None:
      oprot.writeFieldBegin('expected', TType.STRUCT, 2)
      self.expected.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.replacement is not None:
      oprot.writeFieldBegin('replacement', TType.STRUCT, 4)
      self.replacement.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.expected)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.replacement)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyAndSwap_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyAndSwap_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyOrSet_args:
  """
  Attributes:
   - key
   - value
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyOrSet_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyOrSet_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyOrSet_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrAddKeyValue_args:
  """
  Attributes:
   - key
   - value
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, value=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrAddKeyValue_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrAddKeyValue_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
   - ex4
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (DuplicateEntryException, DuplicateEntryException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ex4', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3
    self.ex4 = ex4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = DuplicateEntryException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ex4 = InvalidArgumentException()
          self.ex4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrAddKeyValue_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    if self.ex4 is not None:
      oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
      self.ex4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    value = (value * 31) ^ hash(self.ex4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrInsertCriteriaJson_args:
  """
  Attributes:
   - criteria
   - json
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRING, 'json', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, criteria=None, json=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.json = json
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.json = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrInsertCriteriaJson_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.json is not None:
      oprot.writeFieldBegin('json', TType.STRING, 2)
      oprot.writeString(self.json)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.json)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrInsertCriteriaJson_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (DuplicateEntryException, DuplicateEntryException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = DuplicateEntryException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrInsertCriteriaJson_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrInsertCclJson_args:
  """
  Attributes:
   - ccl
   - json
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRING, 'json', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, ccl=None, json=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.json = json
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.json = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrInsertCclJson_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.json is not None:
      oprot.writeFieldBegin('json', TType.STRING, 2)
      oprot.writeString(self.json)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.json)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrInsertCclJson_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
   - ex4
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ex4', (DuplicateEntryException, DuplicateEntryException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3
    self.ex4 = ex4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ex4 = DuplicateEntryException()
          self.ex4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrInsertCclJson_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    if self.ex4 is not None:
      oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
      self.ex4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    value = (value * 31) ^ hash(self.ex4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyRecordTime_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyRecordTimestr_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyRecords_args:
  """
  Attributes:
   - key
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2370, _size2367) = iprot.readListBegin()
          for _i2371 in range(_size2367):
            _elem2372 = iprot.readI64()
            self.records.append(_elem2372)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2373 in self.records:
        oprot.writeI64(iter2373)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyRecordsTime_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2377, _size2374) = iprot.readListBegin()
          for _i2378 in range(_size2374):
            _elem2379 = iprot.readI64()
            self.records.append(_elem2379)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyRecordsTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2380 in self.records:
        oprot.writeI64(iter2380)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyRecordsTimestr_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2384, _size2381) = iprot.readListBegin()
          for _i2385 in range(_size2381):
            _elem2386 = iprot.readI64()
            self.records.append(_elem2386)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyRecordsTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2387 in self.records:
        oprot.writeI64(iter2387)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKey_args:
  """
  Attributes:
   - key
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, key=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKey_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKey_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKey_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyTime_args:
  """
  Attributes:
   - key
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyTimestr_args:
  """
  Attributes:
   - key
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyCriteria_args:
  """
  Attributes:
   - key
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyCriteria_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyCriteriaTime_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyCriteriaTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyCriteriaTimestr_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyCriteriaTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyCcl_args:
  """
  Attributes:
   - key
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyCcl_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyCclTime_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyCclTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyCclTimestr_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyCclTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sumKeyCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sumKeyCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyRecordTime_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyRecordTimestr_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyRecords_args:
  """
  Attributes:
   - key
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2391, _size2388) = iprot.readListBegin()
          for _i2392 in range(_size2388):
            _elem2393 = iprot.readI64()
            self.records.append(_elem2393)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2394 in self.records:
        oprot.writeI64(iter2394)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyRecordsTime_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2398, _size2395) = iprot.readListBegin()
          for _i2399 in range(_size2395):
            _elem2400 = iprot.readI64()
            self.records.append(_elem2400)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyRecordsTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2401 in self.records:
        oprot.writeI64(iter2401)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyRecordsTimestr_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2405, _size2402) = iprot.readListBegin()
          for _i2406 in range(_size2402):
            _elem2407 = iprot.readI64()
            self.records.append(_elem2407)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyRecordsTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2408 in self.records:
        oprot.writeI64(iter2408)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKey_args:
  """
  Attributes:
   - key
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, key=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKey_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKey_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKey_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyTime_args:
  """
  Attributes:
   - key
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyTimestr_args:
  """
  Attributes:
   - key
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyCriteria_args:
  """
  Attributes:
   - key
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyCriteria_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyCriteriaTime_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyCriteriaTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyCriteriaTimestr_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyCriteriaTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyCcl_args:
  """
  Attributes:
   - key
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyCcl_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyCclTime_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyCclTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyCclTimestr_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyCclTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class averageKeyCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('averageKeyCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyRecordTime_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyRecordTimestr_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyRecords_args:
  """
  Attributes:
   - key
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2412, _size2409) = iprot.readListBegin()
          for _i2413 in range(_size2409):
            _elem2414 = iprot.readI64()
            self.records.append(_elem2414)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2415 in self.records:
        oprot.writeI64(iter2415)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyRecordsTime_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2419, _size2416) = iprot.readListBegin()
          for _i2420 in range(_size2416):
            _elem2421 = iprot.readI64()
            self.records.append(_elem2421)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyRecordsTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2422 in self.records:
        oprot.writeI64(iter2422)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyRecordsTimestr_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2426, _size2423) = iprot.readListBegin()
          for _i2427 in range(_size2423):
            _elem2428 = iprot.readI64()
            self.records.append(_elem2428)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyRecordsTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2429 in self.records:
        oprot.writeI64(iter2429)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKey_args:
  """
  Attributes:
   - key
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, key=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKey_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKey_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKey_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyTime_args:
  """
  Attributes:
   - key
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyTimestr_args:
  """
  Attributes:
   - key
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyCriteria_args:
  """
  Attributes:
   - key
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyCriteria_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyCriteriaTime_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyCriteriaTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyCriteriaTimestr_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyCriteriaTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyCcl_args:
  """
  Attributes:
   - key
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyCcl_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyCclTime_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyCclTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyCclTimestr_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyCclTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countKeyCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countKeyCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyRecordTime_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyRecordTimestr_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyRecords_args:
  """
  Attributes:
   - key
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2433, _size2430) = iprot.readListBegin()
          for _i2434 in range(_size2430):
            _elem2435 = iprot.readI64()
            self.records.append(_elem2435)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2436 in self.records:
        oprot.writeI64(iter2436)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyRecordsTime_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2440, _size2437) = iprot.readListBegin()
          for _i2441 in range(_size2437):
            _elem2442 = iprot.readI64()
            self.records.append(_elem2442)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyRecordsTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2443 in self.records:
        oprot.writeI64(iter2443)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyRecordsTimestr_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2447, _size2444) = iprot.readListBegin()
          for _i2448 in range(_size2444):
            _elem2449 = iprot.readI64()
            self.records.append(_elem2449)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyRecordsTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2450 in self.records:
        oprot.writeI64(iter2450)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyCriteria_args:
  """
  Attributes:
   - key
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyCriteria_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyCriteriaTime_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyCriteriaTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyCriteriaTimestr_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyCriteriaTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyCcl_args:
  """
  Attributes:
   - key
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyCcl_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyCclTime_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyCclTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyCclTimestr_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyCclTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKey_args:
  """
  Attributes:
   - key
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, key=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKey_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKey_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKey_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyTime_args:
  """
  Attributes:
   - key
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyTimestr_args:
  """
  Attributes:
   - key
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class maxKeyTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('maxKeyTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyRecordTime_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyRecordTimestr_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKey_args:
  """
  Attributes:
   - key
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, key=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKey_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKey_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKey_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyRecordsTime_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2454, _size2451) = iprot.readListBegin()
          for _i2455 in range(_size2451):
            _elem2456 = iprot.readI64()
            self.records.append(_elem2456)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyRecordsTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2457 in self.records:
        oprot.writeI64(iter2457)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyRecordsTimestr_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2461, _size2458) = iprot.readListBegin()
          for _i2462 in range(_size2458):
            _elem2463 = iprot.readI64()
            self.records.append(_elem2463)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyRecordsTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2464 in self.records:
        oprot.writeI64(iter2464)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyCriteria_args:
  """
  Attributes:
   - key
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyCriteria_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyCriteriaTime_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyCriteriaTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyCriteriaTimestr_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyCriteriaTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyCcl_args:
  """
  Attributes:
   - key
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyCcl_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyCclTime_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyCclTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyCclTimestr_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyCclTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyTime_args:
  """
  Attributes:
   - key
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyTimestr_args:
  """
  Attributes:
   - key
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyRecords_args:
  """
  Attributes:
   - key
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2468, _size2465) = iprot.readListBegin()
          for _i2469 in range(_size2465):
            _elem2470 = iprot.readI64()
            self.records.append(_elem2470)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2471 in self.records:
        oprot.writeI64(iter2471)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class minKeyRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('minKeyRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2473, _vtype2474, _size2472 ) = iprot.readMapBegin()
          for _i2476 in range(_size2472):
            _key2477 = iprot.readI64()
            _val2478 = []
            (_etype2482, _size2479) = iprot.readSetBegin()
            for _i2483 in range(_size2479):
              _elem2484 = TObject()
              _elem2484.read(iprot)
              _val2478.append(_elem2484)
            iprot.readSetEnd()
            self.success[_key2477] = _val2478
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter2485,viter2486 in list(self.success.items()):
        oprot.writeI64(kiter2485)
        oprot.writeSetBegin(TType.STRUCT, len(viter2486))
        for iter2487 in viter2486:
          iter2487.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyRecordTime_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2489, _vtype2490, _size2488 ) = iprot.readMapBegin()
          for _i2492 in range(_size2488):
            _key2493 = iprot.readI64()
            _val2494 = []
            (_etype2498, _size2495) = iprot.readSetBegin()
            for _i2499 in range(_size2495):
              _elem2500 = TObject()
              _elem2500.read(iprot)
              _val2494.append(_elem2500)
            iprot.readSetEnd()
            self.success[_key2493] = _val2494
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter2501,viter2502 in list(self.success.items()):
        oprot.writeI64(kiter2501)
        oprot.writeSetBegin(TType.STRUCT, len(viter2502))
        for iter2503 in viter2502:
          iter2503.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyRecordTimestr_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2505, _vtype2506, _size2504 ) = iprot.readMapBegin()
          for _i2508 in range(_size2504):
            _key2509 = iprot.readI64()
            _val2510 = []
            (_etype2514, _size2511) = iprot.readSetBegin()
            for _i2515 in range(_size2511):
              _elem2516 = TObject()
              _elem2516.read(iprot)
              _val2510.append(_elem2516)
            iprot.readSetEnd()
            self.success[_key2509] = _val2510
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter2517,viter2518 in list(self.success.items()):
        oprot.writeI64(kiter2517)
        oprot.writeSetBegin(TType.STRUCT, len(viter2518))
        for iter2519 in viter2518:
          iter2519.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysRecord_args:
  """
  Attributes:
   - keys
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, record=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2523, _size2520) = iprot.readListBegin()
          for _i2524 in range(_size2520):
            _elem2525 = iprot.readString()
            self.keys.append(_elem2525)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysRecord_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2526 in self.keys:
        oprot.writeString(iter2526)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2528, _vtype2529, _size2527 ) = iprot.readMapBegin()
          for _i2531 in range(_size2527):
            _key2532 = iprot.readI64()
            _val2533 = {}
            (_ktype2535, _vtype2536, _size2534 ) = iprot.readMapBegin()
            for _i2538 in range(_size2534):
              _key2539 = iprot.readString()
              _val2540 = []
              (_etype2544, _size2541) = iprot.readSetBegin()
              for _i2545 in range(_size2541):
                _elem2546 = TObject()
                _elem2546.read(iprot)
                _val2540.append(_elem2546)
              iprot.readSetEnd()
              _val2533[_key2539] = _val2540
            iprot.readMapEnd()
            self.success[_key2532] = _val2533
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2547,viter2548 in list(self.success.items()):
        oprot.writeI64(kiter2547)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2548))
        for kiter2549,viter2550 in list(viter2548.items()):
          oprot.writeString(kiter2549)
          oprot.writeSetBegin(TType.STRUCT, len(viter2550))
          for iter2551 in viter2550:
            iter2551.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysRecordTime_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2555, _size2552) = iprot.readListBegin()
          for _i2556 in range(_size2552):
            _elem2557 = iprot.readString()
            self.keys.append(_elem2557)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysRecordTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2558 in self.keys:
        oprot.writeString(iter2558)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2560, _vtype2561, _size2559 ) = iprot.readMapBegin()
          for _i2563 in range(_size2559):
            _key2564 = iprot.readI64()
            _val2565 = {}
            (_ktype2567, _vtype2568, _size2566 ) = iprot.readMapBegin()
            for _i2570 in range(_size2566):
              _key2571 = iprot.readString()
              _val2572 = []
              (_etype2576, _size2573) = iprot.readSetBegin()
              for _i2577 in range(_size2573):
                _elem2578 = TObject()
                _elem2578.read(iprot)
                _val2572.append(_elem2578)
              iprot.readSetEnd()
              _val2565[_key2571] = _val2572
            iprot.readMapEnd()
            self.success[_key2564] = _val2565
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2579,viter2580 in list(self.success.items()):
        oprot.writeI64(kiter2579)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2580))
        for kiter2581,viter2582 in list(viter2580.items()):
          oprot.writeString(kiter2581)
          oprot.writeSetBegin(TType.STRUCT, len(viter2582))
          for iter2583 in viter2582:
            iter2583.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysRecordTimestr_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2587, _size2584) = iprot.readListBegin()
          for _i2588 in range(_size2584):
            _elem2589 = iprot.readString()
            self.keys.append(_elem2589)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysRecordTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2590 in self.keys:
        oprot.writeString(iter2590)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2592, _vtype2593, _size2591 ) = iprot.readMapBegin()
          for _i2595 in range(_size2591):
            _key2596 = iprot.readI64()
            _val2597 = {}
            (_ktype2599, _vtype2600, _size2598 ) = iprot.readMapBegin()
            for _i2602 in range(_size2598):
              _key2603 = iprot.readString()
              _val2604 = []
              (_etype2608, _size2605) = iprot.readSetBegin()
              for _i2609 in range(_size2605):
                _elem2610 = TObject()
                _elem2610.read(iprot)
                _val2604.append(_elem2610)
              iprot.readSetEnd()
              _val2597[_key2603] = _val2604
            iprot.readMapEnd()
            self.success[_key2596] = _val2597
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2611,viter2612 in list(self.success.items()):
        oprot.writeI64(kiter2611)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2612))
        for kiter2613,viter2614 in list(viter2612.items()):
          oprot.writeString(kiter2613)
          oprot.writeSetBegin(TType.STRUCT, len(viter2614))
          for iter2615 in viter2614:
            iter2615.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysRecords_args:
  """
  Attributes:
   - keys
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, records=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2619, _size2616) = iprot.readListBegin()
          for _i2620 in range(_size2616):
            _elem2621 = iprot.readString()
            self.keys.append(_elem2621)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2625, _size2622) = iprot.readListBegin()
          for _i2626 in range(_size2622):
            _elem2627 = iprot.readI64()
            self.records.append(_elem2627)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysRecords_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2628 in self.keys:
        oprot.writeString(iter2628)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2629 in self.records:
        oprot.writeI64(iter2629)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2631, _vtype2632, _size2630 ) = iprot.readMapBegin()
          for _i2634 in range(_size2630):
            _key2635 = iprot.readI64()
            _val2636 = {}
            (_ktype2638, _vtype2639, _size2637 ) = iprot.readMapBegin()
            for _i2641 in range(_size2637):
              _key2642 = iprot.readString()
              _val2643 = []
              (_etype2647, _size2644) = iprot.readSetBegin()
              for _i2648 in range(_size2644):
                _elem2649 = TObject()
                _elem2649.read(iprot)
                _val2643.append(_elem2649)
              iprot.readSetEnd()
              _val2636[_key2642] = _val2643
            iprot.readMapEnd()
            self.success[_key2635] = _val2636
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2650,viter2651 in list(self.success.items()):
        oprot.writeI64(kiter2650)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2651))
        for kiter2652,viter2653 in list(viter2651.items()):
          oprot.writeString(kiter2652)
          oprot.writeSetBegin(TType.STRUCT, len(viter2653))
          for iter2654 in viter2653:
            iter2654.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyRecords_args:
  """
  Attributes:
   - key
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2658, _size2655) = iprot.readListBegin()
          for _i2659 in range(_size2655):
            _elem2660 = iprot.readI64()
            self.records.append(_elem2660)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2661 in self.records:
        oprot.writeI64(iter2661)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2663, _vtype2664, _size2662 ) = iprot.readMapBegin()
          for _i2666 in range(_size2662):
            _key2667 = iprot.readI64()
            _val2668 = []
            (_etype2672, _size2669) = iprot.readSetBegin()
            for _i2673 in range(_size2669):
              _elem2674 = TObject()
              _elem2674.read(iprot)
              _val2668.append(_elem2674)
            iprot.readSetEnd()
            self.success[_key2667] = _val2668
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter2675,viter2676 in list(self.success.items()):
        oprot.writeI64(kiter2675)
        oprot.writeSetBegin(TType.STRUCT, len(viter2676))
        for iter2677 in viter2676:
          iter2677.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyRecordsTime_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2681, _size2678) = iprot.readListBegin()
          for _i2682 in range(_size2678):
            _elem2683 = iprot.readI64()
            self.records.append(_elem2683)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyRecordsTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2684 in self.records:
        oprot.writeI64(iter2684)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2686, _vtype2687, _size2685 ) = iprot.readMapBegin()
          for _i2689 in range(_size2685):
            _key2690 = iprot.readI64()
            _val2691 = []
            (_etype2695, _size2692) = iprot.readSetBegin()
            for _i2696 in range(_size2692):
              _elem2697 = TObject()
              _elem2697.read(iprot)
              _val2691.append(_elem2697)
            iprot.readSetEnd()
            self.success[_key2690] = _val2691
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter2698,viter2699 in list(self.success.items()):
        oprot.writeI64(kiter2698)
        oprot.writeSetBegin(TType.STRUCT, len(viter2699))
        for iter2700 in viter2699:
          iter2700.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyRecordsTimestr_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2704, _size2701) = iprot.readListBegin()
          for _i2705 in range(_size2701):
            _elem2706 = iprot.readI64()
            self.records.append(_elem2706)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyRecordsTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2707 in self.records:
        oprot.writeI64(iter2707)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2709, _vtype2710, _size2708 ) = iprot.readMapBegin()
          for _i2712 in range(_size2708):
            _key2713 = iprot.readI64()
            _val2714 = []
            (_etype2718, _size2715) = iprot.readSetBegin()
            for _i2719 in range(_size2715):
              _elem2720 = TObject()
              _elem2720.read(iprot)
              _val2714.append(_elem2720)
            iprot.readSetEnd()
            self.success[_key2713] = _val2714
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter2721,viter2722 in list(self.success.items()):
        oprot.writeI64(kiter2721)
        oprot.writeSetBegin(TType.STRUCT, len(viter2722))
        for iter2723 in viter2722:
          iter2723.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysRecordsTime_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2727, _size2724) = iprot.readListBegin()
          for _i2728 in range(_size2724):
            _elem2729 = iprot.readString()
            self.keys.append(_elem2729)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2733, _size2730) = iprot.readListBegin()
          for _i2734 in range(_size2730):
            _elem2735 = iprot.readI64()
            self.records.append(_elem2735)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysRecordsTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2736 in self.keys:
        oprot.writeString(iter2736)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2737 in self.records:
        oprot.writeI64(iter2737)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2739, _vtype2740, _size2738 ) = iprot.readMapBegin()
          for _i2742 in range(_size2738):
            _key2743 = iprot.readI64()
            _val2744 = {}
            (_ktype2746, _vtype2747, _size2745 ) = iprot.readMapBegin()
            for _i2749 in range(_size2745):
              _key2750 = iprot.readString()
              _val2751 = []
              (_etype2755, _size2752) = iprot.readSetBegin()
              for _i2756 in range(_size2752):
                _elem2757 = TObject()
                _elem2757.read(iprot)
                _val2751.append(_elem2757)
              iprot.readSetEnd()
              _val2744[_key2750] = _val2751
            iprot.readMapEnd()
            self.success[_key2743] = _val2744
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2758,viter2759 in list(self.success.items()):
        oprot.writeI64(kiter2758)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2759))
        for kiter2760,viter2761 in list(viter2759.items()):
          oprot.writeString(kiter2760)
          oprot.writeSetBegin(TType.STRUCT, len(viter2761))
          for iter2762 in viter2761:
            iter2762.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysRecordsTimestr_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2766, _size2763) = iprot.readListBegin()
          for _i2767 in range(_size2763):
            _elem2768 = iprot.readString()
            self.keys.append(_elem2768)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2772, _size2769) = iprot.readListBegin()
          for _i2773 in range(_size2769):
            _elem2774 = iprot.readI64()
            self.records.append(_elem2774)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysRecordsTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2775 in self.keys:
        oprot.writeString(iter2775)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2776 in self.records:
        oprot.writeI64(iter2776)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2778, _vtype2779, _size2777 ) = iprot.readMapBegin()
          for _i2781 in range(_size2777):
            _key2782 = iprot.readI64()
            _val2783 = {}
            (_ktype2785, _vtype2786, _size2784 ) = iprot.readMapBegin()
            for _i2788 in range(_size2784):
              _key2789 = iprot.readString()
              _val2790 = []
              (_etype2794, _size2791) = iprot.readSetBegin()
              for _i2795 in range(_size2791):
                _elem2796 = TObject()
                _elem2796.read(iprot)
                _val2790.append(_elem2796)
              iprot.readSetEnd()
              _val2783[_key2789] = _val2790
            iprot.readMapEnd()
            self.success[_key2782] = _val2783
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2797,viter2798 in list(self.success.items()):
        oprot.writeI64(kiter2797)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2798))
        for kiter2799,viter2800 in list(viter2798.items()):
          oprot.writeString(kiter2799)
          oprot.writeSetBegin(TType.STRUCT, len(viter2800))
          for iter2801 in viter2800:
            iter2801.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyCcl_args:
  """
  Attributes:
   - key
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyCcl_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2803, _vtype2804, _size2802 ) = iprot.readMapBegin()
          for _i2806 in range(_size2802):
            _key2807 = iprot.readI64()
            _val2808 = []
            (_etype2812, _size2809) = iprot.readSetBegin()
            for _i2813 in range(_size2809):
              _elem2814 = TObject()
              _elem2814.read(iprot)
              _val2808.append(_elem2814)
            iprot.readSetEnd()
            self.success[_key2807] = _val2808
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter2815,viter2816 in list(self.success.items()):
        oprot.writeI64(kiter2815)
        oprot.writeSetBegin(TType.STRUCT, len(viter2816))
        for iter2817 in viter2816:
          iter2817.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyCclTime_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyCclTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2819, _vtype2820, _size2818 ) = iprot.readMapBegin()
          for _i2822 in range(_size2818):
            _key2823 = iprot.readI64()
            _val2824 = []
            (_etype2828, _size2825) = iprot.readSetBegin()
            for _i2829 in range(_size2825):
              _elem2830 = TObject()
              _elem2830.read(iprot)
              _val2824.append(_elem2830)
            iprot.readSetEnd()
            self.success[_key2823] = _val2824
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter2831,viter2832 in list(self.success.items()):
        oprot.writeI64(kiter2831)
        oprot.writeSetBegin(TType.STRUCT, len(viter2832))
        for iter2833 in viter2832:
          iter2833.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyCclTimestr_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyCclTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2835, _vtype2836, _size2834 ) = iprot.readMapBegin()
          for _i2838 in range(_size2834):
            _key2839 = iprot.readI64()
            _val2840 = []
            (_etype2844, _size2841) = iprot.readSetBegin()
            for _i2845 in range(_size2841):
              _elem2846 = TObject()
              _elem2846.read(iprot)
              _val2840.append(_elem2846)
            iprot.readSetEnd()
            self.success[_key2839] = _val2840
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter2847,viter2848 in list(self.success.items()):
        oprot.writeI64(kiter2847)
        oprot.writeSetBegin(TType.STRUCT, len(viter2848))
        for iter2849 in viter2848:
          iter2849.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysCcl_args:
  """
  Attributes:
   - keys
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2853, _size2850) = iprot.readListBegin()
          for _i2854 in range(_size2850):
            _elem2855 = iprot.readString()
            self.keys.append(_elem2855)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysCcl_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2856 in self.keys:
        oprot.writeString(iter2856)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2858, _vtype2859, _size2857 ) = iprot.readMapBegin()
          for _i2861 in range(_size2857):
            _key2862 = iprot.readI64()
            _val2863 = {}
            (_ktype2865, _vtype2866, _size2864 ) = iprot.readMapBegin()
            for _i2868 in range(_size2864):
              _key2869 = iprot.readString()
              _val2870 = []
              (_etype2874, _size2871) = iprot.readSetBegin()
              for _i2875 in range(_size2871):
                _elem2876 = TObject()
                _elem2876.read(iprot)
                _val2870.append(_elem2876)
              iprot.readSetEnd()
              _val2863[_key2869] = _val2870
            iprot.readMapEnd()
            self.success[_key2862] = _val2863
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2877,viter2878 in list(self.success.items()):
        oprot.writeI64(kiter2877)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2878))
        for kiter2879,viter2880 in list(viter2878.items()):
          oprot.writeString(kiter2879)
          oprot.writeSetBegin(TType.STRUCT, len(viter2880))
          for iter2881 in viter2880:
            iter2881.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysCclTime_args:
  """
  Attributes:
   - keys
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2885, _size2882) = iprot.readListBegin()
          for _i2886 in range(_size2882):
            _elem2887 = iprot.readString()
            self.keys.append(_elem2887)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysCclTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2888 in self.keys:
        oprot.writeString(iter2888)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2890, _vtype2891, _size2889 ) = iprot.readMapBegin()
          for _i2893 in range(_size2889):
            _key2894 = iprot.readI64()
            _val2895 = {}
            (_ktype2897, _vtype2898, _size2896 ) = iprot.readMapBegin()
            for _i2900 in range(_size2896):
              _key2901 = iprot.readString()
              _val2902 = []
              (_etype2906, _size2903) = iprot.readSetBegin()
              for _i2907 in range(_size2903):
                _elem2908 = TObject()
                _elem2908.read(iprot)
                _val2902.append(_elem2908)
              iprot.readSetEnd()
              _val2895[_key2901] = _val2902
            iprot.readMapEnd()
            self.success[_key2894] = _val2895
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2909,viter2910 in list(self.success.items()):
        oprot.writeI64(kiter2909)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2910))
        for kiter2911,viter2912 in list(viter2910.items()):
          oprot.writeString(kiter2911)
          oprot.writeSetBegin(TType.STRUCT, len(viter2912))
          for iter2913 in viter2912:
            iter2913.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysCclTimestr_args:
  """
  Attributes:
   - keys
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2917, _size2914) = iprot.readListBegin()
          for _i2918 in range(_size2914):
            _elem2919 = iprot.readString()
            self.keys.append(_elem2919)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysCclTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2920 in self.keys:
        oprot.writeString(iter2920)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2922, _vtype2923, _size2921 ) = iprot.readMapBegin()
          for _i2925 in range(_size2921):
            _key2926 = iprot.readI64()
            _val2927 = {}
            (_ktype2929, _vtype2930, _size2928 ) = iprot.readMapBegin()
            for _i2932 in range(_size2928):
              _key2933 = iprot.readString()
              _val2934 = []
              (_etype2938, _size2935) = iprot.readSetBegin()
              for _i2939 in range(_size2935):
                _elem2940 = TObject()
                _elem2940.read(iprot)
                _val2934.append(_elem2940)
              iprot.readSetEnd()
              _val2927[_key2933] = _val2934
            iprot.readMapEnd()
            self.success[_key2926] = _val2927
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2941,viter2942 in list(self.success.items()):
        oprot.writeI64(kiter2941)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter2942))
        for kiter2943,viter2944 in list(viter2942.items()):
          oprot.writeString(kiter2943)
          oprot.writeSetBegin(TType.STRUCT, len(viter2944))
          for iter2945 in viter2944:
            iter2945.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyCriteria_args:
  """
  Attributes:
   - key
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyCriteria_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2947, _vtype2948, _size2946 ) = iprot.readMapBegin()
          for _i2950 in range(_size2946):
            _key2951 = iprot.readI64()
            _val2952 = []
            (_etype2956, _size2953) = iprot.readSetBegin()
            for _i2957 in range(_size2953):
              _elem2958 = TObject()
              _elem2958.read(iprot)
              _val2952.append(_elem2958)
            iprot.readSetEnd()
            self.success[_key2951] = _val2952
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter2959,viter2960 in list(self.success.items()):
        oprot.writeI64(kiter2959)
        oprot.writeSetBegin(TType.STRUCT, len(viter2960))
        for iter2961 in viter2960:
          iter2961.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyCriteriaTime_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyCriteriaTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2963, _vtype2964, _size2962 ) = iprot.readMapBegin()
          for _i2966 in range(_size2962):
            _key2967 = iprot.readI64()
            _val2968 = []
            (_etype2972, _size2969) = iprot.readSetBegin()
            for _i2973 in range(_size2969):
              _elem2974 = TObject()
              _elem2974.read(iprot)
              _val2968.append(_elem2974)
            iprot.readSetEnd()
            self.success[_key2967] = _val2968
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter2975,viter2976 in list(self.success.items()):
        oprot.writeI64(kiter2975)
        oprot.writeSetBegin(TType.STRUCT, len(viter2976))
        for iter2977 in viter2976:
          iter2977.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyCriteriaTimestr_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyCriteriaTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeyCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2979, _vtype2980, _size2978 ) = iprot.readMapBegin()
          for _i2982 in range(_size2978):
            _key2983 = iprot.readI64()
            _val2984 = []
            (_etype2988, _size2985) = iprot.readSetBegin()
            for _i2989 in range(_size2985):
              _elem2990 = TObject()
              _elem2990.read(iprot)
              _val2984.append(_elem2990)
            iprot.readSetEnd()
            self.success[_key2983] = _val2984
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeyCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter2991,viter2992 in list(self.success.items()):
        oprot.writeI64(kiter2991)
        oprot.writeSetBegin(TType.STRUCT, len(viter2992))
        for iter2993 in viter2992:
          iter2993.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysCriteria_args:
  """
  Attributes:
   - keys
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2997, _size2994) = iprot.readListBegin()
          for _i2998 in range(_size2994):
            _elem2999 = iprot.readString()
            self.keys.append(_elem2999)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysCriteria_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter3000 in self.keys:
        oprot.writeString(iter3000)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype3002, _vtype3003, _size3001 ) = iprot.readMapBegin()
          for _i3005 in range(_size3001):
            _key3006 = iprot.readI64()
            _val3007 = {}
            (_ktype3009, _vtype3010, _size3008 ) = iprot.readMapBegin()
            for _i3012 in range(_size3008):
              _key3013 = iprot.readString()
              _val3014 = []
              (_etype3018, _size3015) = iprot.readSetBegin()
              for _i3019 in range(_size3015):
                _elem3020 = TObject()
                _elem3020.read(iprot)
                _val3014.append(_elem3020)
              iprot.readSetEnd()
              _val3007[_key3013] = _val3014
            iprot.readMapEnd()
            self.success[_key3006] = _val3007
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter3021,viter3022 in list(self.success.items()):
        oprot.writeI64(kiter3021)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter3022))
        for kiter3023,viter3024 in list(viter3022.items()):
          oprot.writeString(kiter3023)
          oprot.writeSetBegin(TType.STRUCT, len(viter3024))
          for iter3025 in viter3024:
            iter3025.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysCriteriaTime_args:
  """
  Attributes:
   - keys
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype3029, _size3026) = iprot.readListBegin()
          for _i3030 in range(_size3026):
            _elem3031 = iprot.readString()
            self.keys.append(_elem3031)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysCriteriaTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter3032 in self.keys:
        oprot.writeString(iter3032)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype3034, _vtype3035, _size3033 ) = iprot.readMapBegin()
          for _i3037 in range(_size3033):
            _key3038 = iprot.readI64()
            _val3039 = {}
            (_ktype3041, _vtype3042, _size3040 ) = iprot.readMapBegin()
            for _i3044 in range(_size3040):
              _key3045 = iprot.readString()
              _val3046 = []
              (_etype3050, _size3047) = iprot.readSetBegin()
              for _i3051 in range(_size3047):
                _elem3052 = TObject()
                _elem3052.read(iprot)
                _val3046.append(_elem3052)
              iprot.readSetEnd()
              _val3039[_key3045] = _val3046
            iprot.readMapEnd()
            self.success[_key3038] = _val3039
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter3053,viter3054 in list(self.success.items()):
        oprot.writeI64(kiter3053)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter3054))
        for kiter3055,viter3056 in list(viter3054.items()):
          oprot.writeString(kiter3055)
          oprot.writeSetBegin(TType.STRUCT, len(viter3056))
          for iter3057 in viter3056:
            iter3057.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysCriteriaTimestr_args:
  """
  Attributes:
   - keys
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype3061, _size3058) = iprot.readListBegin()
          for _i3062 in range(_size3058):
            _elem3063 = iprot.readString()
            self.keys.append(_elem3063)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysCriteriaTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter3064 in self.keys:
        oprot.writeString(iter3064)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class navigateKeysCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype3066, _vtype3067, _size3065 ) = iprot.readMapBegin()
          for _i3069 in range(_size3065):
            _key3070 = iprot.readI64()
            _val3071 = {}
            (_ktype3073, _vtype3074, _size3072 ) = iprot.readMapBegin()
            for _i3076 in range(_size3072):
              _key3077 = iprot.readString()
              _val3078 = []
              (_etype3082, _size3079) = iprot.readSetBegin()
              for _i3083 in range(_size3079):
                _elem3084 = TObject()
                _elem3084.read(iprot)
                _val3078.append(_elem3084)
              iprot.readSetEnd()
              _val3071[_key3077] = _val3078
            iprot.readMapEnd()
            self.success[_key3070] = _val3071
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('navigateKeysCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter3085,viter3086 in list(self.success.items()):
        oprot.writeI64(kiter3085)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter3086))
        for kiter3087,viter3088 in list(viter3086.items()):
          oprot.writeString(kiter3087)
          oprot.writeSetBegin(TType.STRUCT, len(viter3088))
          for iter3089 in viter3088:
            iter3089.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServerEnvironment_args:
  """
  Attributes:
   - creds
   - token
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'token', (TransactionToken, TransactionToken.thrift_spec), None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, creds=None, token=None, environment=None,):
    self.creds = creds
    self.token = token
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.token = TransactionToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServerEnvironment_args')
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 1)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 2)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServerEnvironment_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServerEnvironment_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServerVersion_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServerVersion_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServerVersion_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServerVersion_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time_args:
  """
  Attributes:
   - creds
   - token
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'token', (TransactionToken, TransactionToken.thrift_spec), None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, creds=None, token=None, environment=None,):
    self.creds = creds
    self.token = token
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.token = TransactionToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time_args')
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 1)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 2)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timePhrase_args:
  """
  Attributes:
   - phrase
   - creds
   - token
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'phrase', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'token', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, phrase=None, creds=None, token=None, environment=None,):
    self.phrase = phrase
    self.creds = creds
    self.token = token
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.phrase = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.token = TransactionToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timePhrase_args')
    if self.phrase is not None:
      oprot.writeFieldBegin('phrase', TType.STRING, 1)
      oprot.writeString(self.phrase)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 3)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.phrase)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timePhrase_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timePhrase_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
