#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import logging
from .data.ttypes import *
from .shared.ttypes import *
from .exceptions.ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  """
  The interface definition for the Concourse Server API.
  """
  def abort(self, creds, transaction, environment):
    """
    Abort the current transaction and discard any changes that are
    currently staged.
    <p>
    After returning, the driver will return to {@code autocommit} mode and
    all subsequent changes will be committed immediately.
    </p>
    <p>
    Calling this method when the driver is not in {@code staging} mode is a
    no-op.
    </p>
    @param record the id of the record in which an attempt is made to add
                    the data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @throws exceptions.SecurityException if the {@code creds} don't represent a
            valid session

    Parameters:
     - creds
     - transaction
     - environment
    """
    pass

  def addKeyValue(self, key, value, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in a new record.

    @param key the field name
    @param value the value to add
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the new record id
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    pass

  def addKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in {@code record}.

    @param key the field name
    @param value the value to add
    @param record the record id where an attempt is made to add the data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a bool that indicates if the data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def addKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in each of the {@code records} where it
    doesn't exist.

    @param key the field name
    @param value the value to add
    @param records a list of record ids where an attempt is made to add the
                     data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a mapping from each record id to a boolean that indicates if the
                      data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def auditRecord(self, record, creds, transaction, environment):
    """
    List all the changes ever made to {@code record}.

    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def auditRecordStart(self, record, start, creds, transaction, environment):
    """
    List all the changes made to {@code record} since {@code start}
    (inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def auditRecordStartstr(self, record, start, creds, transaction, environment):
    """
    List all the changes made to {@code record} since {@code start}
    (inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def auditRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to {@code record} between {@code start}
    (inclusive) and {@code end} (non-inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def auditRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to {@code record} between {@code start}
    (inclusive) and {@code end} (non-inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def auditKeyRecord(self, key, record, creds, transaction, environment):
    """
    List all the changes ever made to the {@code key} field in {@code record}.

    @param key the field name
    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def auditKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record} since
    {@code start} (inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def auditKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record} since
    {@code start} (inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def auditKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record}
    between {@code start} (inclusive) and {@code end} (non-inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent change that
                 should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def auditKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record}
    between {@code start} (inclusive) and {@code end} (non-inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def browseKey(self, key, creds, transaction, environment):
    """
    View the values from all records that are currently stored for {@code key}.

    @param keys the field name
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contain that value in the {@code key} field
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - creds
     - transaction
     - environment
    """
    pass

  def browseKeys(self, keys, creds, transaction, environment):
    """
    View the values from all records that are currently stored for each of the
    {@code keys}.

    @param keys a list of field names
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the set of records that contain that value in the
            {@code key} field
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - keys
     - creds
     - transaction
     - environment
    """
    pass

  def browseKeyTime(self, key, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for {@code key} at
    {@code timestamp}.

    @param keys the field name
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contained that value in the {@code key} field at {@code
            timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def browseKeyTimestr(self, key, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for {@code key} at
    {@code timestamp}.

    @param keys the field name
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contained that value in the {@code key} field at {@code
            timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def browseKeysTime(self, keys, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for each of the
    {@code keys} at {@code timestamp}.

    @param keys a list of field names
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the {@link Set} of records that contained that value
            in the {@code key} field at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - keys
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def browseKeysTimestr(self, keys, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for each of the
    {@code keys} at {@code timestamp}.

    @param keys a list of field names
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the {@link Set} of records that contained that value
            in the {@code key} field at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - keys
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def chronologizeKeyRecord(self, key, record, creds, transaction, environment):
    """
    View a time series that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def chronologizeKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and the present that
    associates the timestamp of each modification for {@code key} in
    {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def chronologizeKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and the present that
    associates the timestamp of each modification for {@code key} in
    {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def chronologizeKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and {@code end}
    (non-inclusive) that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param end the {@link Timestamp} that should be greater than every
               timestamp in the time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def chronologizeKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and {@code end}
    (non-inclusive) that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param end the {@link Timestamp} that should be greater than every
               timestamp in the time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def clearRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def clearRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def clearKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def clearKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def clearKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def clearKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def commit(self, creds, transaction, environment):
    """
    Attempt to permanently commit any changes that are staged in a transaction
    and return {@code true} if and only if all the changes can be applied.
    Otherwise, returns {@code false} and all the changes are discarded.
    <p>
    After returning, the driver will return to {@code autocommit} mode and
    all subsequent changes will be committed immediately.
    </p>
    <p>
    This method will return {@code false} if it is called when the driver is
    not in {@code staging} mode.
    </p>

    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return {@code true} if all staged changes are committed, otherwise {@code
                         false}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecord(self, record, creds, transaction, environment):
    """
    List all the keys in {@code record} that have at least one value.

    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys in {@code record}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecordTime(self, record, timestamp, creds, transaction, environment):
    """
    List all the keys in {@code record} that had at least one value at
    {@code timestamp}.

    @param record the record id
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys that were in {@code record} at
            {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecordTimestr(self, record, timestamp, creds, transaction, environment):
    """
    List all the keys in {@code record} that have at least one value.

    @param record the record id
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys that were in {@code record} at
            {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecords(self, records, creds, transaction, environment):
    """
    For each of the {@code records}, list all of the keys that have at least
    one value.

    @param records a collection of record ids
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys in that record
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecordsTime(self, records, timestamp, creds, transaction, environment):
    """
    For each of the {@code records}, list all the keys that had at least one
    value at {@code timestamp}.

    @param records a collection of record ids
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys that were in that record at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    """
    For each of the {@code records}, list all the keys that had at least one
    value at {@code timestamp}.

    @param records a collection of record ids
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys that were in that record at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def diffRecordStart(self, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code record} since {@code start}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at the present.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffRecordStartstr(self, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code record} since {@code start}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at the present.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code record} from {@code start} to
    {@code end}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at {@code end}.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def diffRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code record} from {@code start} to
    {@code end}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at {@code end}.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} since
    {@code start}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    the present.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} since
    {@code start}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    the present.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} from
    {@code start} to {@code end}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    {@code end}.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} from
    {@code start} to {@code end}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    {@code end}.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyStart(self, key, start, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    since {@code start}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at the present.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyStartstr(self, key, start, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    since {@code start}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at the present.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyStartEnd(self, key, start, tend, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    from {@code start} to {@code end}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at {@code end}.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyStartstrEndstr(self, key, start, tend, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    from {@code start} to {@code end}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at {@code end}.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def login(self, username, password, environment):
    """
    Attempt to authenticate the user identified by the {@code username} and
    {@code password} combination to the specified {@code environment}. If
    successful, establish a new session within the {@code environment} on
    behalf of that user and return an {@link shared.AccessToken}, which is
    required for all subsequent operations.

    <p>
    The AccessToken <em>may</em> expire after a while so clients should be
    prepared to seamlessly login again for active user sessions.
    </p>

    @param username a binary representation of the UTF-8 encoded username
    @param password a binary representation of the UTF-8 encoded password
    @param environment the name of the environment into which to login
    @return an {@link shared.AccessToken} to submit with all subsequent method
            calls
    @throws exceptions.SecurityException if the login is not successful

    Parameters:
     - username
     - password
     - environment
    """
    pass

  def logout(self, token, environment):
    """
    Terminate the session within {@code environment} for the user represented
    by the {@code token}. Afterwards, all other attempts to use {@code token}
    will result in a {@link exceptions.SecurityException} being thrown.

    @param token the {@link shared.AccessToken to expire}
    @param environment the environment of the session represented by the
                       {@code token}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session

    Parameters:
     - token
     - environment
    """
    pass

  def stage(self, token, environment):
    """
    Start a new transaction.
    <p>
    This method will turn on STAGING mode so that all subsequent changes are
    collected in an isolated buffer before possibly being committed to the
    database. Staged operations are guaranteed to be reliable, all or nothing
    units of work that allow correct recovery from failures and provide
    isolation between clients so the database is always in a consistent state.
    </p>
    <p>
    After this method returns, all subsequent operations will be done in
    {@code staging} mode until either #abort(shared.AccessToken) or
    #commit(shared.AccessToken) is called.
    </p>

    @param token
    @param environment
    @return TransactionToken
    @throws TSecurityException

    Parameters:
     - token
     - environment
    """
    pass

  def insertJson(self, json, creds, transaction, environment):
    """
    Parameters:
     - json
     - creds
     - transaction
     - environment
    """
    pass

  def insertJsonRecord(self, json, record, creds, transaction, environment):
    """
    Parameters:
     - json
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def insertJsonRecords(self, json, records, creds, transaction, environment):
    """
    Parameters:
     - json
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def removeKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def removeKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def setKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def setKeyValue(self, key, value, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    pass

  def setKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def reconcileKeyRecordValues(self, key, record, values, creds, transaction, environment):
    """
    The {@code value} in {@code key} of {@code record} are added
    and removed to be set as exactly the same as the input values

    @param key the field name
    @param record the record id where an attempt is made to add the data
    @param values collection of values to set
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a bool that indicates if the data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - record
     - values
     - creds
     - transaction
     - environment
    """
    pass

  def inventory(self, creds, transaction, environment):
    """
    Parameters:
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecordTime(self, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecordTimestr(self, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecordsTime(self, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def selectCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def selectCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectCclTime(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCriteria(self, keys, criteria, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCcl(self, keys, ccl, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def getCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def getCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def getCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getCclTime(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCriteria(self, keys, criteria, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCcl(self, keys, ccl, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def verifyKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def verifyKeyValueRecordTime(self, key, value, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def verifyKeyValueRecordTimestr(self, key, value, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def jsonifyRecords(self, records, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - identifier
     - creds
     - transaction
     - environment
    """
    pass

  def jsonifyRecordsTime(self, records, timestamp, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - identifier
     - creds
     - transaction
     - environment
    """
    pass

  def jsonifyRecordsTimestr(self, records, timestamp, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - identifier
     - creds
     - transaction
     - environment
    """
    pass

  def findCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def findCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorValues(self, key, operator, values, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorstrValues(self, key, operator, values, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorstrValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorstrValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def search(self, key, query, creds, transaction, environment):
    """
    Parameters:
     - key
     - query
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def pingRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def pingRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def verifyAndSwap(self, key, expected, record, replacement, creds, transaction, environment):
    """
    Parameters:
     - key
     - expected
     - record
     - replacement
     - creds
     - transaction
     - environment
    """
    pass

  def verifyOrSet(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def findOrAddKeyValue(self, key, value, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    pass

  def findOrInsertCriteriaJson(self, criteria, json, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - json
     - creds
     - transaction
     - environment
    """
    pass

  def findOrInsertCclJson(self, ccl, json, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - json
     - creds
     - transaction
     - environment
    """
    pass

  def getServerEnvironment(self, creds, token, environment):
    """
    Parameters:
     - creds
     - token
     - environment
    """
    pass

  def getServerVersion(self):
    pass

  def time(self, creds, token, environment):
    """
    Parameters:
     - creds
     - token
     - environment
    """
    pass

  def timePhrase(self, phrase, creds, token, environment):
    """
    Parameters:
     - phrase
     - creds
     - token
     - environment
    """
    pass


class Client(Iface):
  """
  The interface definition for the Concourse Server API.
  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def abort(self, creds, transaction, environment):
    """
    Abort the current transaction and discard any changes that are
    currently staged.
    <p>
    After returning, the driver will return to {@code autocommit} mode and
    all subsequent changes will be committed immediately.
    </p>
    <p>
    Calling this method when the driver is not in {@code staging} mode is a
    no-op.
    </p>
    @param record the id of the record in which an attempt is made to add
                    the data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @throws exceptions.SecurityException if the {@code creds} don't represent a
            valid session

    Parameters:
     - creds
     - transaction
     - environment
    """
    self.send_abort(creds, transaction, environment)
    self.recv_abort()

  def send_abort(self, creds, transaction, environment):
    self._oprot.writeMessageBegin('abort', TMessageType.CALL, self._seqid)
    args = abort_args()
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_abort(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = abort_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    return

  def addKeyValue(self, key, value, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in a new record.

    @param key the field name
    @param value the value to add
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the new record id
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    self.send_addKeyValue(key, value, creds, transaction, environment)
    return self.recv_addKeyValue()

  def send_addKeyValue(self, key, value, creds, transaction, environment):
    self._oprot.writeMessageBegin('addKeyValue', TMessageType.CALL, self._seqid)
    args = addKeyValue_args()
    args.key = key
    args.value = value
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addKeyValue(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = addKeyValue_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addKeyValue failed: unknown result")

  def addKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in {@code record}.

    @param key the field name
    @param value the value to add
    @param record the record id where an attempt is made to add the data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a bool that indicates if the data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    self.send_addKeyValueRecord(key, value, record, creds, transaction, environment)
    return self.recv_addKeyValueRecord()

  def send_addKeyValueRecord(self, key, value, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('addKeyValueRecord', TMessageType.CALL, self._seqid)
    args = addKeyValueRecord_args()
    args.key = key
    args.value = value
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addKeyValueRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = addKeyValueRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addKeyValueRecord failed: unknown result")

  def addKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in each of the {@code records} where it
    doesn't exist.

    @param key the field name
    @param value the value to add
    @param records a list of record ids where an attempt is made to add the
                     data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a mapping from each record id to a boolean that indicates if the
                      data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    self.send_addKeyValueRecords(key, value, records, creds, transaction, environment)
    return self.recv_addKeyValueRecords()

  def send_addKeyValueRecords(self, key, value, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('addKeyValueRecords', TMessageType.CALL, self._seqid)
    args = addKeyValueRecords_args()
    args.key = key
    args.value = value
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addKeyValueRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = addKeyValueRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addKeyValueRecords failed: unknown result")

  def auditRecord(self, record, creds, transaction, environment):
    """
    List all the changes ever made to {@code record}.

    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    self.send_auditRecord(record, creds, transaction, environment)
    return self.recv_auditRecord()

  def send_auditRecord(self, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditRecord', TMessageType.CALL, self._seqid)
    args = auditRecord_args()
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecord failed: unknown result")

  def auditRecordStart(self, record, start, creds, transaction, environment):
    """
    List all the changes made to {@code record} since {@code start}
    (inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_auditRecordStart(record, start, creds, transaction, environment)
    return self.recv_auditRecordStart()

  def send_auditRecordStart(self, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditRecordStart', TMessageType.CALL, self._seqid)
    args = auditRecordStart_args()
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditRecordStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditRecordStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecordStart failed: unknown result")

  def auditRecordStartstr(self, record, start, creds, transaction, environment):
    """
    List all the changes made to {@code record} since {@code start}
    (inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_auditRecordStartstr(record, start, creds, transaction, environment)
    return self.recv_auditRecordStartstr()

  def send_auditRecordStartstr(self, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditRecordStartstr', TMessageType.CALL, self._seqid)
    args = auditRecordStartstr_args()
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditRecordStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditRecordStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecordStartstr failed: unknown result")

  def auditRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to {@code record} between {@code start}
    (inclusive) and {@code end} (non-inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_auditRecordStartEnd(record, start, tend, creds, transaction, environment)
    return self.recv_auditRecordStartEnd()

  def send_auditRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditRecordStartEnd', TMessageType.CALL, self._seqid)
    args = auditRecordStartEnd_args()
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditRecordStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditRecordStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecordStartEnd failed: unknown result")

  def auditRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to {@code record} between {@code start}
    (inclusive) and {@code end} (non-inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_auditRecordStartstrEndstr(record, start, tend, creds, transaction, environment)
    return self.recv_auditRecordStartstrEndstr()

  def send_auditRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditRecordStartstrEndstr', TMessageType.CALL, self._seqid)
    args = auditRecordStartstrEndstr_args()
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditRecordStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditRecordStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecordStartstrEndstr failed: unknown result")

  def auditKeyRecord(self, key, record, creds, transaction, environment):
    """
    List all the changes ever made to the {@code key} field in {@code record}.

    @param key the field name
    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_auditKeyRecord(key, record, creds, transaction, environment)
    return self.recv_auditKeyRecord()

  def send_auditKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditKeyRecord', TMessageType.CALL, self._seqid)
    args = auditKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecord failed: unknown result")

  def auditKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record} since
    {@code start} (inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_auditKeyRecordStart(key, record, start, creds, transaction, environment)
    return self.recv_auditKeyRecordStart()

  def send_auditKeyRecordStart(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditKeyRecordStart', TMessageType.CALL, self._seqid)
    args = auditKeyRecordStart_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditKeyRecordStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditKeyRecordStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecordStart failed: unknown result")

  def auditKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record} since
    {@code start} (inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_auditKeyRecordStartstr(key, record, start, creds, transaction, environment)
    return self.recv_auditKeyRecordStartstr()

  def send_auditKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditKeyRecordStartstr', TMessageType.CALL, self._seqid)
    args = auditKeyRecordStartstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditKeyRecordStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditKeyRecordStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecordStartstr failed: unknown result")

  def auditKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record}
    between {@code start} (inclusive) and {@code end} (non-inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent change that
                 should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_auditKeyRecordStartEnd(key, record, start, tend, creds, transaction, environment)
    return self.recv_auditKeyRecordStartEnd()

  def send_auditKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditKeyRecordStartEnd', TMessageType.CALL, self._seqid)
    args = auditKeyRecordStartEnd_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditKeyRecordStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditKeyRecordStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecordStartEnd failed: unknown result")

  def auditKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record}
    between {@code start} (inclusive) and {@code end} (non-inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_auditKeyRecordStartstrEndstr(key, record, start, tend, creds, transaction, environment)
    return self.recv_auditKeyRecordStartstrEndstr()

  def send_auditKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditKeyRecordStartstrEndstr', TMessageType.CALL, self._seqid)
    args = auditKeyRecordStartstrEndstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditKeyRecordStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditKeyRecordStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecordStartstrEndstr failed: unknown result")

  def browseKey(self, key, creds, transaction, environment):
    """
    View the values from all records that are currently stored for {@code key}.

    @param keys the field name
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contain that value in the {@code key} field
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - creds
     - transaction
     - environment
    """
    self.send_browseKey(key, creds, transaction, environment)
    return self.recv_browseKey()

  def send_browseKey(self, key, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKey', TMessageType.CALL, self._seqid)
    args = browseKey_args()
    args.key = key
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKey(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKey_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKey failed: unknown result")

  def browseKeys(self, keys, creds, transaction, environment):
    """
    View the values from all records that are currently stored for each of the
    {@code keys}.

    @param keys a list of field names
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the set of records that contain that value in the
            {@code key} field
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - keys
     - creds
     - transaction
     - environment
    """
    self.send_browseKeys(keys, creds, transaction, environment)
    return self.recv_browseKeys()

  def send_browseKeys(self, keys, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKeys', TMessageType.CALL, self._seqid)
    args = browseKeys_args()
    args.keys = keys
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKeys(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKeys_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeys failed: unknown result")

  def browseKeyTime(self, key, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for {@code key} at
    {@code timestamp}.

    @param keys the field name
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contained that value in the {@code key} field at {@code
            timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_browseKeyTime(key, timestamp, creds, transaction, environment)
    return self.recv_browseKeyTime()

  def send_browseKeyTime(self, key, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKeyTime', TMessageType.CALL, self._seqid)
    args = browseKeyTime_args()
    args.key = key
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKeyTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKeyTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeyTime failed: unknown result")

  def browseKeyTimestr(self, key, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for {@code key} at
    {@code timestamp}.

    @param keys the field name
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contained that value in the {@code key} field at {@code
            timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_browseKeyTimestr(key, timestamp, creds, transaction, environment)
    return self.recv_browseKeyTimestr()

  def send_browseKeyTimestr(self, key, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKeyTimestr', TMessageType.CALL, self._seqid)
    args = browseKeyTimestr_args()
    args.key = key
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKeyTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKeyTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeyTimestr failed: unknown result")

  def browseKeysTime(self, keys, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for each of the
    {@code keys} at {@code timestamp}.

    @param keys a list of field names
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the {@link Set} of records that contained that value
            in the {@code key} field at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - keys
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_browseKeysTime(keys, timestamp, creds, transaction, environment)
    return self.recv_browseKeysTime()

  def send_browseKeysTime(self, keys, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKeysTime', TMessageType.CALL, self._seqid)
    args = browseKeysTime_args()
    args.keys = keys
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKeysTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKeysTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeysTime failed: unknown result")

  def browseKeysTimestr(self, keys, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for each of the
    {@code keys} at {@code timestamp}.

    @param keys a list of field names
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the {@link Set} of records that contained that value
            in the {@code key} field at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - keys
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_browseKeysTimestr(keys, timestamp, creds, transaction, environment)
    return self.recv_browseKeysTimestr()

  def send_browseKeysTimestr(self, keys, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKeysTimestr', TMessageType.CALL, self._seqid)
    args = browseKeysTimestr_args()
    args.keys = keys
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKeysTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKeysTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeysTimestr failed: unknown result")

  def chronologizeKeyRecord(self, key, record, creds, transaction, environment):
    """
    View a time series that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_chronologizeKeyRecord(key, record, creds, transaction, environment)
    return self.recv_chronologizeKeyRecord()

  def send_chronologizeKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('chronologizeKeyRecord', TMessageType.CALL, self._seqid)
    args = chronologizeKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chronologizeKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = chronologizeKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecord failed: unknown result")

  def chronologizeKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and the present that
    associates the timestamp of each modification for {@code key} in
    {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_chronologizeKeyRecordStart(key, record, start, creds, transaction, environment)
    return self.recv_chronologizeKeyRecordStart()

  def send_chronologizeKeyRecordStart(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('chronologizeKeyRecordStart', TMessageType.CALL, self._seqid)
    args = chronologizeKeyRecordStart_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chronologizeKeyRecordStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = chronologizeKeyRecordStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecordStart failed: unknown result")

  def chronologizeKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and the present that
    associates the timestamp of each modification for {@code key} in
    {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_chronologizeKeyRecordStartstr(key, record, start, creds, transaction, environment)
    return self.recv_chronologizeKeyRecordStartstr()

  def send_chronologizeKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('chronologizeKeyRecordStartstr', TMessageType.CALL, self._seqid)
    args = chronologizeKeyRecordStartstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chronologizeKeyRecordStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = chronologizeKeyRecordStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecordStartstr failed: unknown result")

  def chronologizeKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and {@code end}
    (non-inclusive) that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param end the {@link Timestamp} that should be greater than every
               timestamp in the time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_chronologizeKeyRecordStartEnd(key, record, start, tend, creds, transaction, environment)
    return self.recv_chronologizeKeyRecordStartEnd()

  def send_chronologizeKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('chronologizeKeyRecordStartEnd', TMessageType.CALL, self._seqid)
    args = chronologizeKeyRecordStartEnd_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chronologizeKeyRecordStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = chronologizeKeyRecordStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecordStartEnd failed: unknown result")

  def chronologizeKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and {@code end}
    (non-inclusive) that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param end the {@link Timestamp} that should be greater than every
               timestamp in the time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_chronologizeKeyRecordStartstrEndstr(key, record, start, tend, creds, transaction, environment)
    return self.recv_chronologizeKeyRecordStartstrEndstr()

  def send_chronologizeKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('chronologizeKeyRecordStartstrEndstr', TMessageType.CALL, self._seqid)
    args = chronologizeKeyRecordStartstrEndstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chronologizeKeyRecordStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = chronologizeKeyRecordStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecordStartstrEndstr failed: unknown result")

  def clearRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    self.send_clearRecord(record, creds, transaction, environment)
    self.recv_clearRecord()

  def send_clearRecord(self, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearRecord', TMessageType.CALL, self._seqid)
    args = clearRecord_args()
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def clearRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    self.send_clearRecords(records, creds, transaction, environment)
    self.recv_clearRecords()

  def send_clearRecords(self, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearRecords', TMessageType.CALL, self._seqid)
    args = clearRecords_args()
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def clearKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_clearKeyRecord(key, record, creds, transaction, environment)
    self.recv_clearKeyRecord()

  def send_clearKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearKeyRecord', TMessageType.CALL, self._seqid)
    args = clearKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def clearKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    self.send_clearKeysRecord(keys, record, creds, transaction, environment)
    self.recv_clearKeysRecord()

  def send_clearKeysRecord(self, keys, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearKeysRecord', TMessageType.CALL, self._seqid)
    args = clearKeysRecord_args()
    args.keys = keys
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearKeysRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearKeysRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def clearKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    self.send_clearKeyRecords(key, records, creds, transaction, environment)
    self.recv_clearKeyRecords()

  def send_clearKeyRecords(self, key, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearKeyRecords', TMessageType.CALL, self._seqid)
    args = clearKeyRecords_args()
    args.key = key
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearKeyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearKeyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def clearKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    self.send_clearKeysRecords(keys, records, creds, transaction, environment)
    self.recv_clearKeysRecords()

  def send_clearKeysRecords(self, keys, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearKeysRecords', TMessageType.CALL, self._seqid)
    args = clearKeysRecords_args()
    args.keys = keys
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearKeysRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearKeysRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def commit(self, creds, transaction, environment):
    """
    Attempt to permanently commit any changes that are staged in a transaction
    and return {@code true} if and only if all the changes can be applied.
    Otherwise, returns {@code false} and all the changes are discarded.
    <p>
    After returning, the driver will return to {@code autocommit} mode and
    all subsequent changes will be committed immediately.
    </p>
    <p>
    This method will return {@code false} if it is called when the driver is
    not in {@code staging} mode.
    </p>

    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return {@code true} if all staged changes are committed, otherwise {@code
                         false}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - creds
     - transaction
     - environment
    """
    self.send_commit(creds, transaction, environment)
    return self.recv_commit()

  def send_commit(self, creds, transaction, environment):
    self._oprot.writeMessageBegin('commit', TMessageType.CALL, self._seqid)
    args = commit_args()
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_commit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = commit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "commit failed: unknown result")

  def describeRecord(self, record, creds, transaction, environment):
    """
    List all the keys in {@code record} that have at least one value.

    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys in {@code record}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    self.send_describeRecord(record, creds, transaction, environment)
    return self.recv_describeRecord()

  def send_describeRecord(self, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecord', TMessageType.CALL, self._seqid)
    args = describeRecord_args()
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecord failed: unknown result")

  def describeRecordTime(self, record, timestamp, creds, transaction, environment):
    """
    List all the keys in {@code record} that had at least one value at
    {@code timestamp}.

    @param record the record id
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys that were in {@code record} at
            {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_describeRecordTime(record, timestamp, creds, transaction, environment)
    return self.recv_describeRecordTime()

  def send_describeRecordTime(self, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecordTime', TMessageType.CALL, self._seqid)
    args = describeRecordTime_args()
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecordTime failed: unknown result")

  def describeRecordTimestr(self, record, timestamp, creds, transaction, environment):
    """
    List all the keys in {@code record} that have at least one value.

    @param record the record id
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys that were in {@code record} at
            {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_describeRecordTimestr(record, timestamp, creds, transaction, environment)
    return self.recv_describeRecordTimestr()

  def send_describeRecordTimestr(self, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecordTimestr', TMessageType.CALL, self._seqid)
    args = describeRecordTimestr_args()
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecordTimestr failed: unknown result")

  def describeRecords(self, records, creds, transaction, environment):
    """
    For each of the {@code records}, list all of the keys that have at least
    one value.

    @param records a collection of record ids
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys in that record
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    self.send_describeRecords(records, creds, transaction, environment)
    return self.recv_describeRecords()

  def send_describeRecords(self, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecords', TMessageType.CALL, self._seqid)
    args = describeRecords_args()
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecords failed: unknown result")

  def describeRecordsTime(self, records, timestamp, creds, transaction, environment):
    """
    For each of the {@code records}, list all the keys that had at least one
    value at {@code timestamp}.

    @param records a collection of record ids
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys that were in that record at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_describeRecordsTime(records, timestamp, creds, transaction, environment)
    return self.recv_describeRecordsTime()

  def send_describeRecordsTime(self, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecordsTime', TMessageType.CALL, self._seqid)
    args = describeRecordsTime_args()
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecordsTime failed: unknown result")

  def describeRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    """
    For each of the {@code records}, list all the keys that had at least one
    value at {@code timestamp}.

    @param records a collection of record ids
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys that were in that record at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_describeRecordsTimestr(records, timestamp, creds, transaction, environment)
    return self.recv_describeRecordsTimestr()

  def send_describeRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecordsTimestr', TMessageType.CALL, self._seqid)
    args = describeRecordsTimestr_args()
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecordsTimestr failed: unknown result")

  def diffRecordStart(self, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code record} since {@code start}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at the present.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffRecordStart(record, start, creds, transaction, environment)
    return self.recv_diffRecordStart()

  def send_diffRecordStart(self, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffRecordStart', TMessageType.CALL, self._seqid)
    args = diffRecordStart_args()
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffRecordStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffRecordStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffRecordStart failed: unknown result")

  def diffRecordStartstr(self, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code record} since {@code start}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at the present.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffRecordStartstr(record, start, creds, transaction, environment)
    return self.recv_diffRecordStartstr()

  def send_diffRecordStartstr(self, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffRecordStartstr', TMessageType.CALL, self._seqid)
    args = diffRecordStartstr_args()
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffRecordStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffRecordStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffRecordStartstr failed: unknown result")

  def diffRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code record} from {@code start} to
    {@code end}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at {@code end}.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffRecordStartEnd(record, start, tend, creds, transaction, environment)
    return self.recv_diffRecordStartEnd()

  def send_diffRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffRecordStartEnd', TMessageType.CALL, self._seqid)
    args = diffRecordStartEnd_args()
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffRecordStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffRecordStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffRecordStartEnd failed: unknown result")

  def diffRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code record} from {@code start} to
    {@code end}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at {@code end}.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffRecordStartstrEndstr(record, start, tend, creds, transaction, environment)
    return self.recv_diffRecordStartstrEndstr()

  def send_diffRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffRecordStartstrEndstr', TMessageType.CALL, self._seqid)
    args = diffRecordStartstrEndstr_args()
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffRecordStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffRecordStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffRecordStartstrEndstr failed: unknown result")

  def diffKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} since
    {@code start}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    the present.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyRecordStart(key, record, start, creds, transaction, environment)
    return self.recv_diffKeyRecordStart()

  def send_diffKeyRecordStart(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyRecordStart', TMessageType.CALL, self._seqid)
    args = diffKeyRecordStart_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyRecordStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyRecordStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyRecordStart failed: unknown result")

  def diffKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} since
    {@code start}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    the present.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyRecordStartstr(key, record, start, creds, transaction, environment)
    return self.recv_diffKeyRecordStartstr()

  def send_diffKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyRecordStartstr', TMessageType.CALL, self._seqid)
    args = diffKeyRecordStartstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyRecordStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyRecordStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyRecordStartstr failed: unknown result")

  def diffKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} from
    {@code start} to {@code end}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    {@code end}.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyRecordStartEnd(key, record, start, tend, creds, transaction, environment)
    return self.recv_diffKeyRecordStartEnd()

  def send_diffKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyRecordStartEnd', TMessageType.CALL, self._seqid)
    args = diffKeyRecordStartEnd_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyRecordStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyRecordStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyRecordStartEnd failed: unknown result")

  def diffKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} from
    {@code start} to {@code end}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    {@code end}.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyRecordStartstrEndstr(key, record, start, tend, creds, transaction, environment)
    return self.recv_diffKeyRecordStartstrEndstr()

  def send_diffKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyRecordStartstrEndstr', TMessageType.CALL, self._seqid)
    args = diffKeyRecordStartstrEndstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyRecordStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyRecordStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyRecordStartstrEndstr failed: unknown result")

  def diffKeyStart(self, key, start, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    since {@code start}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at the present.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyStart(key, start, creds, transaction, environment)
    return self.recv_diffKeyStart()

  def send_diffKeyStart(self, key, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyStart', TMessageType.CALL, self._seqid)
    args = diffKeyStart_args()
    args.key = key
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyStart failed: unknown result")

  def diffKeyStartstr(self, key, start, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    since {@code start}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at the present.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyStartstr(key, start, creds, transaction, environment)
    return self.recv_diffKeyStartstr()

  def send_diffKeyStartstr(self, key, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyStartstr', TMessageType.CALL, self._seqid)
    args = diffKeyStartstr_args()
    args.key = key
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyStartstr failed: unknown result")

  def diffKeyStartEnd(self, key, start, tend, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    from {@code start} to {@code end}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at {@code end}.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyStartEnd(key, start, tend, creds, transaction, environment)
    return self.recv_diffKeyStartEnd()

  def send_diffKeyStartEnd(self, key, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyStartEnd', TMessageType.CALL, self._seqid)
    args = diffKeyStartEnd_args()
    args.key = key
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyStartEnd failed: unknown result")

  def diffKeyStartstrEndstr(self, key, start, tend, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    from {@code start} to {@code end}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at {@code end}.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyStartstrEndstr(key, start, tend, creds, transaction, environment)
    return self.recv_diffKeyStartstrEndstr()

  def send_diffKeyStartstrEndstr(self, key, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyStartstrEndstr', TMessageType.CALL, self._seqid)
    args = diffKeyStartstrEndstr_args()
    args.key = key
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyStartstrEndstr failed: unknown result")

  def login(self, username, password, environment):
    """
    Attempt to authenticate the user identified by the {@code username} and
    {@code password} combination to the specified {@code environment}. If
    successful, establish a new session within the {@code environment} on
    behalf of that user and return an {@link shared.AccessToken}, which is
    required for all subsequent operations.

    <p>
    The AccessToken <em>may</em> expire after a while so clients should be
    prepared to seamlessly login again for active user sessions.
    </p>

    @param username a binary representation of the UTF-8 encoded username
    @param password a binary representation of the UTF-8 encoded password
    @param environment the name of the environment into which to login
    @return an {@link shared.AccessToken} to submit with all subsequent method
            calls
    @throws exceptions.SecurityException if the login is not successful

    Parameters:
     - username
     - password
     - environment
    """
    self.send_login(username, password, environment)
    return self.recv_login()

  def send_login(self, username, password, environment):
    self._oprot.writeMessageBegin('login', TMessageType.CALL, self._seqid)
    args = login_args()
    args.username = username
    args.password = password
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_login(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = login_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "login failed: unknown result")

  def logout(self, token, environment):
    """
    Terminate the session within {@code environment} for the user represented
    by the {@code token}. Afterwards, all other attempts to use {@code token}
    will result in a {@link exceptions.SecurityException} being thrown.

    @param token the {@link shared.AccessToken to expire}
    @param environment the environment of the session represented by the
                       {@code token}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session

    Parameters:
     - token
     - environment
    """
    self.send_logout(token, environment)
    self.recv_logout()

  def send_logout(self, token, environment):
    self._oprot.writeMessageBegin('logout', TMessageType.CALL, self._seqid)
    args = logout_args()
    args.token = token
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_logout(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = logout_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    return

  def stage(self, token, environment):
    """
    Start a new transaction.
    <p>
    This method will turn on STAGING mode so that all subsequent changes are
    collected in an isolated buffer before possibly being committed to the
    database. Staged operations are guaranteed to be reliable, all or nothing
    units of work that allow correct recovery from failures and provide
    isolation between clients so the database is always in a consistent state.
    </p>
    <p>
    After this method returns, all subsequent operations will be done in
    {@code staging} mode until either #abort(shared.AccessToken) or
    #commit(shared.AccessToken) is called.
    </p>

    @param token
    @param environment
    @return TransactionToken
    @throws TSecurityException

    Parameters:
     - token
     - environment
    """
    self.send_stage(token, environment)
    return self.recv_stage()

  def send_stage(self, token, environment):
    self._oprot.writeMessageBegin('stage', TMessageType.CALL, self._seqid)
    args = stage_args()
    args.token = token
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stage(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = stage_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "stage failed: unknown result")

  def insertJson(self, json, creds, transaction, environment):
    """
    Parameters:
     - json
     - creds
     - transaction
     - environment
    """
    self.send_insertJson(json, creds, transaction, environment)
    return self.recv_insertJson()

  def send_insertJson(self, json, creds, transaction, environment):
    self._oprot.writeMessageBegin('insertJson', TMessageType.CALL, self._seqid)
    args = insertJson_args()
    args.json = json
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_insertJson(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = insertJson_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "insertJson failed: unknown result")

  def insertJsonRecord(self, json, record, creds, transaction, environment):
    """
    Parameters:
     - json
     - record
     - creds
     - transaction
     - environment
    """
    self.send_insertJsonRecord(json, record, creds, transaction, environment)
    return self.recv_insertJsonRecord()

  def send_insertJsonRecord(self, json, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('insertJsonRecord', TMessageType.CALL, self._seqid)
    args = insertJsonRecord_args()
    args.json = json
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_insertJsonRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = insertJsonRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "insertJsonRecord failed: unknown result")

  def insertJsonRecords(self, json, records, creds, transaction, environment):
    """
    Parameters:
     - json
     - records
     - creds
     - transaction
     - environment
    """
    self.send_insertJsonRecords(json, records, creds, transaction, environment)
    return self.recv_insertJsonRecords()

  def send_insertJsonRecords(self, json, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('insertJsonRecords', TMessageType.CALL, self._seqid)
    args = insertJsonRecords_args()
    args.json = json
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_insertJsonRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = insertJsonRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "insertJsonRecords failed: unknown result")

  def removeKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    self.send_removeKeyValueRecord(key, value, record, creds, transaction, environment)
    return self.recv_removeKeyValueRecord()

  def send_removeKeyValueRecord(self, key, value, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('removeKeyValueRecord', TMessageType.CALL, self._seqid)
    args = removeKeyValueRecord_args()
    args.key = key
    args.value = value
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_removeKeyValueRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = removeKeyValueRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "removeKeyValueRecord failed: unknown result")

  def removeKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    self.send_removeKeyValueRecords(key, value, records, creds, transaction, environment)
    return self.recv_removeKeyValueRecords()

  def send_removeKeyValueRecords(self, key, value, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('removeKeyValueRecords', TMessageType.CALL, self._seqid)
    args = removeKeyValueRecords_args()
    args.key = key
    args.value = value
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_removeKeyValueRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = removeKeyValueRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "removeKeyValueRecords failed: unknown result")

  def setKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    self.send_setKeyValueRecord(key, value, record, creds, transaction, environment)
    self.recv_setKeyValueRecord()

  def send_setKeyValueRecord(self, key, value, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('setKeyValueRecord', TMessageType.CALL, self._seqid)
    args = setKeyValueRecord_args()
    args.key = key
    args.value = value
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setKeyValueRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setKeyValueRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def setKeyValue(self, key, value, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    self.send_setKeyValue(key, value, creds, transaction, environment)
    return self.recv_setKeyValue()

  def send_setKeyValue(self, key, value, creds, transaction, environment):
    self._oprot.writeMessageBegin('setKeyValue', TMessageType.CALL, self._seqid)
    args = setKeyValue_args()
    args.key = key
    args.value = value
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setKeyValue(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setKeyValue_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setKeyValue failed: unknown result")

  def setKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    self.send_setKeyValueRecords(key, value, records, creds, transaction, environment)
    self.recv_setKeyValueRecords()

  def send_setKeyValueRecords(self, key, value, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('setKeyValueRecords', TMessageType.CALL, self._seqid)
    args = setKeyValueRecords_args()
    args.key = key
    args.value = value
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setKeyValueRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setKeyValueRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def reconcileKeyRecordValues(self, key, record, values, creds, transaction, environment):
    """
    The {@code value} in {@code key} of {@code record} are added
    and removed to be set as exactly the same as the input values

    @param key the field name
    @param record the record id where an attempt is made to add the data
    @param values collection of values to set
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a bool that indicates if the data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - record
     - values
     - creds
     - transaction
     - environment
    """
    self.send_reconcileKeyRecordValues(key, record, values, creds, transaction, environment)
    self.recv_reconcileKeyRecordValues()

  def send_reconcileKeyRecordValues(self, key, record, values, creds, transaction, environment):
    self._oprot.writeMessageBegin('reconcileKeyRecordValues', TMessageType.CALL, self._seqid)
    args = reconcileKeyRecordValues_args()
    args.key = key
    args.record = record
    args.values = values
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_reconcileKeyRecordValues(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = reconcileKeyRecordValues_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def inventory(self, creds, transaction, environment):
    """
    Parameters:
     - creds
     - transaction
     - environment
    """
    self.send_inventory(creds, transaction, environment)
    return self.recv_inventory()

  def send_inventory(self, creds, transaction, environment):
    self._oprot.writeMessageBegin('inventory', TMessageType.CALL, self._seqid)
    args = inventory_args()
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_inventory(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = inventory_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "inventory failed: unknown result")

  def selectRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    self.send_selectRecord(record, creds, transaction, environment)
    return self.recv_selectRecord()

  def send_selectRecord(self, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecord', TMessageType.CALL, self._seqid)
    args = selectRecord_args()
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecord failed: unknown result")

  def selectRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    self.send_selectRecords(records, creds, transaction, environment)
    return self.recv_selectRecords()

  def send_selectRecords(self, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecords', TMessageType.CALL, self._seqid)
    args = selectRecords_args()
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecords failed: unknown result")

  def selectRecordTime(self, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectRecordTime(record, timestamp, creds, transaction, environment)
    return self.recv_selectRecordTime()

  def send_selectRecordTime(self, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecordTime', TMessageType.CALL, self._seqid)
    args = selectRecordTime_args()
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecordTime failed: unknown result")

  def selectRecordTimestr(self, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectRecordTimestr(record, timestamp, creds, transaction, environment)
    return self.recv_selectRecordTimestr()

  def send_selectRecordTimestr(self, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecordTimestr', TMessageType.CALL, self._seqid)
    args = selectRecordTimestr_args()
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecordTimestr failed: unknown result")

  def selectRecordsTime(self, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectRecordsTime(records, timestamp, creds, transaction, environment)
    return self.recv_selectRecordsTime()

  def send_selectRecordsTime(self, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecordsTime', TMessageType.CALL, self._seqid)
    args = selectRecordsTime_args()
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecordsTime failed: unknown result")

  def selectRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectRecordsTimestr(records, timestamp, creds, transaction, environment)
    return self.recv_selectRecordsTimestr()

  def send_selectRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecordsTimestr', TMessageType.CALL, self._seqid)
    args = selectRecordsTimestr_args()
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecordsTimestr failed: unknown result")

  def selectKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecord(key, record, creds, transaction, environment)
    return self.recv_selectKeyRecord()

  def send_selectKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecord', TMessageType.CALL, self._seqid)
    args = selectKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecord failed: unknown result")

  def selectKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecordTime(key, record, timestamp, creds, transaction, environment)
    return self.recv_selectKeyRecordTime()

  def send_selectKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecordTime', TMessageType.CALL, self._seqid)
    args = selectKeyRecordTime_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecordTime failed: unknown result")

  def selectKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
    return self.recv_selectKeyRecordTimestr()

  def send_selectKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecordTimestr', TMessageType.CALL, self._seqid)
    args = selectKeyRecordTimestr_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecordTimestr failed: unknown result")

  def selectKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecord(keys, record, creds, transaction, environment)
    return self.recv_selectKeysRecord()

  def send_selectKeysRecord(self, keys, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecord', TMessageType.CALL, self._seqid)
    args = selectKeysRecord_args()
    args.keys = keys
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecord failed: unknown result")

  def selectKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecordTime(keys, record, timestamp, creds, transaction, environment)
    return self.recv_selectKeysRecordTime()

  def send_selectKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecordTime', TMessageType.CALL, self._seqid)
    args = selectKeysRecordTime_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecordTime failed: unknown result")

  def selectKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecordTimestr(keys, record, timestamp, creds, transaction, environment)
    return self.recv_selectKeysRecordTimestr()

  def send_selectKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecordTimestr', TMessageType.CALL, self._seqid)
    args = selectKeysRecordTimestr_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecordTimestr failed: unknown result")

  def selectKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecords(keys, records, creds, transaction, environment)
    return self.recv_selectKeysRecords()

  def send_selectKeysRecords(self, keys, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecords', TMessageType.CALL, self._seqid)
    args = selectKeysRecords_args()
    args.keys = keys
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecords failed: unknown result")

  def selectKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecords(key, records, creds, transaction, environment)
    return self.recv_selectKeyRecords()

  def send_selectKeyRecords(self, key, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecords', TMessageType.CALL, self._seqid)
    args = selectKeyRecords_args()
    args.key = key
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecords failed: unknown result")

  def selectKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
    return self.recv_selectKeyRecordsTime()

  def send_selectKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecordsTime', TMessageType.CALL, self._seqid)
    args = selectKeyRecordsTime_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecordsTime failed: unknown result")

  def selectKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
    return self.recv_selectKeyRecordsTimestr()

  def send_selectKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = selectKeyRecordsTimestr_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecordsTimestr failed: unknown result")

  def selectKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecordsTime(keys, records, timestamp, creds, transaction, environment)
    return self.recv_selectKeysRecordsTime()

  def send_selectKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecordsTime', TMessageType.CALL, self._seqid)
    args = selectKeysRecordsTime_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecordsTime failed: unknown result")

  def selectKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecordsTimestr(keys, records, timestamp, creds, transaction, environment)
    return self.recv_selectKeysRecordsTimestr()

  def send_selectKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecordsTimestr', TMessageType.CALL, self._seqid)
    args = selectKeysRecordsTimestr_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecordsTimestr failed: unknown result")

  def selectCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_selectCriteria(criteria, creds, transaction, environment)
    return self.recv_selectCriteria()

  def send_selectCriteria(self, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCriteria', TMessageType.CALL, self._seqid)
    args = selectCriteria_args()
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCriteria failed: unknown result")

  def selectCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_selectCcl(ccl, creds, transaction, environment)
    return self.recv_selectCcl()

  def send_selectCcl(self, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCcl', TMessageType.CALL, self._seqid)
    args = selectCcl_args()
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCcl failed: unknown result")

  def selectCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectCriteriaTime(criteria, timestamp, creds, transaction, environment)
    return self.recv_selectCriteriaTime()

  def send_selectCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCriteriaTime', TMessageType.CALL, self._seqid)
    args = selectCriteriaTime_args()
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCriteriaTime failed: unknown result")

  def selectCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectCriteriaTimestr(criteria, timestamp, creds, transaction, environment)
    return self.recv_selectCriteriaTimestr()

  def send_selectCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = selectCriteriaTimestr_args()
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCriteriaTimestr failed: unknown result")

  def selectCclTime(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectCclTime(ccl, timestamp, creds, transaction, environment)
    return self.recv_selectCclTime()

  def send_selectCclTime(self, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCclTime', TMessageType.CALL, self._seqid)
    args = selectCclTime_args()
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCclTime failed: unknown result")

  def selectCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectCclTimestr(ccl, timestamp, creds, transaction, environment)
    return self.recv_selectCclTimestr()

  def send_selectCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCclTimestr', TMessageType.CALL, self._seqid)
    args = selectCclTimestr_args()
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCclTimestr failed: unknown result")

  def selectKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCriteria(key, criteria, creds, transaction, environment)
    return self.recv_selectKeyCriteria()

  def send_selectKeyCriteria(self, key, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCriteria', TMessageType.CALL, self._seqid)
    args = selectKeyCriteria_args()
    args.key = key
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCriteria failed: unknown result")

  def selectKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCcl(key, ccl, creds, transaction, environment)
    return self.recv_selectKeyCcl()

  def send_selectKeyCcl(self, key, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCcl', TMessageType.CALL, self._seqid)
    args = selectKeyCcl_args()
    args.key = key
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCcl failed: unknown result")

  def selectKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_selectKeyCriteriaTime()

  def send_selectKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCriteriaTime', TMessageType.CALL, self._seqid)
    args = selectKeyCriteriaTime_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCriteriaTime failed: unknown result")

  def selectKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_selectKeyCriteriaTimestr()

  def send_selectKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = selectKeyCriteriaTimestr_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCriteriaTimestr failed: unknown result")

  def selectKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_selectKeyCclTime()

  def send_selectKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCclTime', TMessageType.CALL, self._seqid)
    args = selectKeyCclTime_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCclTime failed: unknown result")

  def selectKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_selectKeyCclTimestr()

  def send_selectKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCclTimestr', TMessageType.CALL, self._seqid)
    args = selectKeyCclTimestr_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCclTimestr failed: unknown result")

  def selectKeysCriteria(self, keys, criteria, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCriteria(keys, criteria, creds, transaction, environment)
    return self.recv_selectKeysCriteria()

  def send_selectKeysCriteria(self, keys, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCriteria', TMessageType.CALL, self._seqid)
    args = selectKeysCriteria_args()
    args.keys = keys
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCriteria failed: unknown result")

  def selectKeysCcl(self, keys, ccl, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCcl(keys, ccl, creds, transaction, environment)
    return self.recv_selectKeysCcl()

  def send_selectKeysCcl(self, keys, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCcl', TMessageType.CALL, self._seqid)
    args = selectKeysCcl_args()
    args.keys = keys
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCcl failed: unknown result")

  def selectKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCriteriaTime(keys, criteria, timestamp, creds, transaction, environment)
    return self.recv_selectKeysCriteriaTime()

  def send_selectKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCriteriaTime', TMessageType.CALL, self._seqid)
    args = selectKeysCriteriaTime_args()
    args.keys = keys
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCriteriaTime failed: unknown result")

  def selectKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCriteriaTimestr(keys, criteria, timestamp, creds, transaction, environment)
    return self.recv_selectKeysCriteriaTimestr()

  def send_selectKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = selectKeysCriteriaTimestr_args()
    args.keys = keys
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCriteriaTimestr failed: unknown result")

  def selectKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCclTime(keys, ccl, timestamp, creds, transaction, environment)
    return self.recv_selectKeysCclTime()

  def send_selectKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCclTime', TMessageType.CALL, self._seqid)
    args = selectKeysCclTime_args()
    args.keys = keys
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCclTime failed: unknown result")

  def selectKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCclTimestr(keys, ccl, timestamp, creds, transaction, environment)
    return self.recv_selectKeysCclTimestr()

  def send_selectKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCclTimestr', TMessageType.CALL, self._seqid)
    args = selectKeysCclTimestr_args()
    args.keys = keys
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCclTimestr failed: unknown result")

  def getKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecord(key, record, creds, transaction, environment)
    return self.recv_getKeyRecord()

  def send_getKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecord', TMessageType.CALL, self._seqid)
    args = getKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecord failed: unknown result")

  def getKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecordTime(key, record, timestamp, creds, transaction, environment)
    return self.recv_getKeyRecordTime()

  def send_getKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecordTime', TMessageType.CALL, self._seqid)
    args = getKeyRecordTime_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecordTime failed: unknown result")

  def getKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
    return self.recv_getKeyRecordTimestr()

  def send_getKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecordTimestr', TMessageType.CALL, self._seqid)
    args = getKeyRecordTimestr_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecordTimestr failed: unknown result")

  def getKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecord(keys, record, creds, transaction, environment)
    return self.recv_getKeysRecord()

  def send_getKeysRecord(self, keys, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecord', TMessageType.CALL, self._seqid)
    args = getKeysRecord_args()
    args.keys = keys
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecord failed: unknown result")

  def getKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecordTime(keys, record, timestamp, creds, transaction, environment)
    return self.recv_getKeysRecordTime()

  def send_getKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecordTime', TMessageType.CALL, self._seqid)
    args = getKeysRecordTime_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecordTime failed: unknown result")

  def getKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecordTimestr(keys, record, timestamp, creds, transaction, environment)
    return self.recv_getKeysRecordTimestr()

  def send_getKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecordTimestr', TMessageType.CALL, self._seqid)
    args = getKeysRecordTimestr_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecordTimestr failed: unknown result")

  def getKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecords(keys, records, creds, transaction, environment)
    return self.recv_getKeysRecords()

  def send_getKeysRecords(self, keys, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecords', TMessageType.CALL, self._seqid)
    args = getKeysRecords_args()
    args.keys = keys
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecords failed: unknown result")

  def getKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecords(key, records, creds, transaction, environment)
    return self.recv_getKeyRecords()

  def send_getKeyRecords(self, key, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecords', TMessageType.CALL, self._seqid)
    args = getKeyRecords_args()
    args.key = key
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecords failed: unknown result")

  def getKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
    return self.recv_getKeyRecordsTime()

  def send_getKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecordsTime', TMessageType.CALL, self._seqid)
    args = getKeyRecordsTime_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecordsTime failed: unknown result")

  def getKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
    return self.recv_getKeyRecordsTimestr()

  def send_getKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = getKeyRecordsTimestr_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecordsTimestr failed: unknown result")

  def getKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecordsTime(keys, records, timestamp, creds, transaction, environment)
    return self.recv_getKeysRecordsTime()

  def send_getKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecordsTime', TMessageType.CALL, self._seqid)
    args = getKeysRecordsTime_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecordsTime failed: unknown result")

  def getKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecordsTimestr(keys, records, timestamp, creds, transaction, environment)
    return self.recv_getKeysRecordsTimestr()

  def send_getKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecordsTimestr', TMessageType.CALL, self._seqid)
    args = getKeysRecordsTimestr_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecordsTimestr failed: unknown result")

  def getKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCriteria(key, criteria, creds, transaction, environment)
    return self.recv_getKeyCriteria()

  def send_getKeyCriteria(self, key, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCriteria', TMessageType.CALL, self._seqid)
    args = getKeyCriteria_args()
    args.key = key
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCriteria failed: unknown result")

  def getCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_getCriteria(criteria, creds, transaction, environment)
    return self.recv_getCriteria()

  def send_getCriteria(self, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCriteria', TMessageType.CALL, self._seqid)
    args = getCriteria_args()
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCriteria failed: unknown result")

  def getCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_getCcl(ccl, creds, transaction, environment)
    return self.recv_getCcl()

  def send_getCcl(self, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCcl', TMessageType.CALL, self._seqid)
    args = getCcl_args()
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCcl failed: unknown result")

  def getCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getCriteriaTime(criteria, timestamp, creds, transaction, environment)
    return self.recv_getCriteriaTime()

  def send_getCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCriteriaTime', TMessageType.CALL, self._seqid)
    args = getCriteriaTime_args()
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCriteriaTime failed: unknown result")

  def getCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getCriteriaTimestr(criteria, timestamp, creds, transaction, environment)
    return self.recv_getCriteriaTimestr()

  def send_getCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = getCriteriaTimestr_args()
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCriteriaTimestr failed: unknown result")

  def getCclTime(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getCclTime(ccl, timestamp, creds, transaction, environment)
    return self.recv_getCclTime()

  def send_getCclTime(self, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCclTime', TMessageType.CALL, self._seqid)
    args = getCclTime_args()
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCclTime failed: unknown result")

  def getCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getCclTimestr(ccl, timestamp, creds, transaction, environment)
    return self.recv_getCclTimestr()

  def send_getCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCclTimestr', TMessageType.CALL, self._seqid)
    args = getCclTimestr_args()
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCclTimestr failed: unknown result")

  def getKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCcl(key, ccl, creds, transaction, environment)
    return self.recv_getKeyCcl()

  def send_getKeyCcl(self, key, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCcl', TMessageType.CALL, self._seqid)
    args = getKeyCcl_args()
    args.key = key
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCcl failed: unknown result")

  def getKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_getKeyCriteriaTime()

  def send_getKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCriteriaTime', TMessageType.CALL, self._seqid)
    args = getKeyCriteriaTime_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCriteriaTime failed: unknown result")

  def getKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_getKeyCriteriaTimestr()

  def send_getKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = getKeyCriteriaTimestr_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCriteriaTimestr failed: unknown result")

  def getKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_getKeyCclTime()

  def send_getKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCclTime', TMessageType.CALL, self._seqid)
    args = getKeyCclTime_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCclTime failed: unknown result")

  def getKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_getKeyCclTimestr()

  def send_getKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCclTimestr', TMessageType.CALL, self._seqid)
    args = getKeyCclTimestr_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCclTimestr failed: unknown result")

  def getKeysCriteria(self, keys, criteria, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCriteria(keys, criteria, creds, transaction, environment)
    return self.recv_getKeysCriteria()

  def send_getKeysCriteria(self, keys, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCriteria', TMessageType.CALL, self._seqid)
    args = getKeysCriteria_args()
    args.keys = keys
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCriteria failed: unknown result")

  def getKeysCcl(self, keys, ccl, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCcl(keys, ccl, creds, transaction, environment)
    return self.recv_getKeysCcl()

  def send_getKeysCcl(self, keys, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCcl', TMessageType.CALL, self._seqid)
    args = getKeysCcl_args()
    args.keys = keys
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCcl failed: unknown result")

  def getKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCriteriaTime(keys, criteria, timestamp, creds, transaction, environment)
    return self.recv_getKeysCriteriaTime()

  def send_getKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCriteriaTime', TMessageType.CALL, self._seqid)
    args = getKeysCriteriaTime_args()
    args.keys = keys
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCriteriaTime failed: unknown result")

  def getKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCriteriaTimestr(keys, criteria, timestamp, creds, transaction, environment)
    return self.recv_getKeysCriteriaTimestr()

  def send_getKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = getKeysCriteriaTimestr_args()
    args.keys = keys
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCriteriaTimestr failed: unknown result")

  def getKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCclTime(keys, ccl, timestamp, creds, transaction, environment)
    return self.recv_getKeysCclTime()

  def send_getKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCclTime', TMessageType.CALL, self._seqid)
    args = getKeysCclTime_args()
    args.keys = keys
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCclTime failed: unknown result")

  def getKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCclTimestr(keys, ccl, timestamp, creds, transaction, environment)
    return self.recv_getKeysCclTimestr()

  def send_getKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCclTimestr', TMessageType.CALL, self._seqid)
    args = getKeysCclTimestr_args()
    args.keys = keys
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCclTimestr failed: unknown result")

  def verifyKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    self.send_verifyKeyValueRecord(key, value, record, creds, transaction, environment)
    return self.recv_verifyKeyValueRecord()

  def send_verifyKeyValueRecord(self, key, value, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('verifyKeyValueRecord', TMessageType.CALL, self._seqid)
    args = verifyKeyValueRecord_args()
    args.key = key
    args.value = value
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyKeyValueRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = verifyKeyValueRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyKeyValueRecord failed: unknown result")

  def verifyKeyValueRecordTime(self, key, value, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_verifyKeyValueRecordTime(key, value, record, timestamp, creds, transaction, environment)
    return self.recv_verifyKeyValueRecordTime()

  def send_verifyKeyValueRecordTime(self, key, value, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('verifyKeyValueRecordTime', TMessageType.CALL, self._seqid)
    args = verifyKeyValueRecordTime_args()
    args.key = key
    args.value = value
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyKeyValueRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = verifyKeyValueRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyKeyValueRecordTime failed: unknown result")

  def verifyKeyValueRecordTimestr(self, key, value, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_verifyKeyValueRecordTimestr(key, value, record, timestamp, creds, transaction, environment)
    return self.recv_verifyKeyValueRecordTimestr()

  def send_verifyKeyValueRecordTimestr(self, key, value, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('verifyKeyValueRecordTimestr', TMessageType.CALL, self._seqid)
    args = verifyKeyValueRecordTimestr_args()
    args.key = key
    args.value = value
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyKeyValueRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = verifyKeyValueRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyKeyValueRecordTimestr failed: unknown result")

  def jsonifyRecords(self, records, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - identifier
     - creds
     - transaction
     - environment
    """
    self.send_jsonifyRecords(records, identifier, creds, transaction, environment)
    return self.recv_jsonifyRecords()

  def send_jsonifyRecords(self, records, identifier, creds, transaction, environment):
    self._oprot.writeMessageBegin('jsonifyRecords', TMessageType.CALL, self._seqid)
    args = jsonifyRecords_args()
    args.records = records
    args.identifier = identifier
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_jsonifyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = jsonifyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "jsonifyRecords failed: unknown result")

  def jsonifyRecordsTime(self, records, timestamp, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - identifier
     - creds
     - transaction
     - environment
    """
    self.send_jsonifyRecordsTime(records, timestamp, identifier, creds, transaction, environment)
    return self.recv_jsonifyRecordsTime()

  def send_jsonifyRecordsTime(self, records, timestamp, identifier, creds, transaction, environment):
    self._oprot.writeMessageBegin('jsonifyRecordsTime', TMessageType.CALL, self._seqid)
    args = jsonifyRecordsTime_args()
    args.records = records
    args.timestamp = timestamp
    args.identifier = identifier
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_jsonifyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = jsonifyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "jsonifyRecordsTime failed: unknown result")

  def jsonifyRecordsTimestr(self, records, timestamp, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - identifier
     - creds
     - transaction
     - environment
    """
    self.send_jsonifyRecordsTimestr(records, timestamp, identifier, creds, transaction, environment)
    return self.recv_jsonifyRecordsTimestr()

  def send_jsonifyRecordsTimestr(self, records, timestamp, identifier, creds, transaction, environment):
    self._oprot.writeMessageBegin('jsonifyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = jsonifyRecordsTimestr_args()
    args.records = records
    args.timestamp = timestamp
    args.identifier = identifier
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_jsonifyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = jsonifyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "jsonifyRecordsTimestr failed: unknown result")

  def findCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_findCriteria(criteria, creds, transaction, environment)
    return self.recv_findCriteria()

  def send_findCriteria(self, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('findCriteria', TMessageType.CALL, self._seqid)
    args = findCriteria_args()
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findCriteria failed: unknown result")

  def findCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_findCcl(ccl, creds, transaction, environment)
    return self.recv_findCcl()

  def send_findCcl(self, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('findCcl', TMessageType.CALL, self._seqid)
    args = findCcl_args()
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findCcl failed: unknown result")

  def findKeyOperatorValues(self, key, operator, values, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorValues(key, operator, values, creds, transaction, environment)
    return self.recv_findKeyOperatorValues()

  def send_findKeyOperatorValues(self, key, operator, values, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorValues', TMessageType.CALL, self._seqid)
    args = findKeyOperatorValues_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorValues(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorValues_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorValues failed: unknown result")

  def findKeyOperatorValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorValuesTime(key, operator, values, timestamp, creds, transaction, environment)
    return self.recv_findKeyOperatorValuesTime()

  def send_findKeyOperatorValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorValuesTime', TMessageType.CALL, self._seqid)
    args = findKeyOperatorValuesTime_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorValuesTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorValuesTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorValuesTime failed: unknown result")

  def findKeyOperatorValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorValuesTimestr(key, operator, values, timestamp, creds, transaction, environment)
    return self.recv_findKeyOperatorValuesTimestr()

  def send_findKeyOperatorValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorValuesTimestr', TMessageType.CALL, self._seqid)
    args = findKeyOperatorValuesTimestr_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorValuesTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorValuesTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorValuesTimestr failed: unknown result")

  def findKeyOperatorstrValues(self, key, operator, values, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorstrValues(key, operator, values, creds, transaction, environment)
    return self.recv_findKeyOperatorstrValues()

  def send_findKeyOperatorstrValues(self, key, operator, values, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorstrValues', TMessageType.CALL, self._seqid)
    args = findKeyOperatorstrValues_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorstrValues(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorstrValues_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorstrValues failed: unknown result")

  def findKeyOperatorstrValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorstrValuesTime(key, operator, values, timestamp, creds, transaction, environment)
    return self.recv_findKeyOperatorstrValuesTime()

  def send_findKeyOperatorstrValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorstrValuesTime', TMessageType.CALL, self._seqid)
    args = findKeyOperatorstrValuesTime_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorstrValuesTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorstrValuesTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorstrValuesTime failed: unknown result")

  def findKeyOperatorstrValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorstrValuesTimestr(key, operator, values, timestamp, creds, transaction, environment)
    return self.recv_findKeyOperatorstrValuesTimestr()

  def send_findKeyOperatorstrValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorstrValuesTimestr', TMessageType.CALL, self._seqid)
    args = findKeyOperatorstrValuesTimestr_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorstrValuesTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorstrValuesTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorstrValuesTimestr failed: unknown result")

  def search(self, key, query, creds, transaction, environment):
    """
    Parameters:
     - key
     - query
     - creds
     - transaction
     - environment
    """
    self.send_search(key, query, creds, transaction, environment)
    return self.recv_search()

  def send_search(self, key, query, creds, transaction, environment):
    self._oprot.writeMessageBegin('search', TMessageType.CALL, self._seqid)
    args = search_args()
    args.key = key
    args.query = query
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_search(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = search_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "search failed: unknown result")

  def revertKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeysRecordsTime(keys, records, timestamp, creds, transaction, environment)
    self.recv_revertKeysRecordsTime()

  def send_revertKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeysRecordsTime', TMessageType.CALL, self._seqid)
    args = revertKeysRecordsTime_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeysRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeysRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def revertKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeysRecordsTimestr(keys, records, timestamp, creds, transaction, environment)
    self.recv_revertKeysRecordsTimestr()

  def send_revertKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeysRecordsTimestr', TMessageType.CALL, self._seqid)
    args = revertKeysRecordsTimestr_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeysRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeysRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def revertKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeysRecordTime(keys, record, timestamp, creds, transaction, environment)
    self.recv_revertKeysRecordTime()

  def send_revertKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeysRecordTime', TMessageType.CALL, self._seqid)
    args = revertKeysRecordTime_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeysRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeysRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def revertKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeysRecordTimestr(keys, record, timestamp, creds, transaction, environment)
    self.recv_revertKeysRecordTimestr()

  def send_revertKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeysRecordTimestr', TMessageType.CALL, self._seqid)
    args = revertKeysRecordTimestr_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeysRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeysRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def revertKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
    self.recv_revertKeyRecordsTime()

  def send_revertKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeyRecordsTime', TMessageType.CALL, self._seqid)
    args = revertKeyRecordsTime_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def revertKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
    self.recv_revertKeyRecordsTimestr()

  def send_revertKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = revertKeyRecordsTimestr_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def revertKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeyRecordTime(key, record, timestamp, creds, transaction, environment)
    self.recv_revertKeyRecordTime()

  def send_revertKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeyRecordTime', TMessageType.CALL, self._seqid)
    args = revertKeyRecordTime_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeyRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeyRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def revertKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
    self.recv_revertKeyRecordTimestr()

  def send_revertKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeyRecordTimestr', TMessageType.CALL, self._seqid)
    args = revertKeyRecordTimestr_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeyRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeyRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def pingRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    self.send_pingRecords(records, creds, transaction, environment)
    return self.recv_pingRecords()

  def send_pingRecords(self, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('pingRecords', TMessageType.CALL, self._seqid)
    args = pingRecords_args()
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_pingRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = pingRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "pingRecords failed: unknown result")

  def pingRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    self.send_pingRecord(record, creds, transaction, environment)
    return self.recv_pingRecord()

  def send_pingRecord(self, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('pingRecord', TMessageType.CALL, self._seqid)
    args = pingRecord_args()
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_pingRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = pingRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "pingRecord failed: unknown result")

  def verifyAndSwap(self, key, expected, record, replacement, creds, transaction, environment):
    """
    Parameters:
     - key
     - expected
     - record
     - replacement
     - creds
     - transaction
     - environment
    """
    self.send_verifyAndSwap(key, expected, record, replacement, creds, transaction, environment)
    return self.recv_verifyAndSwap()

  def send_verifyAndSwap(self, key, expected, record, replacement, creds, transaction, environment):
    self._oprot.writeMessageBegin('verifyAndSwap', TMessageType.CALL, self._seqid)
    args = verifyAndSwap_args()
    args.key = key
    args.expected = expected
    args.record = record
    args.replacement = replacement
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyAndSwap(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = verifyAndSwap_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyAndSwap failed: unknown result")

  def verifyOrSet(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    self.send_verifyOrSet(key, value, record, creds, transaction, environment)
    self.recv_verifyOrSet()

  def send_verifyOrSet(self, key, value, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('verifyOrSet', TMessageType.CALL, self._seqid)
    args = verifyOrSet_args()
    args.key = key
    args.value = value
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyOrSet(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = verifyOrSet_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def findOrAddKeyValue(self, key, value, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    self.send_findOrAddKeyValue(key, value, creds, transaction, environment)
    return self.recv_findOrAddKeyValue()

  def send_findOrAddKeyValue(self, key, value, creds, transaction, environment):
    self._oprot.writeMessageBegin('findOrAddKeyValue', TMessageType.CALL, self._seqid)
    args = findOrAddKeyValue_args()
    args.key = key
    args.value = value
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findOrAddKeyValue(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findOrAddKeyValue_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    if result.ex4 is not None:
      raise result.ex4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findOrAddKeyValue failed: unknown result")

  def findOrInsertCriteriaJson(self, criteria, json, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - json
     - creds
     - transaction
     - environment
    """
    self.send_findOrInsertCriteriaJson(criteria, json, creds, transaction, environment)
    return self.recv_findOrInsertCriteriaJson()

  def send_findOrInsertCriteriaJson(self, criteria, json, creds, transaction, environment):
    self._oprot.writeMessageBegin('findOrInsertCriteriaJson', TMessageType.CALL, self._seqid)
    args = findOrInsertCriteriaJson_args()
    args.criteria = criteria
    args.json = json
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findOrInsertCriteriaJson(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findOrInsertCriteriaJson_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findOrInsertCriteriaJson failed: unknown result")

  def findOrInsertCclJson(self, ccl, json, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - json
     - creds
     - transaction
     - environment
    """
    self.send_findOrInsertCclJson(ccl, json, creds, transaction, environment)
    return self.recv_findOrInsertCclJson()

  def send_findOrInsertCclJson(self, ccl, json, creds, transaction, environment):
    self._oprot.writeMessageBegin('findOrInsertCclJson', TMessageType.CALL, self._seqid)
    args = findOrInsertCclJson_args()
    args.ccl = ccl
    args.json = json
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findOrInsertCclJson(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findOrInsertCclJson_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    if result.ex4 is not None:
      raise result.ex4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findOrInsertCclJson failed: unknown result")

  def getServerEnvironment(self, creds, token, environment):
    """
    Parameters:
     - creds
     - token
     - environment
    """
    self.send_getServerEnvironment(creds, token, environment)
    return self.recv_getServerEnvironment()

  def send_getServerEnvironment(self, creds, token, environment):
    self._oprot.writeMessageBegin('getServerEnvironment', TMessageType.CALL, self._seqid)
    args = getServerEnvironment_args()
    args.creds = creds
    args.token = token
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getServerEnvironment(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getServerEnvironment_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getServerEnvironment failed: unknown result")

  def getServerVersion(self):
    self.send_getServerVersion()
    return self.recv_getServerVersion()

  def send_getServerVersion(self):
    self._oprot.writeMessageBegin('getServerVersion', TMessageType.CALL, self._seqid)
    args = getServerVersion_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getServerVersion(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getServerVersion_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getServerVersion failed: unknown result")

  def time(self, creds, token, environment):
    """
    Parameters:
     - creds
     - token
     - environment
    """
    self.send_time(creds, token, environment)
    return self.recv_time()

  def send_time(self, creds, token, environment):
    self._oprot.writeMessageBegin('time', TMessageType.CALL, self._seqid)
    args = time_args()
    args.creds = creds
    args.token = token
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "time failed: unknown result")

  def timePhrase(self, phrase, creds, token, environment):
    """
    Parameters:
     - phrase
     - creds
     - token
     - environment
    """
    self.send_timePhrase(phrase, creds, token, environment)
    return self.recv_timePhrase()

  def send_timePhrase(self, phrase, creds, token, environment):
    self._oprot.writeMessageBegin('timePhrase', TMessageType.CALL, self._seqid)
    args = timePhrase_args()
    args.phrase = phrase
    args.creds = creds
    args.token = token
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_timePhrase(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = timePhrase_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "timePhrase failed: unknown result")


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["abort"] = Processor.process_abort
    self._processMap["addKeyValue"] = Processor.process_addKeyValue
    self._processMap["addKeyValueRecord"] = Processor.process_addKeyValueRecord
    self._processMap["addKeyValueRecords"] = Processor.process_addKeyValueRecords
    self._processMap["auditRecord"] = Processor.process_auditRecord
    self._processMap["auditRecordStart"] = Processor.process_auditRecordStart
    self._processMap["auditRecordStartstr"] = Processor.process_auditRecordStartstr
    self._processMap["auditRecordStartEnd"] = Processor.process_auditRecordStartEnd
    self._processMap["auditRecordStartstrEndstr"] = Processor.process_auditRecordStartstrEndstr
    self._processMap["auditKeyRecord"] = Processor.process_auditKeyRecord
    self._processMap["auditKeyRecordStart"] = Processor.process_auditKeyRecordStart
    self._processMap["auditKeyRecordStartstr"] = Processor.process_auditKeyRecordStartstr
    self._processMap["auditKeyRecordStartEnd"] = Processor.process_auditKeyRecordStartEnd
    self._processMap["auditKeyRecordStartstrEndstr"] = Processor.process_auditKeyRecordStartstrEndstr
    self._processMap["browseKey"] = Processor.process_browseKey
    self._processMap["browseKeys"] = Processor.process_browseKeys
    self._processMap["browseKeyTime"] = Processor.process_browseKeyTime
    self._processMap["browseKeyTimestr"] = Processor.process_browseKeyTimestr
    self._processMap["browseKeysTime"] = Processor.process_browseKeysTime
    self._processMap["browseKeysTimestr"] = Processor.process_browseKeysTimestr
    self._processMap["chronologizeKeyRecord"] = Processor.process_chronologizeKeyRecord
    self._processMap["chronologizeKeyRecordStart"] = Processor.process_chronologizeKeyRecordStart
    self._processMap["chronologizeKeyRecordStartstr"] = Processor.process_chronologizeKeyRecordStartstr
    self._processMap["chronologizeKeyRecordStartEnd"] = Processor.process_chronologizeKeyRecordStartEnd
    self._processMap["chronologizeKeyRecordStartstrEndstr"] = Processor.process_chronologizeKeyRecordStartstrEndstr
    self._processMap["clearRecord"] = Processor.process_clearRecord
    self._processMap["clearRecords"] = Processor.process_clearRecords
    self._processMap["clearKeyRecord"] = Processor.process_clearKeyRecord
    self._processMap["clearKeysRecord"] = Processor.process_clearKeysRecord
    self._processMap["clearKeyRecords"] = Processor.process_clearKeyRecords
    self._processMap["clearKeysRecords"] = Processor.process_clearKeysRecords
    self._processMap["commit"] = Processor.process_commit
    self._processMap["describeRecord"] = Processor.process_describeRecord
    self._processMap["describeRecordTime"] = Processor.process_describeRecordTime
    self._processMap["describeRecordTimestr"] = Processor.process_describeRecordTimestr
    self._processMap["describeRecords"] = Processor.process_describeRecords
    self._processMap["describeRecordsTime"] = Processor.process_describeRecordsTime
    self._processMap["describeRecordsTimestr"] = Processor.process_describeRecordsTimestr
    self._processMap["diffRecordStart"] = Processor.process_diffRecordStart
    self._processMap["diffRecordStartstr"] = Processor.process_diffRecordStartstr
    self._processMap["diffRecordStartEnd"] = Processor.process_diffRecordStartEnd
    self._processMap["diffRecordStartstrEndstr"] = Processor.process_diffRecordStartstrEndstr
    self._processMap["diffKeyRecordStart"] = Processor.process_diffKeyRecordStart
    self._processMap["diffKeyRecordStartstr"] = Processor.process_diffKeyRecordStartstr
    self._processMap["diffKeyRecordStartEnd"] = Processor.process_diffKeyRecordStartEnd
    self._processMap["diffKeyRecordStartstrEndstr"] = Processor.process_diffKeyRecordStartstrEndstr
    self._processMap["diffKeyStart"] = Processor.process_diffKeyStart
    self._processMap["diffKeyStartstr"] = Processor.process_diffKeyStartstr
    self._processMap["diffKeyStartEnd"] = Processor.process_diffKeyStartEnd
    self._processMap["diffKeyStartstrEndstr"] = Processor.process_diffKeyStartstrEndstr
    self._processMap["login"] = Processor.process_login
    self._processMap["logout"] = Processor.process_logout
    self._processMap["stage"] = Processor.process_stage
    self._processMap["insertJson"] = Processor.process_insertJson
    self._processMap["insertJsonRecord"] = Processor.process_insertJsonRecord
    self._processMap["insertJsonRecords"] = Processor.process_insertJsonRecords
    self._processMap["removeKeyValueRecord"] = Processor.process_removeKeyValueRecord
    self._processMap["removeKeyValueRecords"] = Processor.process_removeKeyValueRecords
    self._processMap["setKeyValueRecord"] = Processor.process_setKeyValueRecord
    self._processMap["setKeyValue"] = Processor.process_setKeyValue
    self._processMap["setKeyValueRecords"] = Processor.process_setKeyValueRecords
    self._processMap["reconcileKeyRecordValues"] = Processor.process_reconcileKeyRecordValues
    self._processMap["inventory"] = Processor.process_inventory
    self._processMap["selectRecord"] = Processor.process_selectRecord
    self._processMap["selectRecords"] = Processor.process_selectRecords
    self._processMap["selectRecordTime"] = Processor.process_selectRecordTime
    self._processMap["selectRecordTimestr"] = Processor.process_selectRecordTimestr
    self._processMap["selectRecordsTime"] = Processor.process_selectRecordsTime
    self._processMap["selectRecordsTimestr"] = Processor.process_selectRecordsTimestr
    self._processMap["selectKeyRecord"] = Processor.process_selectKeyRecord
    self._processMap["selectKeyRecordTime"] = Processor.process_selectKeyRecordTime
    self._processMap["selectKeyRecordTimestr"] = Processor.process_selectKeyRecordTimestr
    self._processMap["selectKeysRecord"] = Processor.process_selectKeysRecord
    self._processMap["selectKeysRecordTime"] = Processor.process_selectKeysRecordTime
    self._processMap["selectKeysRecordTimestr"] = Processor.process_selectKeysRecordTimestr
    self._processMap["selectKeysRecords"] = Processor.process_selectKeysRecords
    self._processMap["selectKeyRecords"] = Processor.process_selectKeyRecords
    self._processMap["selectKeyRecordsTime"] = Processor.process_selectKeyRecordsTime
    self._processMap["selectKeyRecordsTimestr"] = Processor.process_selectKeyRecordsTimestr
    self._processMap["selectKeysRecordsTime"] = Processor.process_selectKeysRecordsTime
    self._processMap["selectKeysRecordsTimestr"] = Processor.process_selectKeysRecordsTimestr
    self._processMap["selectCriteria"] = Processor.process_selectCriteria
    self._processMap["selectCcl"] = Processor.process_selectCcl
    self._processMap["selectCriteriaTime"] = Processor.process_selectCriteriaTime
    self._processMap["selectCriteriaTimestr"] = Processor.process_selectCriteriaTimestr
    self._processMap["selectCclTime"] = Processor.process_selectCclTime
    self._processMap["selectCclTimestr"] = Processor.process_selectCclTimestr
    self._processMap["selectKeyCriteria"] = Processor.process_selectKeyCriteria
    self._processMap["selectKeyCcl"] = Processor.process_selectKeyCcl
    self._processMap["selectKeyCriteriaTime"] = Processor.process_selectKeyCriteriaTime
    self._processMap["selectKeyCriteriaTimestr"] = Processor.process_selectKeyCriteriaTimestr
    self._processMap["selectKeyCclTime"] = Processor.process_selectKeyCclTime
    self._processMap["selectKeyCclTimestr"] = Processor.process_selectKeyCclTimestr
    self._processMap["selectKeysCriteria"] = Processor.process_selectKeysCriteria
    self._processMap["selectKeysCcl"] = Processor.process_selectKeysCcl
    self._processMap["selectKeysCriteriaTime"] = Processor.process_selectKeysCriteriaTime
    self._processMap["selectKeysCriteriaTimestr"] = Processor.process_selectKeysCriteriaTimestr
    self._processMap["selectKeysCclTime"] = Processor.process_selectKeysCclTime
    self._processMap["selectKeysCclTimestr"] = Processor.process_selectKeysCclTimestr
    self._processMap["getKeyRecord"] = Processor.process_getKeyRecord
    self._processMap["getKeyRecordTime"] = Processor.process_getKeyRecordTime
    self._processMap["getKeyRecordTimestr"] = Processor.process_getKeyRecordTimestr
    self._processMap["getKeysRecord"] = Processor.process_getKeysRecord
    self._processMap["getKeysRecordTime"] = Processor.process_getKeysRecordTime
    self._processMap["getKeysRecordTimestr"] = Processor.process_getKeysRecordTimestr
    self._processMap["getKeysRecords"] = Processor.process_getKeysRecords
    self._processMap["getKeyRecords"] = Processor.process_getKeyRecords
    self._processMap["getKeyRecordsTime"] = Processor.process_getKeyRecordsTime
    self._processMap["getKeyRecordsTimestr"] = Processor.process_getKeyRecordsTimestr
    self._processMap["getKeysRecordsTime"] = Processor.process_getKeysRecordsTime
    self._processMap["getKeysRecordsTimestr"] = Processor.process_getKeysRecordsTimestr
    self._processMap["getKeyCriteria"] = Processor.process_getKeyCriteria
    self._processMap["getCriteria"] = Processor.process_getCriteria
    self._processMap["getCcl"] = Processor.process_getCcl
    self._processMap["getCriteriaTime"] = Processor.process_getCriteriaTime
    self._processMap["getCriteriaTimestr"] = Processor.process_getCriteriaTimestr
    self._processMap["getCclTime"] = Processor.process_getCclTime
    self._processMap["getCclTimestr"] = Processor.process_getCclTimestr
    self._processMap["getKeyCcl"] = Processor.process_getKeyCcl
    self._processMap["getKeyCriteriaTime"] = Processor.process_getKeyCriteriaTime
    self._processMap["getKeyCriteriaTimestr"] = Processor.process_getKeyCriteriaTimestr
    self._processMap["getKeyCclTime"] = Processor.process_getKeyCclTime
    self._processMap["getKeyCclTimestr"] = Processor.process_getKeyCclTimestr
    self._processMap["getKeysCriteria"] = Processor.process_getKeysCriteria
    self._processMap["getKeysCcl"] = Processor.process_getKeysCcl
    self._processMap["getKeysCriteriaTime"] = Processor.process_getKeysCriteriaTime
    self._processMap["getKeysCriteriaTimestr"] = Processor.process_getKeysCriteriaTimestr
    self._processMap["getKeysCclTime"] = Processor.process_getKeysCclTime
    self._processMap["getKeysCclTimestr"] = Processor.process_getKeysCclTimestr
    self._processMap["verifyKeyValueRecord"] = Processor.process_verifyKeyValueRecord
    self._processMap["verifyKeyValueRecordTime"] = Processor.process_verifyKeyValueRecordTime
    self._processMap["verifyKeyValueRecordTimestr"] = Processor.process_verifyKeyValueRecordTimestr
    self._processMap["jsonifyRecords"] = Processor.process_jsonifyRecords
    self._processMap["jsonifyRecordsTime"] = Processor.process_jsonifyRecordsTime
    self._processMap["jsonifyRecordsTimestr"] = Processor.process_jsonifyRecordsTimestr
    self._processMap["findCriteria"] = Processor.process_findCriteria
    self._processMap["findCcl"] = Processor.process_findCcl
    self._processMap["findKeyOperatorValues"] = Processor.process_findKeyOperatorValues
    self._processMap["findKeyOperatorValuesTime"] = Processor.process_findKeyOperatorValuesTime
    self._processMap["findKeyOperatorValuesTimestr"] = Processor.process_findKeyOperatorValuesTimestr
    self._processMap["findKeyOperatorstrValues"] = Processor.process_findKeyOperatorstrValues
    self._processMap["findKeyOperatorstrValuesTime"] = Processor.process_findKeyOperatorstrValuesTime
    self._processMap["findKeyOperatorstrValuesTimestr"] = Processor.process_findKeyOperatorstrValuesTimestr
    self._processMap["search"] = Processor.process_search
    self._processMap["revertKeysRecordsTime"] = Processor.process_revertKeysRecordsTime
    self._processMap["revertKeysRecordsTimestr"] = Processor.process_revertKeysRecordsTimestr
    self._processMap["revertKeysRecordTime"] = Processor.process_revertKeysRecordTime
    self._processMap["revertKeysRecordTimestr"] = Processor.process_revertKeysRecordTimestr
    self._processMap["revertKeyRecordsTime"] = Processor.process_revertKeyRecordsTime
    self._processMap["revertKeyRecordsTimestr"] = Processor.process_revertKeyRecordsTimestr
    self._processMap["revertKeyRecordTime"] = Processor.process_revertKeyRecordTime
    self._processMap["revertKeyRecordTimestr"] = Processor.process_revertKeyRecordTimestr
    self._processMap["pingRecords"] = Processor.process_pingRecords
    self._processMap["pingRecord"] = Processor.process_pingRecord
    self._processMap["verifyAndSwap"] = Processor.process_verifyAndSwap
    self._processMap["verifyOrSet"] = Processor.process_verifyOrSet
    self._processMap["findOrAddKeyValue"] = Processor.process_findOrAddKeyValue
    self._processMap["findOrInsertCriteriaJson"] = Processor.process_findOrInsertCriteriaJson
    self._processMap["findOrInsertCclJson"] = Processor.process_findOrInsertCclJson
    self._processMap["getServerEnvironment"] = Processor.process_getServerEnvironment
    self._processMap["getServerVersion"] = Processor.process_getServerVersion
    self._processMap["time"] = Processor.process_time
    self._processMap["timePhrase"] = Processor.process_timePhrase

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_abort(self, seqid, iprot, oprot):
    args = abort_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = abort_result()
    try:
      self._handler.abort(args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("abort", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addKeyValue(self, seqid, iprot, oprot):
    args = addKeyValue_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addKeyValue_result()
    try:
      result.success = self._handler.addKeyValue(args.key, args.value, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("addKeyValue", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addKeyValueRecord(self, seqid, iprot, oprot):
    args = addKeyValueRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addKeyValueRecord_result()
    try:
      result.success = self._handler.addKeyValueRecord(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("addKeyValueRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addKeyValueRecords(self, seqid, iprot, oprot):
    args = addKeyValueRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addKeyValueRecords_result()
    try:
      result.success = self._handler.addKeyValueRecords(args.key, args.value, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("addKeyValueRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditRecord(self, seqid, iprot, oprot):
    args = auditRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditRecord_result()
    try:
      result.success = self._handler.auditRecord(args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditRecordStart(self, seqid, iprot, oprot):
    args = auditRecordStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditRecordStart_result()
    try:
      result.success = self._handler.auditRecordStart(args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditRecordStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditRecordStartstr(self, seqid, iprot, oprot):
    args = auditRecordStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditRecordStartstr_result()
    try:
      result.success = self._handler.auditRecordStartstr(args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditRecordStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditRecordStartEnd(self, seqid, iprot, oprot):
    args = auditRecordStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditRecordStartEnd_result()
    try:
      result.success = self._handler.auditRecordStartEnd(args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditRecordStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditRecordStartstrEndstr(self, seqid, iprot, oprot):
    args = auditRecordStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditRecordStartstrEndstr_result()
    try:
      result.success = self._handler.auditRecordStartstrEndstr(args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditRecordStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditKeyRecord(self, seqid, iprot, oprot):
    args = auditKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditKeyRecord_result()
    try:
      result.success = self._handler.auditKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditKeyRecordStart(self, seqid, iprot, oprot):
    args = auditKeyRecordStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditKeyRecordStart_result()
    try:
      result.success = self._handler.auditKeyRecordStart(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditKeyRecordStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditKeyRecordStartstr(self, seqid, iprot, oprot):
    args = auditKeyRecordStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditKeyRecordStartstr_result()
    try:
      result.success = self._handler.auditKeyRecordStartstr(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditKeyRecordStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditKeyRecordStartEnd(self, seqid, iprot, oprot):
    args = auditKeyRecordStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditKeyRecordStartEnd_result()
    try:
      result.success = self._handler.auditKeyRecordStartEnd(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditKeyRecordStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditKeyRecordStartstrEndstr(self, seqid, iprot, oprot):
    args = auditKeyRecordStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditKeyRecordStartstrEndstr_result()
    try:
      result.success = self._handler.auditKeyRecordStartstrEndstr(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditKeyRecordStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKey(self, seqid, iprot, oprot):
    args = browseKey_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKey_result()
    try:
      result.success = self._handler.browseKey(args.key, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKey", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKeys(self, seqid, iprot, oprot):
    args = browseKeys_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKeys_result()
    try:
      result.success = self._handler.browseKeys(args.keys, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKeys", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKeyTime(self, seqid, iprot, oprot):
    args = browseKeyTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKeyTime_result()
    try:
      result.success = self._handler.browseKeyTime(args.key, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKeyTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKeyTimestr(self, seqid, iprot, oprot):
    args = browseKeyTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKeyTimestr_result()
    try:
      result.success = self._handler.browseKeyTimestr(args.key, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKeyTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKeysTime(self, seqid, iprot, oprot):
    args = browseKeysTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKeysTime_result()
    try:
      result.success = self._handler.browseKeysTime(args.keys, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKeysTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKeysTimestr(self, seqid, iprot, oprot):
    args = browseKeysTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKeysTimestr_result()
    try:
      result.success = self._handler.browseKeysTimestr(args.keys, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKeysTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chronologizeKeyRecord(self, seqid, iprot, oprot):
    args = chronologizeKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chronologizeKeyRecord_result()
    try:
      result.success = self._handler.chronologizeKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("chronologizeKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chronologizeKeyRecordStart(self, seqid, iprot, oprot):
    args = chronologizeKeyRecordStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chronologizeKeyRecordStart_result()
    try:
      result.success = self._handler.chronologizeKeyRecordStart(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("chronologizeKeyRecordStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chronologizeKeyRecordStartstr(self, seqid, iprot, oprot):
    args = chronologizeKeyRecordStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chronologizeKeyRecordStartstr_result()
    try:
      result.success = self._handler.chronologizeKeyRecordStartstr(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("chronologizeKeyRecordStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chronologizeKeyRecordStartEnd(self, seqid, iprot, oprot):
    args = chronologizeKeyRecordStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chronologizeKeyRecordStartEnd_result()
    try:
      result.success = self._handler.chronologizeKeyRecordStartEnd(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("chronologizeKeyRecordStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chronologizeKeyRecordStartstrEndstr(self, seqid, iprot, oprot):
    args = chronologizeKeyRecordStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chronologizeKeyRecordStartstrEndstr_result()
    try:
      result.success = self._handler.chronologizeKeyRecordStartstrEndstr(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("chronologizeKeyRecordStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearRecord(self, seqid, iprot, oprot):
    args = clearRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearRecord_result()
    try:
      self._handler.clearRecord(args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearRecords(self, seqid, iprot, oprot):
    args = clearRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearRecords_result()
    try:
      self._handler.clearRecords(args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearKeyRecord(self, seqid, iprot, oprot):
    args = clearKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearKeyRecord_result()
    try:
      self._handler.clearKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearKeysRecord(self, seqid, iprot, oprot):
    args = clearKeysRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearKeysRecord_result()
    try:
      self._handler.clearKeysRecord(args.keys, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearKeysRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearKeyRecords(self, seqid, iprot, oprot):
    args = clearKeyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearKeyRecords_result()
    try:
      self._handler.clearKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearKeyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearKeysRecords(self, seqid, iprot, oprot):
    args = clearKeysRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearKeysRecords_result()
    try:
      self._handler.clearKeysRecords(args.keys, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearKeysRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_commit(self, seqid, iprot, oprot):
    args = commit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = commit_result()
    try:
      result.success = self._handler.commit(args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("commit", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecord(self, seqid, iprot, oprot):
    args = describeRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecord_result()
    try:
      result.success = self._handler.describeRecord(args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecordTime(self, seqid, iprot, oprot):
    args = describeRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecordTime_result()
    try:
      result.success = self._handler.describeRecordTime(args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecordTimestr(self, seqid, iprot, oprot):
    args = describeRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecordTimestr_result()
    try:
      result.success = self._handler.describeRecordTimestr(args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecords(self, seqid, iprot, oprot):
    args = describeRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecords_result()
    try:
      result.success = self._handler.describeRecords(args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecordsTime(self, seqid, iprot, oprot):
    args = describeRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecordsTime_result()
    try:
      result.success = self._handler.describeRecordsTime(args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecordsTimestr(self, seqid, iprot, oprot):
    args = describeRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecordsTimestr_result()
    try:
      result.success = self._handler.describeRecordsTimestr(args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffRecordStart(self, seqid, iprot, oprot):
    args = diffRecordStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffRecordStart_result()
    try:
      result.success = self._handler.diffRecordStart(args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffRecordStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffRecordStartstr(self, seqid, iprot, oprot):
    args = diffRecordStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffRecordStartstr_result()
    try:
      result.success = self._handler.diffRecordStartstr(args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffRecordStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffRecordStartEnd(self, seqid, iprot, oprot):
    args = diffRecordStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffRecordStartEnd_result()
    try:
      result.success = self._handler.diffRecordStartEnd(args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffRecordStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffRecordStartstrEndstr(self, seqid, iprot, oprot):
    args = diffRecordStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffRecordStartstrEndstr_result()
    try:
      result.success = self._handler.diffRecordStartstrEndstr(args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffRecordStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyRecordStart(self, seqid, iprot, oprot):
    args = diffKeyRecordStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyRecordStart_result()
    try:
      result.success = self._handler.diffKeyRecordStart(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyRecordStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyRecordStartstr(self, seqid, iprot, oprot):
    args = diffKeyRecordStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyRecordStartstr_result()
    try:
      result.success = self._handler.diffKeyRecordStartstr(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyRecordStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyRecordStartEnd(self, seqid, iprot, oprot):
    args = diffKeyRecordStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyRecordStartEnd_result()
    try:
      result.success = self._handler.diffKeyRecordStartEnd(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyRecordStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyRecordStartstrEndstr(self, seqid, iprot, oprot):
    args = diffKeyRecordStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyRecordStartstrEndstr_result()
    try:
      result.success = self._handler.diffKeyRecordStartstrEndstr(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyRecordStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyStart(self, seqid, iprot, oprot):
    args = diffKeyStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyStart_result()
    try:
      result.success = self._handler.diffKeyStart(args.key, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyStartstr(self, seqid, iprot, oprot):
    args = diffKeyStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyStartstr_result()
    try:
      result.success = self._handler.diffKeyStartstr(args.key, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyStartEnd(self, seqid, iprot, oprot):
    args = diffKeyStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyStartEnd_result()
    try:
      result.success = self._handler.diffKeyStartEnd(args.key, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyStartstrEndstr(self, seqid, iprot, oprot):
    args = diffKeyStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyStartstrEndstr_result()
    try:
      result.success = self._handler.diffKeyStartstrEndstr(args.key, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_login(self, seqid, iprot, oprot):
    args = login_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = login_result()
    try:
      result.success = self._handler.login(args.username, args.password, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("login", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_logout(self, seqid, iprot, oprot):
    args = logout_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = logout_result()
    try:
      self._handler.logout(args.token, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("logout", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stage(self, seqid, iprot, oprot):
    args = stage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stage_result()
    try:
      result.success = self._handler.stage(args.token, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("stage", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_insertJson(self, seqid, iprot, oprot):
    args = insertJson_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = insertJson_result()
    try:
      result.success = self._handler.insertJson(args.json, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("insertJson", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_insertJsonRecord(self, seqid, iprot, oprot):
    args = insertJsonRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = insertJsonRecord_result()
    try:
      result.success = self._handler.insertJsonRecord(args.json, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("insertJsonRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_insertJsonRecords(self, seqid, iprot, oprot):
    args = insertJsonRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = insertJsonRecords_result()
    try:
      result.success = self._handler.insertJsonRecords(args.json, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("insertJsonRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_removeKeyValueRecord(self, seqid, iprot, oprot):
    args = removeKeyValueRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeKeyValueRecord_result()
    try:
      result.success = self._handler.removeKeyValueRecord(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("removeKeyValueRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_removeKeyValueRecords(self, seqid, iprot, oprot):
    args = removeKeyValueRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeKeyValueRecords_result()
    try:
      result.success = self._handler.removeKeyValueRecords(args.key, args.value, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("removeKeyValueRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setKeyValueRecord(self, seqid, iprot, oprot):
    args = setKeyValueRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setKeyValueRecord_result()
    try:
      self._handler.setKeyValueRecord(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("setKeyValueRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setKeyValue(self, seqid, iprot, oprot):
    args = setKeyValue_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setKeyValue_result()
    try:
      result.success = self._handler.setKeyValue(args.key, args.value, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("setKeyValue", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setKeyValueRecords(self, seqid, iprot, oprot):
    args = setKeyValueRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setKeyValueRecords_result()
    try:
      self._handler.setKeyValueRecords(args.key, args.value, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("setKeyValueRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_reconcileKeyRecordValues(self, seqid, iprot, oprot):
    args = reconcileKeyRecordValues_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = reconcileKeyRecordValues_result()
    try:
      self._handler.reconcileKeyRecordValues(args.key, args.record, args.values, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("reconcileKeyRecordValues", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_inventory(self, seqid, iprot, oprot):
    args = inventory_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = inventory_result()
    try:
      result.success = self._handler.inventory(args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("inventory", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecord(self, seqid, iprot, oprot):
    args = selectRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecord_result()
    try:
      result.success = self._handler.selectRecord(args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecords(self, seqid, iprot, oprot):
    args = selectRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecords_result()
    try:
      result.success = self._handler.selectRecords(args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecordTime(self, seqid, iprot, oprot):
    args = selectRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecordTime_result()
    try:
      result.success = self._handler.selectRecordTime(args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecordTimestr(self, seqid, iprot, oprot):
    args = selectRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecordTimestr_result()
    try:
      result.success = self._handler.selectRecordTimestr(args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecordsTime(self, seqid, iprot, oprot):
    args = selectRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecordsTime_result()
    try:
      result.success = self._handler.selectRecordsTime(args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecordsTimestr(self, seqid, iprot, oprot):
    args = selectRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecordsTimestr_result()
    try:
      result.success = self._handler.selectRecordsTimestr(args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecord(self, seqid, iprot, oprot):
    args = selectKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecord_result()
    try:
      result.success = self._handler.selectKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecordTime(self, seqid, iprot, oprot):
    args = selectKeyRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecordTime_result()
    try:
      result.success = self._handler.selectKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecordTimestr(self, seqid, iprot, oprot):
    args = selectKeyRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecordTimestr_result()
    try:
      result.success = self._handler.selectKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecord(self, seqid, iprot, oprot):
    args = selectKeysRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecord_result()
    try:
      result.success = self._handler.selectKeysRecord(args.keys, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecordTime(self, seqid, iprot, oprot):
    args = selectKeysRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecordTime_result()
    try:
      result.success = self._handler.selectKeysRecordTime(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecordTimestr(self, seqid, iprot, oprot):
    args = selectKeysRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecordTimestr_result()
    try:
      result.success = self._handler.selectKeysRecordTimestr(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecords(self, seqid, iprot, oprot):
    args = selectKeysRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecords_result()
    try:
      result.success = self._handler.selectKeysRecords(args.keys, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecords(self, seqid, iprot, oprot):
    args = selectKeyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecords_result()
    try:
      result.success = self._handler.selectKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecordsTime(self, seqid, iprot, oprot):
    args = selectKeyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecordsTime_result()
    try:
      result.success = self._handler.selectKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecordsTimestr(self, seqid, iprot, oprot):
    args = selectKeyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecordsTimestr_result()
    try:
      result.success = self._handler.selectKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecordsTime(self, seqid, iprot, oprot):
    args = selectKeysRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecordsTime_result()
    try:
      result.success = self._handler.selectKeysRecordsTime(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecordsTimestr(self, seqid, iprot, oprot):
    args = selectKeysRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecordsTimestr_result()
    try:
      result.success = self._handler.selectKeysRecordsTimestr(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCriteria(self, seqid, iprot, oprot):
    args = selectCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCriteria_result()
    try:
      result.success = self._handler.selectCriteria(args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCcl(self, seqid, iprot, oprot):
    args = selectCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCcl_result()
    try:
      result.success = self._handler.selectCcl(args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCriteriaTime(self, seqid, iprot, oprot):
    args = selectCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCriteriaTime_result()
    try:
      result.success = self._handler.selectCriteriaTime(args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCriteriaTimestr(self, seqid, iprot, oprot):
    args = selectCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCriteriaTimestr_result()
    try:
      result.success = self._handler.selectCriteriaTimestr(args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCclTime(self, seqid, iprot, oprot):
    args = selectCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCclTime_result()
    try:
      result.success = self._handler.selectCclTime(args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCclTimestr(self, seqid, iprot, oprot):
    args = selectCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCclTimestr_result()
    try:
      result.success = self._handler.selectCclTimestr(args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCriteria(self, seqid, iprot, oprot):
    args = selectKeyCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCriteria_result()
    try:
      result.success = self._handler.selectKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCcl(self, seqid, iprot, oprot):
    args = selectKeyCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCcl_result()
    try:
      result.success = self._handler.selectKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCriteriaTime(self, seqid, iprot, oprot):
    args = selectKeyCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCriteriaTime_result()
    try:
      result.success = self._handler.selectKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCriteriaTimestr(self, seqid, iprot, oprot):
    args = selectKeyCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCriteriaTimestr_result()
    try:
      result.success = self._handler.selectKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCclTime(self, seqid, iprot, oprot):
    args = selectKeyCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCclTime_result()
    try:
      result.success = self._handler.selectKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCclTimestr(self, seqid, iprot, oprot):
    args = selectKeyCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCclTimestr_result()
    try:
      result.success = self._handler.selectKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCriteria(self, seqid, iprot, oprot):
    args = selectKeysCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCriteria_result()
    try:
      result.success = self._handler.selectKeysCriteria(args.keys, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCcl(self, seqid, iprot, oprot):
    args = selectKeysCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCcl_result()
    try:
      result.success = self._handler.selectKeysCcl(args.keys, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCriteriaTime(self, seqid, iprot, oprot):
    args = selectKeysCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCriteriaTime_result()
    try:
      result.success = self._handler.selectKeysCriteriaTime(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCriteriaTimestr(self, seqid, iprot, oprot):
    args = selectKeysCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCriteriaTimestr_result()
    try:
      result.success = self._handler.selectKeysCriteriaTimestr(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCclTime(self, seqid, iprot, oprot):
    args = selectKeysCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCclTime_result()
    try:
      result.success = self._handler.selectKeysCclTime(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCclTimestr(self, seqid, iprot, oprot):
    args = selectKeysCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCclTimestr_result()
    try:
      result.success = self._handler.selectKeysCclTimestr(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecord(self, seqid, iprot, oprot):
    args = getKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecord_result()
    try:
      result.success = self._handler.getKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecordTime(self, seqid, iprot, oprot):
    args = getKeyRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecordTime_result()
    try:
      result.success = self._handler.getKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecordTimestr(self, seqid, iprot, oprot):
    args = getKeyRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecordTimestr_result()
    try:
      result.success = self._handler.getKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecord(self, seqid, iprot, oprot):
    args = getKeysRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecord_result()
    try:
      result.success = self._handler.getKeysRecord(args.keys, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecordTime(self, seqid, iprot, oprot):
    args = getKeysRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecordTime_result()
    try:
      result.success = self._handler.getKeysRecordTime(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecordTimestr(self, seqid, iprot, oprot):
    args = getKeysRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecordTimestr_result()
    try:
      result.success = self._handler.getKeysRecordTimestr(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecords(self, seqid, iprot, oprot):
    args = getKeysRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecords_result()
    try:
      result.success = self._handler.getKeysRecords(args.keys, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecords(self, seqid, iprot, oprot):
    args = getKeyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecords_result()
    try:
      result.success = self._handler.getKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecordsTime(self, seqid, iprot, oprot):
    args = getKeyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecordsTime_result()
    try:
      result.success = self._handler.getKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecordsTimestr(self, seqid, iprot, oprot):
    args = getKeyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecordsTimestr_result()
    try:
      result.success = self._handler.getKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecordsTime(self, seqid, iprot, oprot):
    args = getKeysRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecordsTime_result()
    try:
      result.success = self._handler.getKeysRecordsTime(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecordsTimestr(self, seqid, iprot, oprot):
    args = getKeysRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecordsTimestr_result()
    try:
      result.success = self._handler.getKeysRecordsTimestr(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCriteria(self, seqid, iprot, oprot):
    args = getKeyCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCriteria_result()
    try:
      result.success = self._handler.getKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCriteria(self, seqid, iprot, oprot):
    args = getCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCriteria_result()
    try:
      result.success = self._handler.getCriteria(args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCcl(self, seqid, iprot, oprot):
    args = getCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCcl_result()
    try:
      result.success = self._handler.getCcl(args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCriteriaTime(self, seqid, iprot, oprot):
    args = getCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCriteriaTime_result()
    try:
      result.success = self._handler.getCriteriaTime(args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCriteriaTimestr(self, seqid, iprot, oprot):
    args = getCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCriteriaTimestr_result()
    try:
      result.success = self._handler.getCriteriaTimestr(args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCclTime(self, seqid, iprot, oprot):
    args = getCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCclTime_result()
    try:
      result.success = self._handler.getCclTime(args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCclTimestr(self, seqid, iprot, oprot):
    args = getCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCclTimestr_result()
    try:
      result.success = self._handler.getCclTimestr(args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCcl(self, seqid, iprot, oprot):
    args = getKeyCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCcl_result()
    try:
      result.success = self._handler.getKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCriteriaTime(self, seqid, iprot, oprot):
    args = getKeyCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCriteriaTime_result()
    try:
      result.success = self._handler.getKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCriteriaTimestr(self, seqid, iprot, oprot):
    args = getKeyCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCriteriaTimestr_result()
    try:
      result.success = self._handler.getKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCclTime(self, seqid, iprot, oprot):
    args = getKeyCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCclTime_result()
    try:
      result.success = self._handler.getKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCclTimestr(self, seqid, iprot, oprot):
    args = getKeyCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCclTimestr_result()
    try:
      result.success = self._handler.getKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCriteria(self, seqid, iprot, oprot):
    args = getKeysCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCriteria_result()
    try:
      result.success = self._handler.getKeysCriteria(args.keys, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCcl(self, seqid, iprot, oprot):
    args = getKeysCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCcl_result()
    try:
      result.success = self._handler.getKeysCcl(args.keys, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCriteriaTime(self, seqid, iprot, oprot):
    args = getKeysCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCriteriaTime_result()
    try:
      result.success = self._handler.getKeysCriteriaTime(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCriteriaTimestr(self, seqid, iprot, oprot):
    args = getKeysCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCriteriaTimestr_result()
    try:
      result.success = self._handler.getKeysCriteriaTimestr(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCclTime(self, seqid, iprot, oprot):
    args = getKeysCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCclTime_result()
    try:
      result.success = self._handler.getKeysCclTime(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCclTimestr(self, seqid, iprot, oprot):
    args = getKeysCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCclTimestr_result()
    try:
      result.success = self._handler.getKeysCclTimestr(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_verifyKeyValueRecord(self, seqid, iprot, oprot):
    args = verifyKeyValueRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = verifyKeyValueRecord_result()
    try:
      result.success = self._handler.verifyKeyValueRecord(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("verifyKeyValueRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_verifyKeyValueRecordTime(self, seqid, iprot, oprot):
    args = verifyKeyValueRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = verifyKeyValueRecordTime_result()
    try:
      result.success = self._handler.verifyKeyValueRecordTime(args.key, args.value, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("verifyKeyValueRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_verifyKeyValueRecordTimestr(self, seqid, iprot, oprot):
    args = verifyKeyValueRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = verifyKeyValueRecordTimestr_result()
    try:
      result.success = self._handler.verifyKeyValueRecordTimestr(args.key, args.value, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("verifyKeyValueRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_jsonifyRecords(self, seqid, iprot, oprot):
    args = jsonifyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = jsonifyRecords_result()
    try:
      result.success = self._handler.jsonifyRecords(args.records, args.identifier, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("jsonifyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_jsonifyRecordsTime(self, seqid, iprot, oprot):
    args = jsonifyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = jsonifyRecordsTime_result()
    try:
      result.success = self._handler.jsonifyRecordsTime(args.records, args.timestamp, args.identifier, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("jsonifyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_jsonifyRecordsTimestr(self, seqid, iprot, oprot):
    args = jsonifyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = jsonifyRecordsTimestr_result()
    try:
      result.success = self._handler.jsonifyRecordsTimestr(args.records, args.timestamp, args.identifier, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("jsonifyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findCriteria(self, seqid, iprot, oprot):
    args = findCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findCriteria_result()
    try:
      result.success = self._handler.findCriteria(args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findCcl(self, seqid, iprot, oprot):
    args = findCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findCcl_result()
    try:
      result.success = self._handler.findCcl(args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorValues(self, seqid, iprot, oprot):
    args = findKeyOperatorValues_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorValues_result()
    try:
      result.success = self._handler.findKeyOperatorValues(args.key, args.operator, args.values, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorValues", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorValuesTime(self, seqid, iprot, oprot):
    args = findKeyOperatorValuesTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorValuesTime_result()
    try:
      result.success = self._handler.findKeyOperatorValuesTime(args.key, args.operator, args.values, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorValuesTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorValuesTimestr(self, seqid, iprot, oprot):
    args = findKeyOperatorValuesTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorValuesTimestr_result()
    try:
      result.success = self._handler.findKeyOperatorValuesTimestr(args.key, args.operator, args.values, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorValuesTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorstrValues(self, seqid, iprot, oprot):
    args = findKeyOperatorstrValues_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorstrValues_result()
    try:
      result.success = self._handler.findKeyOperatorstrValues(args.key, args.operator, args.values, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorstrValues", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorstrValuesTime(self, seqid, iprot, oprot):
    args = findKeyOperatorstrValuesTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorstrValuesTime_result()
    try:
      result.success = self._handler.findKeyOperatorstrValuesTime(args.key, args.operator, args.values, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorstrValuesTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorstrValuesTimestr(self, seqid, iprot, oprot):
    args = findKeyOperatorstrValuesTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorstrValuesTimestr_result()
    try:
      result.success = self._handler.findKeyOperatorstrValuesTimestr(args.key, args.operator, args.values, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorstrValuesTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_search(self, seqid, iprot, oprot):
    args = search_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = search_result()
    try:
      result.success = self._handler.search(args.key, args.query, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("search", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeysRecordsTime(self, seqid, iprot, oprot):
    args = revertKeysRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeysRecordsTime_result()
    try:
      self._handler.revertKeysRecordsTime(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeysRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeysRecordsTimestr(self, seqid, iprot, oprot):
    args = revertKeysRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeysRecordsTimestr_result()
    try:
      self._handler.revertKeysRecordsTimestr(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeysRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeysRecordTime(self, seqid, iprot, oprot):
    args = revertKeysRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeysRecordTime_result()
    try:
      self._handler.revertKeysRecordTime(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeysRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeysRecordTimestr(self, seqid, iprot, oprot):
    args = revertKeysRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeysRecordTimestr_result()
    try:
      self._handler.revertKeysRecordTimestr(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeysRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeyRecordsTime(self, seqid, iprot, oprot):
    args = revertKeyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeyRecordsTime_result()
    try:
      self._handler.revertKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeyRecordsTimestr(self, seqid, iprot, oprot):
    args = revertKeyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeyRecordsTimestr_result()
    try:
      self._handler.revertKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeyRecordTime(self, seqid, iprot, oprot):
    args = revertKeyRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeyRecordTime_result()
    try:
      self._handler.revertKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeyRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeyRecordTimestr(self, seqid, iprot, oprot):
    args = revertKeyRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeyRecordTimestr_result()
    try:
      self._handler.revertKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeyRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_pingRecords(self, seqid, iprot, oprot):
    args = pingRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = pingRecords_result()
    try:
      result.success = self._handler.pingRecords(args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("pingRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_pingRecord(self, seqid, iprot, oprot):
    args = pingRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = pingRecord_result()
    try:
      result.success = self._handler.pingRecord(args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("pingRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_verifyAndSwap(self, seqid, iprot, oprot):
    args = verifyAndSwap_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = verifyAndSwap_result()
    try:
      result.success = self._handler.verifyAndSwap(args.key, args.expected, args.record, args.replacement, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("verifyAndSwap", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_verifyOrSet(self, seqid, iprot, oprot):
    args = verifyOrSet_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = verifyOrSet_result()
    try:
      self._handler.verifyOrSet(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("verifyOrSet", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findOrAddKeyValue(self, seqid, iprot, oprot):
    args = findOrAddKeyValue_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findOrAddKeyValue_result()
    try:
      result.success = self._handler.findOrAddKeyValue(args.key, args.value, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except DuplicateEntryException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except InvalidArgumentException as ex4:
      msg_type = TMessageType.REPLY
      result.ex4 = ex4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findOrAddKeyValue", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findOrInsertCriteriaJson(self, seqid, iprot, oprot):
    args = findOrInsertCriteriaJson_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findOrInsertCriteriaJson_result()
    try:
      result.success = self._handler.findOrInsertCriteriaJson(args.criteria, args.json, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except DuplicateEntryException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findOrInsertCriteriaJson", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findOrInsertCclJson(self, seqid, iprot, oprot):
    args = findOrInsertCclJson_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findOrInsertCclJson_result()
    try:
      result.success = self._handler.findOrInsertCclJson(args.ccl, args.json, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except DuplicateEntryException as ex4:
      msg_type = TMessageType.REPLY
      result.ex4 = ex4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findOrInsertCclJson", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getServerEnvironment(self, seqid, iprot, oprot):
    args = getServerEnvironment_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getServerEnvironment_result()
    try:
      result.success = self._handler.getServerEnvironment(args.creds, args.token, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getServerEnvironment", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getServerVersion(self, seqid, iprot, oprot):
    args = getServerVersion_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getServerVersion_result()
    try:
      result.success = self._handler.getServerVersion()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getServerVersion", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time(self, seqid, iprot, oprot):
    args = time_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time_result()
    try:
      result.success = self._handler.time(args.creds, args.token, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("time", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_timePhrase(self, seqid, iprot, oprot):
    args = timePhrase_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = timePhrase_result()
    try:
      result.success = self._handler.timePhrase(args.phrase, args.creds, args.token, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("timePhrase", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class abort_args:
  """
  Attributes:
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, creds=None, transaction=None, environment=None,):
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abort_args')
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 1)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 2)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abort_result:
  """
  Attributes:
   - ex
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, ex=None,):
    self.ex = ex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abort_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValue_args:
  """
  Attributes:
   - key
   - value
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, value=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValue_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValue_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValue_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValueRecord_args:
  """
  Attributes:
   - key
   - value
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValueRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValueRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValueRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValueRecords_args:
  """
  Attributes:
   - key
   - value
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.LIST, 'records', (TType.I64,None), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.records = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in range(_size0):
            _elem5 = iprot.readI64()
            self.records.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValueRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter6 in self.records:
        oprot.writeI64(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValueRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.BOOL,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin()
          for _i11 in range(_size7):
            _key12 = iprot.readI64()
            _val13 = iprot.readBool()
            self.success[_key12] = _val13
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValueRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.BOOL, len(self.success))
      for kiter14,viter15 in list(self.success.items()):
        oprot.writeI64(kiter14)
        oprot.writeBool(viter15)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecord_args:
  """
  Attributes:
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, record=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype17, _vtype18, _size16 ) = iprot.readMapBegin()
          for _i20 in range(_size16):
            _key21 = iprot.readI64()
            _val22 = iprot.readString()
            self.success[_key21] = _val22
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter23,viter24 in list(self.success.items()):
        oprot.writeI64(kiter23)
        oprot.writeString(viter24)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStart_args:
  """
  Attributes:
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStart_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype26, _vtype27, _size25 ) = iprot.readMapBegin()
          for _i29 in range(_size25):
            _key30 = iprot.readI64()
            _val31 = iprot.readString()
            self.success[_key30] = _val31
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter32,viter33 in list(self.success.items()):
        oprot.writeI64(kiter32)
        oprot.writeString(viter33)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartstr_args:
  """
  Attributes:
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartstr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype35, _vtype36, _size34 ) = iprot.readMapBegin()
          for _i38 in range(_size34):
            _key39 = iprot.readI64()
            _val40 = iprot.readString()
            self.success[_key39] = _val40
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter41,viter42 in list(self.success.items()):
        oprot.writeI64(kiter41)
        oprot.writeString(viter42)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartEnd_args:
  """
  Attributes:
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.I64, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartEnd_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 3)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype44, _vtype45, _size43 ) = iprot.readMapBegin()
          for _i47 in range(_size43):
            _key48 = iprot.readI64()
            _val49 = iprot.readString()
            self.success[_key48] = _val49
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter50,viter51 in list(self.success.items()):
        oprot.writeI64(kiter50)
        oprot.writeString(viter51)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartstrEndstr_args:
  """
  Attributes:
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRING, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartstrEndstr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 3)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype53, _vtype54, _size52 ) = iprot.readMapBegin()
          for _i56 in range(_size52):
            _key57 = iprot.readI64()
            _val58 = iprot.readString()
            self.success[_key57] = _val58
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter59,viter60 in list(self.success.items()):
        oprot.writeI64(kiter59)
        oprot.writeString(viter60)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype62, _vtype63, _size61 ) = iprot.readMapBegin()
          for _i65 in range(_size61):
            _key66 = iprot.readI64()
            _val67 = iprot.readString()
            self.success[_key66] = _val67
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter68,viter69 in list(self.success.items()):
        oprot.writeI64(kiter68)
        oprot.writeString(viter69)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStart_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStart_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype71, _vtype72, _size70 ) = iprot.readMapBegin()
          for _i74 in range(_size70):
            _key75 = iprot.readI64()
            _val76 = iprot.readString()
            self.success[_key75] = _val76
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter77,viter78 in list(self.success.items()):
        oprot.writeI64(kiter77)
        oprot.writeString(viter78)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype80, _vtype81, _size79 ) = iprot.readMapBegin()
          for _i83 in range(_size79):
            _key84 = iprot.readI64()
            _val85 = iprot.readString()
            self.success[_key84] = _val85
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter86,viter87 in list(self.success.items()):
        oprot.writeI64(kiter86)
        oprot.writeString(viter87)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartEnd_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.I64, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartEnd_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 4)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype89, _vtype90, _size88 ) = iprot.readMapBegin()
          for _i92 in range(_size88):
            _key93 = iprot.readI64()
            _val94 = iprot.readString()
            self.success[_key93] = _val94
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter95,viter96 in list(self.success.items()):
        oprot.writeI64(kiter95)
        oprot.writeString(viter96)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartstrEndstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRING, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartstrEndstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 4)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype98, _vtype99, _size97 ) = iprot.readMapBegin()
          for _i101 in range(_size97):
            _key102 = iprot.readI64()
            _val103 = iprot.readString()
            self.success[_key102] = _val103
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter104,viter105 in list(self.success.items()):
        oprot.writeI64(kiter104)
        oprot.writeString(viter105)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKey_args:
  """
  Attributes:
   - key
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, key=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKey_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKey_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype107, _vtype108, _size106 ) = iprot.readMapBegin()
          for _i110 in range(_size106):
            _key111 = TObject()
            _key111.read(iprot)
            _val112 = []
            (_etype116, _size113) = iprot.readSetBegin()
            for _i117 in range(_size113):
              _elem118 = iprot.readI64()
              _val112.append(_elem118)
            iprot.readSetEnd()
            self.success[_key111] = _val112
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKey_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.SET, len(self.success))
      for kiter119,viter120 in list(self.success.items()):
        kiter119.write(oprot)
        oprot.writeSetBegin(TType.I64, len(viter120))
        for iter121 in viter120:
          oprot.writeI64(iter121)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeys_args:
  """
  Attributes:
   - keys
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, keys=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype125, _size122) = iprot.readListBegin()
          for _i126 in range(_size122):
            _elem127 = iprot.readString()
            self.keys.append(_elem127)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeys_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter128 in self.keys:
        oprot.writeString(iter128)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeys_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype130, _vtype131, _size129 ) = iprot.readMapBegin()
          for _i133 in range(_size129):
            _key134 = iprot.readString()
            _val135 = {}
            (_ktype137, _vtype138, _size136 ) = iprot.readMapBegin()
            for _i140 in range(_size136):
              _key141 = TObject()
              _key141.read(iprot)
              _val142 = []
              (_etype146, _size143) = iprot.readSetBegin()
              for _i147 in range(_size143):
                _elem148 = iprot.readI64()
                _val142.append(_elem148)
              iprot.readSetEnd()
              _val135[_key141] = _val142
            iprot.readMapEnd()
            self.success[_key134] = _val135
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeys_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter149,viter150 in list(self.success.items()):
        oprot.writeString(kiter149)
        oprot.writeMapBegin(TType.STRUCT, TType.SET, len(viter150))
        for kiter151,viter152 in list(viter150.items()):
          kiter151.write(oprot)
          oprot.writeSetBegin(TType.I64, len(viter152))
          for iter153 in viter152:
            oprot.writeI64(iter153)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeyTime_args:
  """
  Attributes:
   - key
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeyTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeyTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype155, _vtype156, _size154 ) = iprot.readMapBegin()
          for _i158 in range(_size154):
            _key159 = TObject()
            _key159.read(iprot)
            _val160 = []
            (_etype164, _size161) = iprot.readSetBegin()
            for _i165 in range(_size161):
              _elem166 = iprot.readI64()
              _val160.append(_elem166)
            iprot.readSetEnd()
            self.success[_key159] = _val160
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeyTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.SET, len(self.success))
      for kiter167,viter168 in list(self.success.items()):
        kiter167.write(oprot)
        oprot.writeSetBegin(TType.I64, len(viter168))
        for iter169 in viter168:
          oprot.writeI64(iter169)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeyTimestr_args:
  """
  Attributes:
   - key
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeyTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeyTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype171, _vtype172, _size170 ) = iprot.readMapBegin()
          for _i174 in range(_size170):
            _key175 = TObject()
            _key175.read(iprot)
            _val176 = []
            (_etype180, _size177) = iprot.readSetBegin()
            for _i181 in range(_size177):
              _elem182 = iprot.readI64()
              _val176.append(_elem182)
            iprot.readSetEnd()
            self.success[_key175] = _val176
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeyTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.SET, len(self.success))
      for kiter183,viter184 in list(self.success.items()):
        kiter183.write(oprot)
        oprot.writeSetBegin(TType.I64, len(viter184))
        for iter185 in viter184:
          oprot.writeI64(iter185)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeysTime_args:
  """
  Attributes:
   - keys
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype189, _size186) = iprot.readListBegin()
          for _i190 in range(_size186):
            _elem191 = iprot.readString()
            self.keys.append(_elem191)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeysTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter192 in self.keys:
        oprot.writeString(iter192)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeysTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype194, _vtype195, _size193 ) = iprot.readMapBegin()
          for _i197 in range(_size193):
            _key198 = iprot.readString()
            _val199 = {}
            (_ktype201, _vtype202, _size200 ) = iprot.readMapBegin()
            for _i204 in range(_size200):
              _key205 = TObject()
              _key205.read(iprot)
              _val206 = []
              (_etype210, _size207) = iprot.readSetBegin()
              for _i211 in range(_size207):
                _elem212 = iprot.readI64()
                _val206.append(_elem212)
              iprot.readSetEnd()
              _val199[_key205] = _val206
            iprot.readMapEnd()
            self.success[_key198] = _val199
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeysTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter213,viter214 in list(self.success.items()):
        oprot.writeString(kiter213)
        oprot.writeMapBegin(TType.STRUCT, TType.SET, len(viter214))
        for kiter215,viter216 in list(viter214.items()):
          kiter215.write(oprot)
          oprot.writeSetBegin(TType.I64, len(viter216))
          for iter217 in viter216:
            oprot.writeI64(iter217)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeysTimestr_args:
  """
  Attributes:
   - keys
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype221, _size218) = iprot.readListBegin()
          for _i222 in range(_size218):
            _elem223 = iprot.readString()
            self.keys.append(_elem223)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeysTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter224 in self.keys:
        oprot.writeString(iter224)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeysTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype226, _vtype227, _size225 ) = iprot.readMapBegin()
          for _i229 in range(_size225):
            _key230 = iprot.readString()
            _val231 = {}
            (_ktype233, _vtype234, _size232 ) = iprot.readMapBegin()
            for _i236 in range(_size232):
              _key237 = TObject()
              _key237.read(iprot)
              _val238 = []
              (_etype242, _size239) = iprot.readSetBegin()
              for _i243 in range(_size239):
                _elem244 = iprot.readI64()
                _val238.append(_elem244)
              iprot.readSetEnd()
              _val231[_key237] = _val238
            iprot.readMapEnd()
            self.success[_key230] = _val231
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeysTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter245,viter246 in list(self.success.items()):
        oprot.writeString(kiter245)
        oprot.writeMapBegin(TType.STRUCT, TType.SET, len(viter246))
        for kiter247,viter248 in list(viter246.items()):
          kiter247.write(oprot)
          oprot.writeSetBegin(TType.I64, len(viter248))
          for iter249 in viter248:
            oprot.writeI64(iter249)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype251, _vtype252, _size250 ) = iprot.readMapBegin()
          for _i254 in range(_size250):
            _key255 = iprot.readI64()
            _val256 = []
            (_etype260, _size257) = iprot.readSetBegin()
            for _i261 in range(_size257):
              _elem262 = TObject()
              _elem262.read(iprot)
              _val256.append(_elem262)
            iprot.readSetEnd()
            self.success[_key255] = _val256
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter263,viter264 in list(self.success.items()):
        oprot.writeI64(kiter263)
        oprot.writeSetBegin(TType.STRUCT, len(viter264))
        for iter265 in viter264:
          iter265.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStart_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStart_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype267, _vtype268, _size266 ) = iprot.readMapBegin()
          for _i270 in range(_size266):
            _key271 = iprot.readI64()
            _val272 = []
            (_etype276, _size273) = iprot.readSetBegin()
            for _i277 in range(_size273):
              _elem278 = TObject()
              _elem278.read(iprot)
              _val272.append(_elem278)
            iprot.readSetEnd()
            self.success[_key271] = _val272
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter279,viter280 in list(self.success.items()):
        oprot.writeI64(kiter279)
        oprot.writeSetBegin(TType.STRUCT, len(viter280))
        for iter281 in viter280:
          iter281.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype283, _vtype284, _size282 ) = iprot.readMapBegin()
          for _i286 in range(_size282):
            _key287 = iprot.readI64()
            _val288 = []
            (_etype292, _size289) = iprot.readSetBegin()
            for _i293 in range(_size289):
              _elem294 = TObject()
              _elem294.read(iprot)
              _val288.append(_elem294)
            iprot.readSetEnd()
            self.success[_key287] = _val288
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter295,viter296 in list(self.success.items()):
        oprot.writeI64(kiter295)
        oprot.writeSetBegin(TType.STRUCT, len(viter296))
        for iter297 in viter296:
          iter297.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartEnd_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.I64, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartEnd_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 4)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype299, _vtype300, _size298 ) = iprot.readMapBegin()
          for _i302 in range(_size298):
            _key303 = iprot.readI64()
            _val304 = []
            (_etype308, _size305) = iprot.readSetBegin()
            for _i309 in range(_size305):
              _elem310 = TObject()
              _elem310.read(iprot)
              _val304.append(_elem310)
            iprot.readSetEnd()
            self.success[_key303] = _val304
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter311,viter312 in list(self.success.items()):
        oprot.writeI64(kiter311)
        oprot.writeSetBegin(TType.STRUCT, len(viter312))
        for iter313 in viter312:
          iter313.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartstrEndstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRING, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartstrEndstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 4)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype315, _vtype316, _size314 ) = iprot.readMapBegin()
          for _i318 in range(_size314):
            _key319 = iprot.readI64()
            _val320 = []
            (_etype324, _size321) = iprot.readSetBegin()
            for _i325 in range(_size321):
              _elem326 = TObject()
              _elem326.read(iprot)
              _val320.append(_elem326)
            iprot.readSetEnd()
            self.success[_key319] = _val320
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter327,viter328 in list(self.success.items()):
        oprot.writeI64(kiter327)
        oprot.writeSetBegin(TType.STRUCT, len(viter328))
        for iter329 in viter328:
          iter329.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearRecord_args:
  """
  Attributes:
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, record=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearRecord_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearRecord_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearRecords_args:
  """
  Attributes:
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, records=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype333, _size330) = iprot.readListBegin()
          for _i334 in range(_size330):
            _elem335 = iprot.readI64()
            self.records.append(_elem335)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearRecords_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter336 in self.records:
        oprot.writeI64(iter336)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearRecords_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearRecords_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeyRecord_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeyRecord_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeysRecord_args:
  """
  Attributes:
   - keys
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, record=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype340, _size337) = iprot.readListBegin()
          for _i341 in range(_size337):
            _elem342 = iprot.readString()
            self.keys.append(_elem342)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeysRecord_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter343 in self.keys:
        oprot.writeString(iter343)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeysRecord_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeysRecord_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeyRecords_args:
  """
  Attributes:
   - key
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype347, _size344) = iprot.readListBegin()
          for _i348 in range(_size344):
            _elem349 = iprot.readI64()
            self.records.append(_elem349)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeyRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter350 in self.records:
        oprot.writeI64(iter350)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeyRecords_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeyRecords_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeysRecords_args:
  """
  Attributes:
   - keys
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, records=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype354, _size351) = iprot.readListBegin()
          for _i355 in range(_size351):
            _elem356 = iprot.readString()
            self.keys.append(_elem356)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype360, _size357) = iprot.readListBegin()
          for _i361 in range(_size357):
            _elem362 = iprot.readI64()
            self.records.append(_elem362)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeysRecords_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter363 in self.keys:
        oprot.writeString(iter363)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter364 in self.records:
        oprot.writeI64(iter364)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeysRecords_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeysRecords_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commit_args:
  """
  Attributes:
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, creds=None, transaction=None, environment=None,):
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commit_args')
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 1)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 2)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commit_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecord_args:
  """
  Attributes:
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, record=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype368, _size365) = iprot.readSetBegin()
          for _i369 in range(_size365):
            _elem370 = iprot.readString()
            self.success.append(_elem370)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter371 in self.success:
        oprot.writeString(iter371)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordTime_args:
  """
  Attributes:
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordTime_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype375, _size372) = iprot.readSetBegin()
          for _i376 in range(_size372):
            _elem377 = iprot.readString()
            self.success.append(_elem377)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter378 in self.success:
        oprot.writeString(iter378)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordTimestr_args:
  """
  Attributes:
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordTimestr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype382, _size379) = iprot.readSetBegin()
          for _i383 in range(_size379):
            _elem384 = iprot.readString()
            self.success.append(_elem384)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter385 in self.success:
        oprot.writeString(iter385)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecords_args:
  """
  Attributes:
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, records=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype389, _size386) = iprot.readListBegin()
          for _i390 in range(_size386):
            _elem391 = iprot.readI64()
            self.records.append(_elem391)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecords_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter392 in self.records:
        oprot.writeI64(iter392)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype394, _vtype395, _size393 ) = iprot.readMapBegin()
          for _i397 in range(_size393):
            _key398 = iprot.readI64()
            _val399 = []
            (_etype403, _size400) = iprot.readSetBegin()
            for _i404 in range(_size400):
              _elem405 = iprot.readString()
              _val399.append(_elem405)
            iprot.readSetEnd()
            self.success[_key398] = _val399
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter406,viter407 in list(self.success.items()):
        oprot.writeI64(kiter406)
        oprot.writeSetBegin(TType.STRING, len(viter407))
        for iter408 in viter407:
          oprot.writeString(iter408)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordsTime_args:
  """
  Attributes:
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype412, _size409) = iprot.readListBegin()
          for _i413 in range(_size409):
            _elem414 = iprot.readI64()
            self.records.append(_elem414)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordsTime_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter415 in self.records:
        oprot.writeI64(iter415)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype417, _vtype418, _size416 ) = iprot.readMapBegin()
          for _i420 in range(_size416):
            _key421 = iprot.readI64()
            _val422 = []
            (_etype426, _size423) = iprot.readSetBegin()
            for _i427 in range(_size423):
              _elem428 = iprot.readString()
              _val422.append(_elem428)
            iprot.readSetEnd()
            self.success[_key421] = _val422
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter429,viter430 in list(self.success.items()):
        oprot.writeI64(kiter429)
        oprot.writeSetBegin(TType.STRING, len(viter430))
        for iter431 in viter430:
          oprot.writeString(iter431)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordsTimestr_args:
  """
  Attributes:
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype435, _size432) = iprot.readListBegin()
          for _i436 in range(_size432):
            _elem437 = iprot.readI64()
            self.records.append(_elem437)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordsTimestr_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter438 in self.records:
        oprot.writeI64(iter438)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype440, _vtype441, _size439 ) = iprot.readMapBegin()
          for _i443 in range(_size439):
            _key444 = iprot.readI64()
            _val445 = []
            (_etype449, _size446) = iprot.readSetBegin()
            for _i450 in range(_size446):
              _elem451 = iprot.readString()
              _val445.append(_elem451)
            iprot.readSetEnd()
            self.success[_key444] = _val445
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter452,viter453 in list(self.success.items()):
        oprot.writeI64(kiter452)
        oprot.writeSetBegin(TType.STRING, len(viter453))
        for iter454 in viter453:
          oprot.writeString(iter454)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStart_args:
  """
  Attributes:
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStart_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype456, _vtype457, _size455 ) = iprot.readMapBegin()
          for _i459 in range(_size455):
            _key460 = iprot.readString()
            _val461 = {}
            (_ktype463, _vtype464, _size462 ) = iprot.readMapBegin()
            for _i466 in range(_size462):
              _key467 = iprot.readI32()
              _val468 = []
              (_etype472, _size469) = iprot.readSetBegin()
              for _i473 in range(_size469):
                _elem474 = TObject()
                _elem474.read(iprot)
                _val468.append(_elem474)
              iprot.readSetEnd()
              _val461[_key467] = _val468
            iprot.readMapEnd()
            self.success[_key460] = _val461
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter475,viter476 in list(self.success.items()):
        oprot.writeString(kiter475)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter476))
        for kiter477,viter478 in list(viter476.items()):
          oprot.writeI32(kiter477)
          oprot.writeSetBegin(TType.STRUCT, len(viter478))
          for iter479 in viter478:
            iter479.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartstr_args:
  """
  Attributes:
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartstr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype481, _vtype482, _size480 ) = iprot.readMapBegin()
          for _i484 in range(_size480):
            _key485 = iprot.readString()
            _val486 = {}
            (_ktype488, _vtype489, _size487 ) = iprot.readMapBegin()
            for _i491 in range(_size487):
              _key492 = iprot.readI32()
              _val493 = []
              (_etype497, _size494) = iprot.readSetBegin()
              for _i498 in range(_size494):
                _elem499 = TObject()
                _elem499.read(iprot)
                _val493.append(_elem499)
              iprot.readSetEnd()
              _val486[_key492] = _val493
            iprot.readMapEnd()
            self.success[_key485] = _val486
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter500,viter501 in list(self.success.items()):
        oprot.writeString(kiter500)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter501))
        for kiter502,viter503 in list(viter501.items()):
          oprot.writeI32(kiter502)
          oprot.writeSetBegin(TType.STRUCT, len(viter503))
          for iter504 in viter503:
            iter504.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartEnd_args:
  """
  Attributes:
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.I64, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartEnd_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 3)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype506, _vtype507, _size505 ) = iprot.readMapBegin()
          for _i509 in range(_size505):
            _key510 = iprot.readString()
            _val511 = {}
            (_ktype513, _vtype514, _size512 ) = iprot.readMapBegin()
            for _i516 in range(_size512):
              _key517 = iprot.readI32()
              _val518 = []
              (_etype522, _size519) = iprot.readSetBegin()
              for _i523 in range(_size519):
                _elem524 = TObject()
                _elem524.read(iprot)
                _val518.append(_elem524)
              iprot.readSetEnd()
              _val511[_key517] = _val518
            iprot.readMapEnd()
            self.success[_key510] = _val511
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter525,viter526 in list(self.success.items()):
        oprot.writeString(kiter525)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter526))
        for kiter527,viter528 in list(viter526.items()):
          oprot.writeI32(kiter527)
          oprot.writeSetBegin(TType.STRUCT, len(viter528))
          for iter529 in viter528:
            iter529.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartstrEndstr_args:
  """
  Attributes:
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRING, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartstrEndstr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 3)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype531, _vtype532, _size530 ) = iprot.readMapBegin()
          for _i534 in range(_size530):
            _key535 = iprot.readString()
            _val536 = {}
            (_ktype538, _vtype539, _size537 ) = iprot.readMapBegin()
            for _i541 in range(_size537):
              _key542 = iprot.readI32()
              _val543 = []
              (_etype547, _size544) = iprot.readSetBegin()
              for _i548 in range(_size544):
                _elem549 = TObject()
                _elem549.read(iprot)
                _val543.append(_elem549)
              iprot.readSetEnd()
              _val536[_key542] = _val543
            iprot.readMapEnd()
            self.success[_key535] = _val536
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter550,viter551 in list(self.success.items()):
        oprot.writeString(kiter550)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter551))
        for kiter552,viter553 in list(viter551.items()):
          oprot.writeI32(kiter552)
          oprot.writeSetBegin(TType.STRUCT, len(viter553))
          for iter554 in viter553:
            iter554.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStart_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStart_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype556, _vtype557, _size555 ) = iprot.readMapBegin()
          for _i559 in range(_size555):
            _key560 = iprot.readI32()
            _val561 = []
            (_etype565, _size562) = iprot.readSetBegin()
            for _i566 in range(_size562):
              _elem567 = TObject()
              _elem567.read(iprot)
              _val561.append(_elem567)
            iprot.readSetEnd()
            self.success[_key560] = _val561
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.SET, len(self.success))
      for kiter568,viter569 in list(self.success.items()):
        oprot.writeI32(kiter568)
        oprot.writeSetBegin(TType.STRUCT, len(viter569))
        for iter570 in viter569:
          iter570.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype572, _vtype573, _size571 ) = iprot.readMapBegin()
          for _i575 in range(_size571):
            _key576 = iprot.readI32()
            _val577 = []
            (_etype581, _size578) = iprot.readSetBegin()
            for _i582 in range(_size578):
              _elem583 = TObject()
              _elem583.read(iprot)
              _val577.append(_elem583)
            iprot.readSetEnd()
            self.success[_key576] = _val577
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.SET, len(self.success))
      for kiter584,viter585 in list(self.success.items()):
        oprot.writeI32(kiter584)
        oprot.writeSetBegin(TType.STRUCT, len(viter585))
        for iter586 in viter585:
          iter586.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartEnd_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.I64, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartEnd_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 4)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype588, _vtype589, _size587 ) = iprot.readMapBegin()
          for _i591 in range(_size587):
            _key592 = iprot.readI32()
            _val593 = []
            (_etype597, _size594) = iprot.readSetBegin()
            for _i598 in range(_size594):
              _elem599 = TObject()
              _elem599.read(iprot)
              _val593.append(_elem599)
            iprot.readSetEnd()
            self.success[_key592] = _val593
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.SET, len(self.success))
      for kiter600,viter601 in list(self.success.items()):
        oprot.writeI32(kiter600)
        oprot.writeSetBegin(TType.STRUCT, len(viter601))
        for iter602 in viter601:
          iter602.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartstrEndstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRING, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartstrEndstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 4)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype604, _vtype605, _size603 ) = iprot.readMapBegin()
          for _i607 in range(_size603):
            _key608 = iprot.readI32()
            _val609 = []
            (_etype613, _size610) = iprot.readSetBegin()
            for _i614 in range(_size610):
              _elem615 = TObject()
              _elem615.read(iprot)
              _val609.append(_elem615)
            iprot.readSetEnd()
            self.success[_key608] = _val609
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.SET, len(self.success))
      for kiter616,viter617 in list(self.success.items()):
        oprot.writeI32(kiter616)
        oprot.writeSetBegin(TType.STRUCT, len(viter617))
        for iter618 in viter617:
          iter618.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStart_args:
  """
  Attributes:
   - key
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStart_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.MAP,(TType.I32,None,TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype620, _vtype621, _size619 ) = iprot.readMapBegin()
          for _i623 in range(_size619):
            _key624 = TObject()
            _key624.read(iprot)
            _val625 = {}
            (_ktype627, _vtype628, _size626 ) = iprot.readMapBegin()
            for _i630 in range(_size626):
              _key631 = iprot.readI32()
              _val632 = []
              (_etype636, _size633) = iprot.readSetBegin()
              for _i637 in range(_size633):
                _elem638 = iprot.readI64()
                _val632.append(_elem638)
              iprot.readSetEnd()
              _val625[_key631] = _val632
            iprot.readMapEnd()
            self.success[_key624] = _val625
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.success))
      for kiter639,viter640 in list(self.success.items()):
        kiter639.write(oprot)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter640))
        for kiter641,viter642 in list(viter640.items()):
          oprot.writeI32(kiter641)
          oprot.writeSetBegin(TType.I64, len(viter642))
          for iter643 in viter642:
            oprot.writeI64(iter643)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartstr_args:
  """
  Attributes:
   - key
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.MAP,(TType.I32,None,TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype645, _vtype646, _size644 ) = iprot.readMapBegin()
          for _i648 in range(_size644):
            _key649 = TObject()
            _key649.read(iprot)
            _val650 = {}
            (_ktype652, _vtype653, _size651 ) = iprot.readMapBegin()
            for _i655 in range(_size651):
              _key656 = iprot.readI32()
              _val657 = []
              (_etype661, _size658) = iprot.readSetBegin()
              for _i662 in range(_size658):
                _elem663 = iprot.readI64()
                _val657.append(_elem663)
              iprot.readSetEnd()
              _val650[_key656] = _val657
            iprot.readMapEnd()
            self.success[_key649] = _val650
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.success))
      for kiter664,viter665 in list(self.success.items()):
        kiter664.write(oprot)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter665))
        for kiter666,viter667 in list(viter665.items()):
          oprot.writeI32(kiter666)
          oprot.writeSetBegin(TType.I64, len(viter667))
          for iter668 in viter667:
            oprot.writeI64(iter668)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartEnd_args:
  """
  Attributes:
   - key
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.I64, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartEnd_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 3)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.MAP,(TType.I32,None,TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype670, _vtype671, _size669 ) = iprot.readMapBegin()
          for _i673 in range(_size669):
            _key674 = TObject()
            _key674.read(iprot)
            _val675 = {}
            (_ktype677, _vtype678, _size676 ) = iprot.readMapBegin()
            for _i680 in range(_size676):
              _key681 = iprot.readI32()
              _val682 = []
              (_etype686, _size683) = iprot.readSetBegin()
              for _i687 in range(_size683):
                _elem688 = iprot.readI64()
                _val682.append(_elem688)
              iprot.readSetEnd()
              _val675[_key681] = _val682
            iprot.readMapEnd()
            self.success[_key674] = _val675
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.success))
      for kiter689,viter690 in list(self.success.items()):
        kiter689.write(oprot)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter690))
        for kiter691,viter692 in list(viter690.items()):
          oprot.writeI32(kiter691)
          oprot.writeSetBegin(TType.I64, len(viter692))
          for iter693 in viter692:
            oprot.writeI64(iter693)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartstrEndstr_args:
  """
  Attributes:
   - key
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRING, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartstrEndstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 3)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.MAP,(TType.I32,None,TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype695, _vtype696, _size694 ) = iprot.readMapBegin()
          for _i698 in range(_size694):
            _key699 = TObject()
            _key699.read(iprot)
            _val700 = {}
            (_ktype702, _vtype703, _size701 ) = iprot.readMapBegin()
            for _i705 in range(_size701):
              _key706 = iprot.readI32()
              _val707 = []
              (_etype711, _size708) = iprot.readSetBegin()
              for _i712 in range(_size708):
                _elem713 = iprot.readI64()
                _val707.append(_elem713)
              iprot.readSetEnd()
              _val700[_key706] = _val707
            iprot.readMapEnd()
            self.success[_key699] = _val700
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.success))
      for kiter714,viter715 in list(self.success.items()):
        kiter714.write(oprot)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter715))
        for kiter716,viter717 in list(viter715.items()):
          oprot.writeI32(kiter716)
          oprot.writeSetBegin(TType.I64, len(viter717))
          for iter718 in viter717:
            oprot.writeI64(iter718)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class login_args:
  """
  Attributes:
   - username
   - password
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'username', None, None, ), # 1
    (2, TType.STRING, 'password', None, None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, username=None, password=None, environment=None,):
    self.username = username
    self.password = password
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.username = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.password = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('login_args')
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 1)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 2)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.username)
    value = (value * 31) ^ hash(self.password)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class login_result:
  """
  Attributes:
   - success
   - ex
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessToken, AccessToken.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ex=None,):
    self.success = success
    self.ex = ex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessToken()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('login_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class logout_args:
  """
  Attributes:
   - token
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'environment', None, None, ), # 2
  )

  def __init__(self, token=None, environment=None,):
    self.token = token
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('logout_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 2)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class logout_result:
  """
  Attributes:
   - ex
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, ex=None,):
    self.ex = ex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('logout_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stage_args:
  """
  Attributes:
   - token
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'environment', None, None, ), # 2
  )

  def __init__(self, token=None, environment=None,):
    self.token = token
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stage_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 2)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stage_result:
  """
  Attributes:
   - success
   - ex
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TransactionToken, TransactionToken.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ex=None,):
    self.success = success
    self.ex = ex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TransactionToken()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stage_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJson_args:
  """
  Attributes:
   - json
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'json', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, json=None, creds=None, transaction=None, environment=None,):
    self.json = json
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.json = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJson_args')
    if self.json is not None:
      oprot.writeFieldBegin('json', TType.STRING, 1)
      oprot.writeString(self.json)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.json)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJson_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype722, _size719) = iprot.readSetBegin()
          for _i723 in range(_size719):
            _elem724 = iprot.readI64()
            self.success.append(_elem724)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJson_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter725 in self.success:
        oprot.writeI64(iter725)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJsonRecord_args:
  """
  Attributes:
   - json
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'json', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, json=None, record=None, creds=None, transaction=None, environment=None,):
    self.json = json
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.json = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJsonRecord_args')
    if self.json is not None:
      oprot.writeFieldBegin('json', TType.STRING, 1)
      oprot.writeString(self.json)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.json)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJsonRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJsonRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJsonRecords_args:
  """
  Attributes:
   - json
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'json', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, json=None, records=None, creds=None, transaction=None, environment=None,):
    self.json = json
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.json = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype729, _size726) = iprot.readListBegin()
          for _i730 in range(_size726):
            _elem731 = iprot.readI64()
            self.records.append(_elem731)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJsonRecords_args')
    if self.json is not None:
      oprot.writeFieldBegin('json', TType.STRING, 1)
      oprot.writeString(self.json)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter732 in self.records:
        oprot.writeI64(iter732)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.json)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJsonRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.BOOL,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype734, _vtype735, _size733 ) = iprot.readMapBegin()
          for _i737 in range(_size733):
            _key738 = iprot.readI64()
            _val739 = iprot.readBool()
            self.success[_key738] = _val739
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJsonRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.BOOL, len(self.success))
      for kiter740,viter741 in list(self.success.items()):
        oprot.writeI64(kiter740)
        oprot.writeBool(viter741)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeKeyValueRecord_args:
  """
  Attributes:
   - key
   - value
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeKeyValueRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeKeyValueRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeKeyValueRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeKeyValueRecords_args:
  """
  Attributes:
   - key
   - value
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.LIST, 'records', (TType.I64,None), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.records = []
          (_etype745, _size742) = iprot.readListBegin()
          for _i746 in range(_size742):
            _elem747 = iprot.readI64()
            self.records.append(_elem747)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeKeyValueRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter748 in self.records:
        oprot.writeI64(iter748)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeKeyValueRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.BOOL,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype750, _vtype751, _size749 ) = iprot.readMapBegin()
          for _i753 in range(_size749):
            _key754 = iprot.readI64()
            _val755 = iprot.readBool()
            self.success[_key754] = _val755
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeKeyValueRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.BOOL, len(self.success))
      for kiter756,viter757 in list(self.success.items()):
        oprot.writeI64(kiter756)
        oprot.writeBool(viter757)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValueRecord_args:
  """
  Attributes:
   - key
   - value
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValueRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValueRecord_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValueRecord_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValue_args:
  """
  Attributes:
   - key
   - value
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, value=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValue_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValue_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValue_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValueRecords_args:
  """
  Attributes:
   - key
   - value
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.LIST, 'records', (TType.I64,None), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.records = []
          (_etype761, _size758) = iprot.readListBegin()
          for _i762 in range(_size758):
            _elem763 = iprot.readI64()
            self.records.append(_elem763)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValueRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter764 in self.records:
        oprot.writeI64(iter764)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValueRecords_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValueRecords_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reconcileKeyRecordValues_args:
  """
  Attributes:
   - key
   - record
   - values
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.SET, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, values=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.values = values
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.values = []
          (_etype768, _size765) = iprot.readSetBegin()
          for _i769 in range(_size765):
            _elem770 = TObject()
            _elem770.read(iprot)
            self.values.append(_elem770)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reconcileKeyRecordValues_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.SET, 3)
      oprot.writeSetBegin(TType.STRUCT, len(self.values))
      for iter771 in self.values:
        iter771.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reconcileKeyRecordValues_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reconcileKeyRecordValues_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inventory_args:
  """
  Attributes:
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, creds=None, transaction=None, environment=None,):
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inventory_args')
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 1)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 2)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inventory_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype775, _size772) = iprot.readSetBegin()
          for _i776 in range(_size772):
            _elem777 = iprot.readI64()
            self.success.append(_elem777)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inventory_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter778 in self.success:
        oprot.writeI64(iter778)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecord_args:
  """
  Attributes:
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, record=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype780, _vtype781, _size779 ) = iprot.readMapBegin()
          for _i783 in range(_size779):
            _key784 = iprot.readString()
            _val785 = []
            (_etype789, _size786) = iprot.readSetBegin()
            for _i790 in range(_size786):
              _elem791 = TObject()
              _elem791.read(iprot)
              _val785.append(_elem791)
            iprot.readSetEnd()
            self.success[_key784] = _val785
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter792,viter793 in list(self.success.items()):
        oprot.writeString(kiter792)
        oprot.writeSetBegin(TType.STRUCT, len(viter793))
        for iter794 in viter793:
          iter794.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecords_args:
  """
  Attributes:
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, records=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype798, _size795) = iprot.readListBegin()
          for _i799 in range(_size795):
            _elem800 = iprot.readI64()
            self.records.append(_elem800)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecords_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter801 in self.records:
        oprot.writeI64(iter801)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype803, _vtype804, _size802 ) = iprot.readMapBegin()
          for _i806 in range(_size802):
            _key807 = iprot.readI64()
            _val808 = {}
            (_ktype810, _vtype811, _size809 ) = iprot.readMapBegin()
            for _i813 in range(_size809):
              _key814 = iprot.readString()
              _val815 = []
              (_etype819, _size816) = iprot.readSetBegin()
              for _i820 in range(_size816):
                _elem821 = TObject()
                _elem821.read(iprot)
                _val815.append(_elem821)
              iprot.readSetEnd()
              _val808[_key814] = _val815
            iprot.readMapEnd()
            self.success[_key807] = _val808
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter822,viter823 in list(self.success.items()):
        oprot.writeI64(kiter822)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter823))
        for kiter824,viter825 in list(viter823.items()):
          oprot.writeString(kiter824)
          oprot.writeSetBegin(TType.STRUCT, len(viter825))
          for iter826 in viter825:
            iter826.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordTime_args:
  """
  Attributes:
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordTime_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype828, _vtype829, _size827 ) = iprot.readMapBegin()
          for _i831 in range(_size827):
            _key832 = iprot.readString()
            _val833 = []
            (_etype837, _size834) = iprot.readSetBegin()
            for _i838 in range(_size834):
              _elem839 = TObject()
              _elem839.read(iprot)
              _val833.append(_elem839)
            iprot.readSetEnd()
            self.success[_key832] = _val833
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter840,viter841 in list(self.success.items()):
        oprot.writeString(kiter840)
        oprot.writeSetBegin(TType.STRUCT, len(viter841))
        for iter842 in viter841:
          iter842.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordTimestr_args:
  """
  Attributes:
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordTimestr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype844, _vtype845, _size843 ) = iprot.readMapBegin()
          for _i847 in range(_size843):
            _key848 = iprot.readString()
            _val849 = []
            (_etype853, _size850) = iprot.readSetBegin()
            for _i854 in range(_size850):
              _elem855 = TObject()
              _elem855.read(iprot)
              _val849.append(_elem855)
            iprot.readSetEnd()
            self.success[_key848] = _val849
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter856,viter857 in list(self.success.items()):
        oprot.writeString(kiter856)
        oprot.writeSetBegin(TType.STRUCT, len(viter857))
        for iter858 in viter857:
          iter858.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordsTime_args:
  """
  Attributes:
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype862, _size859) = iprot.readListBegin()
          for _i863 in range(_size859):
            _elem864 = iprot.readI64()
            self.records.append(_elem864)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordsTime_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter865 in self.records:
        oprot.writeI64(iter865)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype867, _vtype868, _size866 ) = iprot.readMapBegin()
          for _i870 in range(_size866):
            _key871 = iprot.readI64()
            _val872 = {}
            (_ktype874, _vtype875, _size873 ) = iprot.readMapBegin()
            for _i877 in range(_size873):
              _key878 = iprot.readString()
              _val879 = []
              (_etype883, _size880) = iprot.readSetBegin()
              for _i884 in range(_size880):
                _elem885 = TObject()
                _elem885.read(iprot)
                _val879.append(_elem885)
              iprot.readSetEnd()
              _val872[_key878] = _val879
            iprot.readMapEnd()
            self.success[_key871] = _val872
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter886,viter887 in list(self.success.items()):
        oprot.writeI64(kiter886)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter887))
        for kiter888,viter889 in list(viter887.items()):
          oprot.writeString(kiter888)
          oprot.writeSetBegin(TType.STRUCT, len(viter889))
          for iter890 in viter889:
            iter890.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordsTimestr_args:
  """
  Attributes:
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype894, _size891) = iprot.readListBegin()
          for _i895 in range(_size891):
            _elem896 = iprot.readI64()
            self.records.append(_elem896)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordsTimestr_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter897 in self.records:
        oprot.writeI64(iter897)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype899, _vtype900, _size898 ) = iprot.readMapBegin()
          for _i902 in range(_size898):
            _key903 = iprot.readI64()
            _val904 = {}
            (_ktype906, _vtype907, _size905 ) = iprot.readMapBegin()
            for _i909 in range(_size905):
              _key910 = iprot.readString()
              _val911 = []
              (_etype915, _size912) = iprot.readSetBegin()
              for _i916 in range(_size912):
                _elem917 = TObject()
                _elem917.read(iprot)
                _val911.append(_elem917)
              iprot.readSetEnd()
              _val904[_key910] = _val911
            iprot.readMapEnd()
            self.success[_key903] = _val904
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter918,viter919 in list(self.success.items()):
        oprot.writeI64(kiter918)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter919))
        for kiter920,viter921 in list(viter919.items()):
          oprot.writeString(kiter920)
          oprot.writeSetBegin(TType.STRUCT, len(viter921))
          for iter922 in viter921:
            iter922.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype926, _size923) = iprot.readSetBegin()
          for _i927 in range(_size923):
            _elem928 = TObject()
            _elem928.read(iprot)
            self.success.append(_elem928)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRUCT, len(self.success))
      for iter929 in self.success:
        iter929.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordTime_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype933, _size930) = iprot.readSetBegin()
          for _i934 in range(_size930):
            _elem935 = TObject()
            _elem935.read(iprot)
            self.success.append(_elem935)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRUCT, len(self.success))
      for iter936 in self.success:
        iter936.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordTimestr_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype940, _size937) = iprot.readSetBegin()
          for _i941 in range(_size937):
            _elem942 = TObject()
            _elem942.read(iprot)
            self.success.append(_elem942)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRUCT, len(self.success))
      for iter943 in self.success:
        iter943.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecord_args:
  """
  Attributes:
   - keys
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, record=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype947, _size944) = iprot.readListBegin()
          for _i948 in range(_size944):
            _elem949 = iprot.readString()
            self.keys.append(_elem949)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecord_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter950 in self.keys:
        oprot.writeString(iter950)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype952, _vtype953, _size951 ) = iprot.readMapBegin()
          for _i955 in range(_size951):
            _key956 = iprot.readString()
            _val957 = []
            (_etype961, _size958) = iprot.readSetBegin()
            for _i962 in range(_size958):
              _elem963 = TObject()
              _elem963.read(iprot)
              _val957.append(_elem963)
            iprot.readSetEnd()
            self.success[_key956] = _val957
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter964,viter965 in list(self.success.items()):
        oprot.writeString(kiter964)
        oprot.writeSetBegin(TType.STRUCT, len(viter965))
        for iter966 in viter965:
          iter966.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordTime_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype970, _size967) = iprot.readListBegin()
          for _i971 in range(_size967):
            _elem972 = iprot.readString()
            self.keys.append(_elem972)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter973 in self.keys:
        oprot.writeString(iter973)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype975, _vtype976, _size974 ) = iprot.readMapBegin()
          for _i978 in range(_size974):
            _key979 = iprot.readString()
            _val980 = []
            (_etype984, _size981) = iprot.readSetBegin()
            for _i985 in range(_size981):
              _elem986 = TObject()
              _elem986.read(iprot)
              _val980.append(_elem986)
            iprot.readSetEnd()
            self.success[_key979] = _val980
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter987,viter988 in list(self.success.items()):
        oprot.writeString(kiter987)
        oprot.writeSetBegin(TType.STRUCT, len(viter988))
        for iter989 in viter988:
          iter989.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordTimestr_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype993, _size990) = iprot.readListBegin()
          for _i994 in range(_size990):
            _elem995 = iprot.readString()
            self.keys.append(_elem995)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter996 in self.keys:
        oprot.writeString(iter996)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype998, _vtype999, _size997 ) = iprot.readMapBegin()
          for _i1001 in range(_size997):
            _key1002 = iprot.readString()
            _val1003 = []
            (_etype1007, _size1004) = iprot.readSetBegin()
            for _i1008 in range(_size1004):
              _elem1009 = TObject()
              _elem1009.read(iprot)
              _val1003.append(_elem1009)
            iprot.readSetEnd()
            self.success[_key1002] = _val1003
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter1010,viter1011 in list(self.success.items()):
        oprot.writeString(kiter1010)
        oprot.writeSetBegin(TType.STRUCT, len(viter1011))
        for iter1012 in viter1011:
          iter1012.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecords_args:
  """
  Attributes:
   - keys
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, records=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1016, _size1013) = iprot.readListBegin()
          for _i1017 in range(_size1013):
            _elem1018 = iprot.readString()
            self.keys.append(_elem1018)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1022, _size1019) = iprot.readListBegin()
          for _i1023 in range(_size1019):
            _elem1024 = iprot.readI64()
            self.records.append(_elem1024)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecords_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1025 in self.keys:
        oprot.writeString(iter1025)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1026 in self.records:
        oprot.writeI64(iter1026)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1028, _vtype1029, _size1027 ) = iprot.readMapBegin()
          for _i1031 in range(_size1027):
            _key1032 = iprot.readI64()
            _val1033 = {}
            (_ktype1035, _vtype1036, _size1034 ) = iprot.readMapBegin()
            for _i1038 in range(_size1034):
              _key1039 = iprot.readString()
              _val1040 = []
              (_etype1044, _size1041) = iprot.readSetBegin()
              for _i1045 in range(_size1041):
                _elem1046 = TObject()
                _elem1046.read(iprot)
                _val1040.append(_elem1046)
              iprot.readSetEnd()
              _val1033[_key1039] = _val1040
            iprot.readMapEnd()
            self.success[_key1032] = _val1033
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1047,viter1048 in list(self.success.items()):
        oprot.writeI64(kiter1047)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1048))
        for kiter1049,viter1050 in list(viter1048.items()):
          oprot.writeString(kiter1049)
          oprot.writeSetBegin(TType.STRUCT, len(viter1050))
          for iter1051 in viter1050:
            iter1051.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecords_args:
  """
  Attributes:
   - key
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1055, _size1052) = iprot.readListBegin()
          for _i1056 in range(_size1052):
            _elem1057 = iprot.readI64()
            self.records.append(_elem1057)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1058 in self.records:
        oprot.writeI64(iter1058)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1060, _vtype1061, _size1059 ) = iprot.readMapBegin()
          for _i1063 in range(_size1059):
            _key1064 = iprot.readI64()
            _val1065 = []
            (_etype1069, _size1066) = iprot.readSetBegin()
            for _i1070 in range(_size1066):
              _elem1071 = TObject()
              _elem1071.read(iprot)
              _val1065.append(_elem1071)
            iprot.readSetEnd()
            self.success[_key1064] = _val1065
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1072,viter1073 in list(self.success.items()):
        oprot.writeI64(kiter1072)
        oprot.writeSetBegin(TType.STRUCT, len(viter1073))
        for iter1074 in viter1073:
          iter1074.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordsTime_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1078, _size1075) = iprot.readListBegin()
          for _i1079 in range(_size1075):
            _elem1080 = iprot.readI64()
            self.records.append(_elem1080)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordsTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1081 in self.records:
        oprot.writeI64(iter1081)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1083, _vtype1084, _size1082 ) = iprot.readMapBegin()
          for _i1086 in range(_size1082):
            _key1087 = iprot.readI64()
            _val1088 = []
            (_etype1092, _size1089) = iprot.readSetBegin()
            for _i1093 in range(_size1089):
              _elem1094 = TObject()
              _elem1094.read(iprot)
              _val1088.append(_elem1094)
            iprot.readSetEnd()
            self.success[_key1087] = _val1088
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1095,viter1096 in list(self.success.items()):
        oprot.writeI64(kiter1095)
        oprot.writeSetBegin(TType.STRUCT, len(viter1096))
        for iter1097 in viter1096:
          iter1097.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordsTimestr_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1101, _size1098) = iprot.readListBegin()
          for _i1102 in range(_size1098):
            _elem1103 = iprot.readI64()
            self.records.append(_elem1103)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordsTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1104 in self.records:
        oprot.writeI64(iter1104)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1106, _vtype1107, _size1105 ) = iprot.readMapBegin()
          for _i1109 in range(_size1105):
            _key1110 = iprot.readI64()
            _val1111 = []
            (_etype1115, _size1112) = iprot.readSetBegin()
            for _i1116 in range(_size1112):
              _elem1117 = TObject()
              _elem1117.read(iprot)
              _val1111.append(_elem1117)
            iprot.readSetEnd()
            self.success[_key1110] = _val1111
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1118,viter1119 in list(self.success.items()):
        oprot.writeI64(kiter1118)
        oprot.writeSetBegin(TType.STRUCT, len(viter1119))
        for iter1120 in viter1119:
          iter1120.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordsTime_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1124, _size1121) = iprot.readListBegin()
          for _i1125 in range(_size1121):
            _elem1126 = iprot.readString()
            self.keys.append(_elem1126)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1130, _size1127) = iprot.readListBegin()
          for _i1131 in range(_size1127):
            _elem1132 = iprot.readI64()
            self.records.append(_elem1132)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordsTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1133 in self.keys:
        oprot.writeString(iter1133)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1134 in self.records:
        oprot.writeI64(iter1134)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1136, _vtype1137, _size1135 ) = iprot.readMapBegin()
          for _i1139 in range(_size1135):
            _key1140 = iprot.readI64()
            _val1141 = {}
            (_ktype1143, _vtype1144, _size1142 ) = iprot.readMapBegin()
            for _i1146 in range(_size1142):
              _key1147 = iprot.readString()
              _val1148 = []
              (_etype1152, _size1149) = iprot.readSetBegin()
              for _i1153 in range(_size1149):
                _elem1154 = TObject()
                _elem1154.read(iprot)
                _val1148.append(_elem1154)
              iprot.readSetEnd()
              _val1141[_key1147] = _val1148
            iprot.readMapEnd()
            self.success[_key1140] = _val1141
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1155,viter1156 in list(self.success.items()):
        oprot.writeI64(kiter1155)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1156))
        for kiter1157,viter1158 in list(viter1156.items()):
          oprot.writeString(kiter1157)
          oprot.writeSetBegin(TType.STRUCT, len(viter1158))
          for iter1159 in viter1158:
            iter1159.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordsTimestr_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1163, _size1160) = iprot.readListBegin()
          for _i1164 in range(_size1160):
            _elem1165 = iprot.readString()
            self.keys.append(_elem1165)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1169, _size1166) = iprot.readListBegin()
          for _i1170 in range(_size1166):
            _elem1171 = iprot.readI64()
            self.records.append(_elem1171)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordsTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1172 in self.keys:
        oprot.writeString(iter1172)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1173 in self.records:
        oprot.writeI64(iter1173)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1175, _vtype1176, _size1174 ) = iprot.readMapBegin()
          for _i1178 in range(_size1174):
            _key1179 = iprot.readI64()
            _val1180 = {}
            (_ktype1182, _vtype1183, _size1181 ) = iprot.readMapBegin()
            for _i1185 in range(_size1181):
              _key1186 = iprot.readString()
              _val1187 = []
              (_etype1191, _size1188) = iprot.readSetBegin()
              for _i1192 in range(_size1188):
                _elem1193 = TObject()
                _elem1193.read(iprot)
                _val1187.append(_elem1193)
              iprot.readSetEnd()
              _val1180[_key1186] = _val1187
            iprot.readMapEnd()
            self.success[_key1179] = _val1180
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1194,viter1195 in list(self.success.items()):
        oprot.writeI64(kiter1194)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1195))
        for kiter1196,viter1197 in list(viter1195.items()):
          oprot.writeString(kiter1196)
          oprot.writeSetBegin(TType.STRUCT, len(viter1197))
          for iter1198 in viter1197:
            iter1198.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteria_args:
  """
  Attributes:
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, criteria=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteria_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1200, _vtype1201, _size1199 ) = iprot.readMapBegin()
          for _i1203 in range(_size1199):
            _key1204 = iprot.readI64()
            _val1205 = {}
            (_ktype1207, _vtype1208, _size1206 ) = iprot.readMapBegin()
            for _i1210 in range(_size1206):
              _key1211 = iprot.readString()
              _val1212 = []
              (_etype1216, _size1213) = iprot.readSetBegin()
              for _i1217 in range(_size1213):
                _elem1218 = TObject()
                _elem1218.read(iprot)
                _val1212.append(_elem1218)
              iprot.readSetEnd()
              _val1205[_key1211] = _val1212
            iprot.readMapEnd()
            self.success[_key1204] = _val1205
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1219,viter1220 in list(self.success.items()):
        oprot.writeI64(kiter1219)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1220))
        for kiter1221,viter1222 in list(viter1220.items()):
          oprot.writeString(kiter1221)
          oprot.writeSetBegin(TType.STRUCT, len(viter1222))
          for iter1223 in viter1222:
            iter1223.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCcl_args:
  """
  Attributes:
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, ccl=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCcl_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1225, _vtype1226, _size1224 ) = iprot.readMapBegin()
          for _i1228 in range(_size1224):
            _key1229 = iprot.readI64()
            _val1230 = {}
            (_ktype1232, _vtype1233, _size1231 ) = iprot.readMapBegin()
            for _i1235 in range(_size1231):
              _key1236 = iprot.readString()
              _val1237 = []
              (_etype1241, _size1238) = iprot.readSetBegin()
              for _i1242 in range(_size1238):
                _elem1243 = TObject()
                _elem1243.read(iprot)
                _val1237.append(_elem1243)
              iprot.readSetEnd()
              _val1230[_key1236] = _val1237
            iprot.readMapEnd()
            self.success[_key1229] = _val1230
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1244,viter1245 in list(self.success.items()):
        oprot.writeI64(kiter1244)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1245))
        for kiter1246,viter1247 in list(viter1245.items()):
          oprot.writeString(kiter1246)
          oprot.writeSetBegin(TType.STRUCT, len(viter1247))
          for iter1248 in viter1247:
            iter1248.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteriaTime_args:
  """
  Attributes:
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteriaTime_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1250, _vtype1251, _size1249 ) = iprot.readMapBegin()
          for _i1253 in range(_size1249):
            _key1254 = iprot.readI64()
            _val1255 = {}
            (_ktype1257, _vtype1258, _size1256 ) = iprot.readMapBegin()
            for _i1260 in range(_size1256):
              _key1261 = iprot.readString()
              _val1262 = []
              (_etype1266, _size1263) = iprot.readSetBegin()
              for _i1267 in range(_size1263):
                _elem1268 = TObject()
                _elem1268.read(iprot)
                _val1262.append(_elem1268)
              iprot.readSetEnd()
              _val1255[_key1261] = _val1262
            iprot.readMapEnd()
            self.success[_key1254] = _val1255
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1269,viter1270 in list(self.success.items()):
        oprot.writeI64(kiter1269)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1270))
        for kiter1271,viter1272 in list(viter1270.items()):
          oprot.writeString(kiter1271)
          oprot.writeSetBegin(TType.STRUCT, len(viter1272))
          for iter1273 in viter1272:
            iter1273.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteriaTimestr_args:
  """
  Attributes:
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteriaTimestr_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1275, _vtype1276, _size1274 ) = iprot.readMapBegin()
          for _i1278 in range(_size1274):
            _key1279 = iprot.readI64()
            _val1280 = {}
            (_ktype1282, _vtype1283, _size1281 ) = iprot.readMapBegin()
            for _i1285 in range(_size1281):
              _key1286 = iprot.readString()
              _val1287 = []
              (_etype1291, _size1288) = iprot.readSetBegin()
              for _i1292 in range(_size1288):
                _elem1293 = TObject()
                _elem1293.read(iprot)
                _val1287.append(_elem1293)
              iprot.readSetEnd()
              _val1280[_key1286] = _val1287
            iprot.readMapEnd()
            self.success[_key1279] = _val1280
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1294,viter1295 in list(self.success.items()):
        oprot.writeI64(kiter1294)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1295))
        for kiter1296,viter1297 in list(viter1295.items()):
          oprot.writeString(kiter1296)
          oprot.writeSetBegin(TType.STRUCT, len(viter1297))
          for iter1298 in viter1297:
            iter1298.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCclTime_args:
  """
  Attributes:
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCclTime_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1300, _vtype1301, _size1299 ) = iprot.readMapBegin()
          for _i1303 in range(_size1299):
            _key1304 = iprot.readI64()
            _val1305 = {}
            (_ktype1307, _vtype1308, _size1306 ) = iprot.readMapBegin()
            for _i1310 in range(_size1306):
              _key1311 = iprot.readString()
              _val1312 = []
              (_etype1316, _size1313) = iprot.readSetBegin()
              for _i1317 in range(_size1313):
                _elem1318 = TObject()
                _elem1318.read(iprot)
                _val1312.append(_elem1318)
              iprot.readSetEnd()
              _val1305[_key1311] = _val1312
            iprot.readMapEnd()
            self.success[_key1304] = _val1305
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1319,viter1320 in list(self.success.items()):
        oprot.writeI64(kiter1319)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1320))
        for kiter1321,viter1322 in list(viter1320.items()):
          oprot.writeString(kiter1321)
          oprot.writeSetBegin(TType.STRUCT, len(viter1322))
          for iter1323 in viter1322:
            iter1323.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCclTimestr_args:
  """
  Attributes:
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCclTimestr_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1325, _vtype1326, _size1324 ) = iprot.readMapBegin()
          for _i1328 in range(_size1324):
            _key1329 = iprot.readI64()
            _val1330 = {}
            (_ktype1332, _vtype1333, _size1331 ) = iprot.readMapBegin()
            for _i1335 in range(_size1331):
              _key1336 = iprot.readString()
              _val1337 = []
              (_etype1341, _size1338) = iprot.readSetBegin()
              for _i1342 in range(_size1338):
                _elem1343 = TObject()
                _elem1343.read(iprot)
                _val1337.append(_elem1343)
              iprot.readSetEnd()
              _val1330[_key1336] = _val1337
            iprot.readMapEnd()
            self.success[_key1329] = _val1330
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1344,viter1345 in list(self.success.items()):
        oprot.writeI64(kiter1344)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1345))
        for kiter1346,viter1347 in list(viter1345.items()):
          oprot.writeString(kiter1346)
          oprot.writeSetBegin(TType.STRUCT, len(viter1347))
          for iter1348 in viter1347:
            iter1348.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteria_args:
  """
  Attributes:
   - key
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteria_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1350, _vtype1351, _size1349 ) = iprot.readMapBegin()
          for _i1353 in range(_size1349):
            _key1354 = iprot.readI64()
            _val1355 = []
            (_etype1359, _size1356) = iprot.readSetBegin()
            for _i1360 in range(_size1356):
              _elem1361 = TObject()
              _elem1361.read(iprot)
              _val1355.append(_elem1361)
            iprot.readSetEnd()
            self.success[_key1354] = _val1355
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1362,viter1363 in list(self.success.items()):
        oprot.writeI64(kiter1362)
        oprot.writeSetBegin(TType.STRUCT, len(viter1363))
        for iter1364 in viter1363:
          iter1364.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCcl_args:
  """
  Attributes:
   - key
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCcl_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1366, _vtype1367, _size1365 ) = iprot.readMapBegin()
          for _i1369 in range(_size1365):
            _key1370 = iprot.readI64()
            _val1371 = []
            (_etype1375, _size1372) = iprot.readSetBegin()
            for _i1376 in range(_size1372):
              _elem1377 = TObject()
              _elem1377.read(iprot)
              _val1371.append(_elem1377)
            iprot.readSetEnd()
            self.success[_key1370] = _val1371
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1378,viter1379 in list(self.success.items()):
        oprot.writeI64(kiter1378)
        oprot.writeSetBegin(TType.STRUCT, len(viter1379))
        for iter1380 in viter1379:
          iter1380.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteriaTime_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteriaTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1382, _vtype1383, _size1381 ) = iprot.readMapBegin()
          for _i1385 in range(_size1381):
            _key1386 = iprot.readI64()
            _val1387 = []
            (_etype1391, _size1388) = iprot.readSetBegin()
            for _i1392 in range(_size1388):
              _elem1393 = TObject()
              _elem1393.read(iprot)
              _val1387.append(_elem1393)
            iprot.readSetEnd()
            self.success[_key1386] = _val1387
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1394,viter1395 in list(self.success.items()):
        oprot.writeI64(kiter1394)
        oprot.writeSetBegin(TType.STRUCT, len(viter1395))
        for iter1396 in viter1395:
          iter1396.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteriaTimestr_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteriaTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1398, _vtype1399, _size1397 ) = iprot.readMapBegin()
          for _i1401 in range(_size1397):
            _key1402 = iprot.readI64()
            _val1403 = []
            (_etype1407, _size1404) = iprot.readSetBegin()
            for _i1408 in range(_size1404):
              _elem1409 = TObject()
              _elem1409.read(iprot)
              _val1403.append(_elem1409)
            iprot.readSetEnd()
            self.success[_key1402] = _val1403
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1410,viter1411 in list(self.success.items()):
        oprot.writeI64(kiter1410)
        oprot.writeSetBegin(TType.STRUCT, len(viter1411))
        for iter1412 in viter1411:
          iter1412.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCclTime_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCclTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1414, _vtype1415, _size1413 ) = iprot.readMapBegin()
          for _i1417 in range(_size1413):
            _key1418 = iprot.readI64()
            _val1419 = []
            (_etype1423, _size1420) = iprot.readSetBegin()
            for _i1424 in range(_size1420):
              _elem1425 = TObject()
              _elem1425.read(iprot)
              _val1419.append(_elem1425)
            iprot.readSetEnd()
            self.success[_key1418] = _val1419
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1426,viter1427 in list(self.success.items()):
        oprot.writeI64(kiter1426)
        oprot.writeSetBegin(TType.STRUCT, len(viter1427))
        for iter1428 in viter1427:
          iter1428.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCclTimestr_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCclTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1430, _vtype1431, _size1429 ) = iprot.readMapBegin()
          for _i1433 in range(_size1429):
            _key1434 = iprot.readI64()
            _val1435 = []
            (_etype1439, _size1436) = iprot.readSetBegin()
            for _i1440 in range(_size1436):
              _elem1441 = TObject()
              _elem1441.read(iprot)
              _val1435.append(_elem1441)
            iprot.readSetEnd()
            self.success[_key1434] = _val1435
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1442,viter1443 in list(self.success.items()):
        oprot.writeI64(kiter1442)
        oprot.writeSetBegin(TType.STRUCT, len(viter1443))
        for iter1444 in viter1443:
          iter1444.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteria_args:
  """
  Attributes:
   - keys
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1448, _size1445) = iprot.readListBegin()
          for _i1449 in range(_size1445):
            _elem1450 = iprot.readString()
            self.keys.append(_elem1450)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteria_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1451 in self.keys:
        oprot.writeString(iter1451)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1453, _vtype1454, _size1452 ) = iprot.readMapBegin()
          for _i1456 in range(_size1452):
            _key1457 = iprot.readI64()
            _val1458 = {}
            (_ktype1460, _vtype1461, _size1459 ) = iprot.readMapBegin()
            for _i1463 in range(_size1459):
              _key1464 = iprot.readString()
              _val1465 = []
              (_etype1469, _size1466) = iprot.readSetBegin()
              for _i1470 in range(_size1466):
                _elem1471 = TObject()
                _elem1471.read(iprot)
                _val1465.append(_elem1471)
              iprot.readSetEnd()
              _val1458[_key1464] = _val1465
            iprot.readMapEnd()
            self.success[_key1457] = _val1458
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1472,viter1473 in list(self.success.items()):
        oprot.writeI64(kiter1472)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1473))
        for kiter1474,viter1475 in list(viter1473.items()):
          oprot.writeString(kiter1474)
          oprot.writeSetBegin(TType.STRUCT, len(viter1475))
          for iter1476 in viter1475:
            iter1476.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCcl_args:
  """
  Attributes:
   - keys
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1480, _size1477) = iprot.readListBegin()
          for _i1481 in range(_size1477):
            _elem1482 = iprot.readString()
            self.keys.append(_elem1482)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCcl_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1483 in self.keys:
        oprot.writeString(iter1483)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1485, _vtype1486, _size1484 ) = iprot.readMapBegin()
          for _i1488 in range(_size1484):
            _key1489 = iprot.readI64()
            _val1490 = {}
            (_ktype1492, _vtype1493, _size1491 ) = iprot.readMapBegin()
            for _i1495 in range(_size1491):
              _key1496 = iprot.readString()
              _val1497 = []
              (_etype1501, _size1498) = iprot.readSetBegin()
              for _i1502 in range(_size1498):
                _elem1503 = TObject()
                _elem1503.read(iprot)
                _val1497.append(_elem1503)
              iprot.readSetEnd()
              _val1490[_key1496] = _val1497
            iprot.readMapEnd()
            self.success[_key1489] = _val1490
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1504,viter1505 in list(self.success.items()):
        oprot.writeI64(kiter1504)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1505))
        for kiter1506,viter1507 in list(viter1505.items()):
          oprot.writeString(kiter1506)
          oprot.writeSetBegin(TType.STRUCT, len(viter1507))
          for iter1508 in viter1507:
            iter1508.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteriaTime_args:
  """
  Attributes:
   - keys
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1512, _size1509) = iprot.readListBegin()
          for _i1513 in range(_size1509):
            _elem1514 = iprot.readString()
            self.keys.append(_elem1514)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteriaTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1515 in self.keys:
        oprot.writeString(iter1515)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1517, _vtype1518, _size1516 ) = iprot.readMapBegin()
          for _i1520 in range(_size1516):
            _key1521 = iprot.readI64()
            _val1522 = {}
            (_ktype1524, _vtype1525, _size1523 ) = iprot.readMapBegin()
            for _i1527 in range(_size1523):
              _key1528 = iprot.readString()
              _val1529 = []
              (_etype1533, _size1530) = iprot.readSetBegin()
              for _i1534 in range(_size1530):
                _elem1535 = TObject()
                _elem1535.read(iprot)
                _val1529.append(_elem1535)
              iprot.readSetEnd()
              _val1522[_key1528] = _val1529
            iprot.readMapEnd()
            self.success[_key1521] = _val1522
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1536,viter1537 in list(self.success.items()):
        oprot.writeI64(kiter1536)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1537))
        for kiter1538,viter1539 in list(viter1537.items()):
          oprot.writeString(kiter1538)
          oprot.writeSetBegin(TType.STRUCT, len(viter1539))
          for iter1540 in viter1539:
            iter1540.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteriaTimestr_args:
  """
  Attributes:
   - keys
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1544, _size1541) = iprot.readListBegin()
          for _i1545 in range(_size1541):
            _elem1546 = iprot.readString()
            self.keys.append(_elem1546)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteriaTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1547 in self.keys:
        oprot.writeString(iter1547)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1549, _vtype1550, _size1548 ) = iprot.readMapBegin()
          for _i1552 in range(_size1548):
            _key1553 = iprot.readI64()
            _val1554 = {}
            (_ktype1556, _vtype1557, _size1555 ) = iprot.readMapBegin()
            for _i1559 in range(_size1555):
              _key1560 = iprot.readString()
              _val1561 = []
              (_etype1565, _size1562) = iprot.readSetBegin()
              for _i1566 in range(_size1562):
                _elem1567 = TObject()
                _elem1567.read(iprot)
                _val1561.append(_elem1567)
              iprot.readSetEnd()
              _val1554[_key1560] = _val1561
            iprot.readMapEnd()
            self.success[_key1553] = _val1554
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1568,viter1569 in list(self.success.items()):
        oprot.writeI64(kiter1568)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1569))
        for kiter1570,viter1571 in list(viter1569.items()):
          oprot.writeString(kiter1570)
          oprot.writeSetBegin(TType.STRUCT, len(viter1571))
          for iter1572 in viter1571:
            iter1572.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCclTime_args:
  """
  Attributes:
   - keys
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1576, _size1573) = iprot.readListBegin()
          for _i1577 in range(_size1573):
            _elem1578 = iprot.readString()
            self.keys.append(_elem1578)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCclTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1579 in self.keys:
        oprot.writeString(iter1579)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1581, _vtype1582, _size1580 ) = iprot.readMapBegin()
          for _i1584 in range(_size1580):
            _key1585 = iprot.readI64()
            _val1586 = {}
            (_ktype1588, _vtype1589, _size1587 ) = iprot.readMapBegin()
            for _i1591 in range(_size1587):
              _key1592 = iprot.readString()
              _val1593 = []
              (_etype1597, _size1594) = iprot.readSetBegin()
              for _i1598 in range(_size1594):
                _elem1599 = TObject()
                _elem1599.read(iprot)
                _val1593.append(_elem1599)
              iprot.readSetEnd()
              _val1586[_key1592] = _val1593
            iprot.readMapEnd()
            self.success[_key1585] = _val1586
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1600,viter1601 in list(self.success.items()):
        oprot.writeI64(kiter1600)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1601))
        for kiter1602,viter1603 in list(viter1601.items()):
          oprot.writeString(kiter1602)
          oprot.writeSetBegin(TType.STRUCT, len(viter1603))
          for iter1604 in viter1603:
            iter1604.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCclTimestr_args:
  """
  Attributes:
   - keys
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1608, _size1605) = iprot.readListBegin()
          for _i1609 in range(_size1605):
            _elem1610 = iprot.readString()
            self.keys.append(_elem1610)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCclTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1611 in self.keys:
        oprot.writeString(iter1611)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1613, _vtype1614, _size1612 ) = iprot.readMapBegin()
          for _i1616 in range(_size1612):
            _key1617 = iprot.readI64()
            _val1618 = {}
            (_ktype1620, _vtype1621, _size1619 ) = iprot.readMapBegin()
            for _i1623 in range(_size1619):
              _key1624 = iprot.readString()
              _val1625 = []
              (_etype1629, _size1626) = iprot.readSetBegin()
              for _i1630 in range(_size1626):
                _elem1631 = TObject()
                _elem1631.read(iprot)
                _val1625.append(_elem1631)
              iprot.readSetEnd()
              _val1618[_key1624] = _val1625
            iprot.readMapEnd()
            self.success[_key1617] = _val1618
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1632,viter1633 in list(self.success.items()):
        oprot.writeI64(kiter1632)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1633))
        for kiter1634,viter1635 in list(viter1633.items()):
          oprot.writeString(kiter1634)
          oprot.writeSetBegin(TType.STRUCT, len(viter1635))
          for iter1636 in viter1635:
            iter1636.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordTime_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordTimestr_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecord_args:
  """
  Attributes:
   - keys
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, record=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1640, _size1637) = iprot.readListBegin()
          for _i1641 in range(_size1637):
            _elem1642 = iprot.readString()
            self.keys.append(_elem1642)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecord_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1643 in self.keys:
        oprot.writeString(iter1643)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1645, _vtype1646, _size1644 ) = iprot.readMapBegin()
          for _i1648 in range(_size1644):
            _key1649 = iprot.readString()
            _val1650 = TObject()
            _val1650.read(iprot)
            self.success[_key1649] = _val1650
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter1651,viter1652 in list(self.success.items()):
        oprot.writeString(kiter1651)
        viter1652.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordTime_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1656, _size1653) = iprot.readListBegin()
          for _i1657 in range(_size1653):
            _elem1658 = iprot.readString()
            self.keys.append(_elem1658)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1659 in self.keys:
        oprot.writeString(iter1659)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1661, _vtype1662, _size1660 ) = iprot.readMapBegin()
          for _i1664 in range(_size1660):
            _key1665 = iprot.readString()
            _val1666 = TObject()
            _val1666.read(iprot)
            self.success[_key1665] = _val1666
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter1667,viter1668 in list(self.success.items()):
        oprot.writeString(kiter1667)
        viter1668.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordTimestr_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1672, _size1669) = iprot.readListBegin()
          for _i1673 in range(_size1669):
            _elem1674 = iprot.readString()
            self.keys.append(_elem1674)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1675 in self.keys:
        oprot.writeString(iter1675)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1677, _vtype1678, _size1676 ) = iprot.readMapBegin()
          for _i1680 in range(_size1676):
            _key1681 = iprot.readString()
            _val1682 = TObject()
            _val1682.read(iprot)
            self.success[_key1681] = _val1682
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter1683,viter1684 in list(self.success.items()):
        oprot.writeString(kiter1683)
        viter1684.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecords_args:
  """
  Attributes:
   - keys
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, records=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1688, _size1685) = iprot.readListBegin()
          for _i1689 in range(_size1685):
            _elem1690 = iprot.readString()
            self.keys.append(_elem1690)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1694, _size1691) = iprot.readListBegin()
          for _i1695 in range(_size1691):
            _elem1696 = iprot.readI64()
            self.records.append(_elem1696)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecords_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1697 in self.keys:
        oprot.writeString(iter1697)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1698 in self.records:
        oprot.writeI64(iter1698)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1700, _vtype1701, _size1699 ) = iprot.readMapBegin()
          for _i1703 in range(_size1699):
            _key1704 = iprot.readI64()
            _val1705 = {}
            (_ktype1707, _vtype1708, _size1706 ) = iprot.readMapBegin()
            for _i1710 in range(_size1706):
              _key1711 = iprot.readString()
              _val1712 = TObject()
              _val1712.read(iprot)
              _val1705[_key1711] = _val1712
            iprot.readMapEnd()
            self.success[_key1704] = _val1705
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1713,viter1714 in list(self.success.items()):
        oprot.writeI64(kiter1713)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1714))
        for kiter1715,viter1716 in list(viter1714.items()):
          oprot.writeString(kiter1715)
          viter1716.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecords_args:
  """
  Attributes:
   - key
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1720, _size1717) = iprot.readListBegin()
          for _i1721 in range(_size1717):
            _elem1722 = iprot.readI64()
            self.records.append(_elem1722)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1723 in self.records:
        oprot.writeI64(iter1723)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1725, _vtype1726, _size1724 ) = iprot.readMapBegin()
          for _i1728 in range(_size1724):
            _key1729 = iprot.readI64()
            _val1730 = TObject()
            _val1730.read(iprot)
            self.success[_key1729] = _val1730
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1731,viter1732 in list(self.success.items()):
        oprot.writeI64(kiter1731)
        viter1732.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordsTime_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1736, _size1733) = iprot.readListBegin()
          for _i1737 in range(_size1733):
            _elem1738 = iprot.readI64()
            self.records.append(_elem1738)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordsTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1739 in self.records:
        oprot.writeI64(iter1739)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1741, _vtype1742, _size1740 ) = iprot.readMapBegin()
          for _i1744 in range(_size1740):
            _key1745 = iprot.readI64()
            _val1746 = TObject()
            _val1746.read(iprot)
            self.success[_key1745] = _val1746
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1747,viter1748 in list(self.success.items()):
        oprot.writeI64(kiter1747)
        viter1748.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordsTimestr_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1752, _size1749) = iprot.readListBegin()
          for _i1753 in range(_size1749):
            _elem1754 = iprot.readI64()
            self.records.append(_elem1754)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordsTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1755 in self.records:
        oprot.writeI64(iter1755)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1757, _vtype1758, _size1756 ) = iprot.readMapBegin()
          for _i1760 in range(_size1756):
            _key1761 = iprot.readI64()
            _val1762 = TObject()
            _val1762.read(iprot)
            self.success[_key1761] = _val1762
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1763,viter1764 in list(self.success.items()):
        oprot.writeI64(kiter1763)
        viter1764.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordsTime_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1768, _size1765) = iprot.readListBegin()
          for _i1769 in range(_size1765):
            _elem1770 = iprot.readString()
            self.keys.append(_elem1770)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1774, _size1771) = iprot.readListBegin()
          for _i1775 in range(_size1771):
            _elem1776 = iprot.readI64()
            self.records.append(_elem1776)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordsTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1777 in self.keys:
        oprot.writeString(iter1777)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1778 in self.records:
        oprot.writeI64(iter1778)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1780, _vtype1781, _size1779 ) = iprot.readMapBegin()
          for _i1783 in range(_size1779):
            _key1784 = iprot.readI64()
            _val1785 = {}
            (_ktype1787, _vtype1788, _size1786 ) = iprot.readMapBegin()
            for _i1790 in range(_size1786):
              _key1791 = iprot.readString()
              _val1792 = TObject()
              _val1792.read(iprot)
              _val1785[_key1791] = _val1792
            iprot.readMapEnd()
            self.success[_key1784] = _val1785
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1793,viter1794 in list(self.success.items()):
        oprot.writeI64(kiter1793)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1794))
        for kiter1795,viter1796 in list(viter1794.items()):
          oprot.writeString(kiter1795)
          viter1796.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordsTimestr_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1800, _size1797) = iprot.readListBegin()
          for _i1801 in range(_size1797):
            _elem1802 = iprot.readString()
            self.keys.append(_elem1802)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1806, _size1803) = iprot.readListBegin()
          for _i1807 in range(_size1803):
            _elem1808 = iprot.readI64()
            self.records.append(_elem1808)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordsTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1809 in self.keys:
        oprot.writeString(iter1809)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1810 in self.records:
        oprot.writeI64(iter1810)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1812, _vtype1813, _size1811 ) = iprot.readMapBegin()
          for _i1815 in range(_size1811):
            _key1816 = iprot.readI64()
            _val1817 = {}
            (_ktype1819, _vtype1820, _size1818 ) = iprot.readMapBegin()
            for _i1822 in range(_size1818):
              _key1823 = iprot.readString()
              _val1824 = TObject()
              _val1824.read(iprot)
              _val1817[_key1823] = _val1824
            iprot.readMapEnd()
            self.success[_key1816] = _val1817
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1825,viter1826 in list(self.success.items()):
        oprot.writeI64(kiter1825)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1826))
        for kiter1827,viter1828 in list(viter1826.items()):
          oprot.writeString(kiter1827)
          viter1828.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteria_args:
  """
  Attributes:
   - key
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteria_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1830, _vtype1831, _size1829 ) = iprot.readMapBegin()
          for _i1833 in range(_size1829):
            _key1834 = iprot.readI64()
            _val1835 = TObject()
            _val1835.read(iprot)
            self.success[_key1834] = _val1835
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1836,viter1837 in list(self.success.items()):
        oprot.writeI64(kiter1836)
        viter1837.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteria_args:
  """
  Attributes:
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, criteria=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteria_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1839, _vtype1840, _size1838 ) = iprot.readMapBegin()
          for _i1842 in range(_size1838):
            _key1843 = iprot.readI64()
            _val1844 = {}
            (_ktype1846, _vtype1847, _size1845 ) = iprot.readMapBegin()
            for _i1849 in range(_size1845):
              _key1850 = iprot.readString()
              _val1851 = TObject()
              _val1851.read(iprot)
              _val1844[_key1850] = _val1851
            iprot.readMapEnd()
            self.success[_key1843] = _val1844
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1852,viter1853 in list(self.success.items()):
        oprot.writeI64(kiter1852)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1853))
        for kiter1854,viter1855 in list(viter1853.items()):
          oprot.writeString(kiter1854)
          viter1855.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCcl_args:
  """
  Attributes:
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, ccl=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCcl_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1857, _vtype1858, _size1856 ) = iprot.readMapBegin()
          for _i1860 in range(_size1856):
            _key1861 = iprot.readI64()
            _val1862 = {}
            (_ktype1864, _vtype1865, _size1863 ) = iprot.readMapBegin()
            for _i1867 in range(_size1863):
              _key1868 = iprot.readString()
              _val1869 = TObject()
              _val1869.read(iprot)
              _val1862[_key1868] = _val1869
            iprot.readMapEnd()
            self.success[_key1861] = _val1862
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1870,viter1871 in list(self.success.items()):
        oprot.writeI64(kiter1870)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1871))
        for kiter1872,viter1873 in list(viter1871.items()):
          oprot.writeString(kiter1872)
          viter1873.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteriaTime_args:
  """
  Attributes:
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteriaTime_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1875, _vtype1876, _size1874 ) = iprot.readMapBegin()
          for _i1878 in range(_size1874):
            _key1879 = iprot.readI64()
            _val1880 = {}
            (_ktype1882, _vtype1883, _size1881 ) = iprot.readMapBegin()
            for _i1885 in range(_size1881):
              _key1886 = iprot.readString()
              _val1887 = TObject()
              _val1887.read(iprot)
              _val1880[_key1886] = _val1887
            iprot.readMapEnd()
            self.success[_key1879] = _val1880
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1888,viter1889 in list(self.success.items()):
        oprot.writeI64(kiter1888)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1889))
        for kiter1890,viter1891 in list(viter1889.items()):
          oprot.writeString(kiter1890)
          viter1891.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteriaTimestr_args:
  """
  Attributes:
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteriaTimestr_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1893, _vtype1894, _size1892 ) = iprot.readMapBegin()
          for _i1896 in range(_size1892):
            _key1897 = iprot.readI64()
            _val1898 = {}
            (_ktype1900, _vtype1901, _size1899 ) = iprot.readMapBegin()
            for _i1903 in range(_size1899):
              _key1904 = iprot.readString()
              _val1905 = TObject()
              _val1905.read(iprot)
              _val1898[_key1904] = _val1905
            iprot.readMapEnd()
            self.success[_key1897] = _val1898
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1906,viter1907 in list(self.success.items()):
        oprot.writeI64(kiter1906)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1907))
        for kiter1908,viter1909 in list(viter1907.items()):
          oprot.writeString(kiter1908)
          viter1909.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCclTime_args:
  """
  Attributes:
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCclTime_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1911, _vtype1912, _size1910 ) = iprot.readMapBegin()
          for _i1914 in range(_size1910):
            _key1915 = iprot.readI64()
            _val1916 = {}
            (_ktype1918, _vtype1919, _size1917 ) = iprot.readMapBegin()
            for _i1921 in range(_size1917):
              _key1922 = iprot.readString()
              _val1923 = TObject()
              _val1923.read(iprot)
              _val1916[_key1922] = _val1923
            iprot.readMapEnd()
            self.success[_key1915] = _val1916
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1924,viter1925 in list(self.success.items()):
        oprot.writeI64(kiter1924)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1925))
        for kiter1926,viter1927 in list(viter1925.items()):
          oprot.writeString(kiter1926)
          viter1927.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCclTimestr_args:
  """
  Attributes:
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCclTimestr_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1929, _vtype1930, _size1928 ) = iprot.readMapBegin()
          for _i1932 in range(_size1928):
            _key1933 = iprot.readI64()
            _val1934 = {}
            (_ktype1936, _vtype1937, _size1935 ) = iprot.readMapBegin()
            for _i1939 in range(_size1935):
              _key1940 = iprot.readString()
              _val1941 = TObject()
              _val1941.read(iprot)
              _val1934[_key1940] = _val1941
            iprot.readMapEnd()
            self.success[_key1933] = _val1934
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1942,viter1943 in list(self.success.items()):
        oprot.writeI64(kiter1942)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1943))
        for kiter1944,viter1945 in list(viter1943.items()):
          oprot.writeString(kiter1944)
          viter1945.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCcl_args:
  """
  Attributes:
   - key
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCcl_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1947, _vtype1948, _size1946 ) = iprot.readMapBegin()
          for _i1950 in range(_size1946):
            _key1951 = iprot.readI64()
            _val1952 = TObject()
            _val1952.read(iprot)
            self.success[_key1951] = _val1952
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1953,viter1954 in list(self.success.items()):
        oprot.writeI64(kiter1953)
        viter1954.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteriaTime_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteriaTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1956, _vtype1957, _size1955 ) = iprot.readMapBegin()
          for _i1959 in range(_size1955):
            _key1960 = iprot.readI64()
            _val1961 = TObject()
            _val1961.read(iprot)
            self.success[_key1960] = _val1961
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1962,viter1963 in list(self.success.items()):
        oprot.writeI64(kiter1962)
        viter1963.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteriaTimestr_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteriaTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1965, _vtype1966, _size1964 ) = iprot.readMapBegin()
          for _i1968 in range(_size1964):
            _key1969 = iprot.readI64()
            _val1970 = TObject()
            _val1970.read(iprot)
            self.success[_key1969] = _val1970
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1971,viter1972 in list(self.success.items()):
        oprot.writeI64(kiter1971)
        viter1972.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCclTime_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCclTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1974, _vtype1975, _size1973 ) = iprot.readMapBegin()
          for _i1977 in range(_size1973):
            _key1978 = iprot.readI64()
            _val1979 = TObject()
            _val1979.read(iprot)
            self.success[_key1978] = _val1979
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1980,viter1981 in list(self.success.items()):
        oprot.writeI64(kiter1980)
        viter1981.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCclTimestr_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCclTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1983, _vtype1984, _size1982 ) = iprot.readMapBegin()
          for _i1986 in range(_size1982):
            _key1987 = iprot.readI64()
            _val1988 = TObject()
            _val1988.read(iprot)
            self.success[_key1987] = _val1988
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1989,viter1990 in list(self.success.items()):
        oprot.writeI64(kiter1989)
        viter1990.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteria_args:
  """
  Attributes:
   - keys
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1994, _size1991) = iprot.readListBegin()
          for _i1995 in range(_size1991):
            _elem1996 = iprot.readString()
            self.keys.append(_elem1996)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteria_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1997 in self.keys:
        oprot.writeString(iter1997)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1999, _vtype2000, _size1998 ) = iprot.readMapBegin()
          for _i2002 in range(_size1998):
            _key2003 = iprot.readI64()
            _val2004 = {}
            (_ktype2006, _vtype2007, _size2005 ) = iprot.readMapBegin()
            for _i2009 in range(_size2005):
              _key2010 = iprot.readString()
              _val2011 = TObject()
              _val2011.read(iprot)
              _val2004[_key2010] = _val2011
            iprot.readMapEnd()
            self.success[_key2003] = _val2004
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2012,viter2013 in list(self.success.items()):
        oprot.writeI64(kiter2012)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2013))
        for kiter2014,viter2015 in list(viter2013.items()):
          oprot.writeString(kiter2014)
          viter2015.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCcl_args:
  """
  Attributes:
   - keys
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2019, _size2016) = iprot.readListBegin()
          for _i2020 in range(_size2016):
            _elem2021 = iprot.readString()
            self.keys.append(_elem2021)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCcl_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2022 in self.keys:
        oprot.writeString(iter2022)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2024, _vtype2025, _size2023 ) = iprot.readMapBegin()
          for _i2027 in range(_size2023):
            _key2028 = iprot.readI64()
            _val2029 = {}
            (_ktype2031, _vtype2032, _size2030 ) = iprot.readMapBegin()
            for _i2034 in range(_size2030):
              _key2035 = iprot.readString()
              _val2036 = TObject()
              _val2036.read(iprot)
              _val2029[_key2035] = _val2036
            iprot.readMapEnd()
            self.success[_key2028] = _val2029
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2037,viter2038 in list(self.success.items()):
        oprot.writeI64(kiter2037)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2038))
        for kiter2039,viter2040 in list(viter2038.items()):
          oprot.writeString(kiter2039)
          viter2040.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteriaTime_args:
  """
  Attributes:
   - keys
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2044, _size2041) = iprot.readListBegin()
          for _i2045 in range(_size2041):
            _elem2046 = iprot.readString()
            self.keys.append(_elem2046)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteriaTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2047 in self.keys:
        oprot.writeString(iter2047)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2049, _vtype2050, _size2048 ) = iprot.readMapBegin()
          for _i2052 in range(_size2048):
            _key2053 = iprot.readI64()
            _val2054 = {}
            (_ktype2056, _vtype2057, _size2055 ) = iprot.readMapBegin()
            for _i2059 in range(_size2055):
              _key2060 = iprot.readString()
              _val2061 = TObject()
              _val2061.read(iprot)
              _val2054[_key2060] = _val2061
            iprot.readMapEnd()
            self.success[_key2053] = _val2054
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2062,viter2063 in list(self.success.items()):
        oprot.writeI64(kiter2062)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2063))
        for kiter2064,viter2065 in list(viter2063.items()):
          oprot.writeString(kiter2064)
          viter2065.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteriaTimestr_args:
  """
  Attributes:
   - keys
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2069, _size2066) = iprot.readListBegin()
          for _i2070 in range(_size2066):
            _elem2071 = iprot.readString()
            self.keys.append(_elem2071)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteriaTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2072 in self.keys:
        oprot.writeString(iter2072)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2074, _vtype2075, _size2073 ) = iprot.readMapBegin()
          for _i2077 in range(_size2073):
            _key2078 = iprot.readI64()
            _val2079 = {}
            (_ktype2081, _vtype2082, _size2080 ) = iprot.readMapBegin()
            for _i2084 in range(_size2080):
              _key2085 = iprot.readString()
              _val2086 = TObject()
              _val2086.read(iprot)
              _val2079[_key2085] = _val2086
            iprot.readMapEnd()
            self.success[_key2078] = _val2079
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2087,viter2088 in list(self.success.items()):
        oprot.writeI64(kiter2087)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2088))
        for kiter2089,viter2090 in list(viter2088.items()):
          oprot.writeString(kiter2089)
          viter2090.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCclTime_args:
  """
  Attributes:
   - keys
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2094, _size2091) = iprot.readListBegin()
          for _i2095 in range(_size2091):
            _elem2096 = iprot.readString()
            self.keys.append(_elem2096)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCclTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2097 in self.keys:
        oprot.writeString(iter2097)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2099, _vtype2100, _size2098 ) = iprot.readMapBegin()
          for _i2102 in range(_size2098):
            _key2103 = iprot.readI64()
            _val2104 = {}
            (_ktype2106, _vtype2107, _size2105 ) = iprot.readMapBegin()
            for _i2109 in range(_size2105):
              _key2110 = iprot.readString()
              _val2111 = TObject()
              _val2111.read(iprot)
              _val2104[_key2110] = _val2111
            iprot.readMapEnd()
            self.success[_key2103] = _val2104
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2112,viter2113 in list(self.success.items()):
        oprot.writeI64(kiter2112)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2113))
        for kiter2114,viter2115 in list(viter2113.items()):
          oprot.writeString(kiter2114)
          viter2115.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCclTimestr_args:
  """
  Attributes:
   - keys
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2119, _size2116) = iprot.readListBegin()
          for _i2120 in range(_size2116):
            _elem2121 = iprot.readString()
            self.keys.append(_elem2121)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCclTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2122 in self.keys:
        oprot.writeString(iter2122)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2124, _vtype2125, _size2123 ) = iprot.readMapBegin()
          for _i2127 in range(_size2123):
            _key2128 = iprot.readI64()
            _val2129 = {}
            (_ktype2131, _vtype2132, _size2130 ) = iprot.readMapBegin()
            for _i2134 in range(_size2130):
              _key2135 = iprot.readString()
              _val2136 = TObject()
              _val2136.read(iprot)
              _val2129[_key2135] = _val2136
            iprot.readMapEnd()
            self.success[_key2128] = _val2129
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2137,viter2138 in list(self.success.items()):
        oprot.writeI64(kiter2137)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2138))
        for kiter2139,viter2140 in list(viter2138.items()):
          oprot.writeString(kiter2139)
          viter2140.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecord_args:
  """
  Attributes:
   - key
   - value
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecordTime_args:
  """
  Attributes:
   - key
   - value
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.I64, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, value=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 4)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecordTimestr_args:
  """
  Attributes:
   - key
   - value
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRING, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, value=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 4)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecords_args:
  """
  Attributes:
   - records
   - identifier
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.BOOL, 'identifier', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, records=None, identifier=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.identifier = identifier
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype2144, _size2141) = iprot.readListBegin()
          for _i2145 in range(_size2141):
            _elem2146 = iprot.readI64()
            self.records.append(_elem2146)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.identifier = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecords_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2147 in self.records:
        oprot.writeI64(iter2147)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.identifier is not None:
      oprot.writeFieldBegin('identifier', TType.BOOL, 2)
      oprot.writeBool(self.identifier)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.identifier)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecordsTime_args:
  """
  Attributes:
   - records
   - timestamp
   - identifier
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.BOOL, 'identifier', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, records=None, timestamp=None, identifier=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.identifier = identifier
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype2151, _size2148) = iprot.readListBegin()
          for _i2152 in range(_size2148):
            _elem2153 = iprot.readI64()
            self.records.append(_elem2153)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.identifier = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecordsTime_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2154 in self.records:
        oprot.writeI64(iter2154)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.identifier is not None:
      oprot.writeFieldBegin('identifier', TType.BOOL, 3)
      oprot.writeBool(self.identifier)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.identifier)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecordsTimestr_args:
  """
  Attributes:
   - records
   - timestamp
   - identifier
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.BOOL, 'identifier', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, records=None, timestamp=None, identifier=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.identifier = identifier
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype2158, _size2155) = iprot.readListBegin()
          for _i2159 in range(_size2155):
            _elem2160 = iprot.readI64()
            self.records.append(_elem2160)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.identifier = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecordsTimestr_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2161 in self.records:
        oprot.writeI64(iter2161)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.identifier is not None:
      oprot.writeFieldBegin('identifier', TType.BOOL, 3)
      oprot.writeBool(self.identifier)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.identifier)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findCriteria_args:
  """
  Attributes:
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, criteria=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findCriteria_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2165, _size2162) = iprot.readSetBegin()
          for _i2166 in range(_size2162):
            _elem2167 = iprot.readI64()
            self.success.append(_elem2167)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2168 in self.success:
        oprot.writeI64(iter2168)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findCcl_args:
  """
  Attributes:
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, ccl=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findCcl_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2172, _size2169) = iprot.readSetBegin()
          for _i2173 in range(_size2169):
            _elem2174 = iprot.readI64()
            self.success.append(_elem2174)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2175 in self.success:
        oprot.writeI64(iter2175)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValues_args:
  """
  Attributes:
   - key
   - operator
   - values
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I32, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, operator=None, values=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.operator = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2179, _size2176) = iprot.readListBegin()
          for _i2180 in range(_size2176):
            _elem2181 = TObject()
            _elem2181.read(iprot)
            self.values.append(_elem2181)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValues_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.I32, 2)
      oprot.writeI32(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2182 in self.values:
        iter2182.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValues_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2186, _size2183) = iprot.readSetBegin()
          for _i2187 in range(_size2183):
            _elem2188 = iprot.readI64()
            self.success.append(_elem2188)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValues_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2189 in self.success:
        oprot.writeI64(iter2189)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValuesTime_args:
  """
  Attributes:
   - key
   - operator
   - values
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I32, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.I64, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, operator=None, values=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.operator = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2193, _size2190) = iprot.readListBegin()
          for _i2194 in range(_size2190):
            _elem2195 = TObject()
            _elem2195.read(iprot)
            self.values.append(_elem2195)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValuesTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.I32, 2)
      oprot.writeI32(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2196 in self.values:
        iter2196.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 4)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValuesTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2200, _size2197) = iprot.readSetBegin()
          for _i2201 in range(_size2197):
            _elem2202 = iprot.readI64()
            self.success.append(_elem2202)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValuesTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2203 in self.success:
        oprot.writeI64(iter2203)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValuesTimestr_args:
  """
  Attributes:
   - key
   - operator
   - values
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I32, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.STRING, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, operator=None, values=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.operator = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2207, _size2204) = iprot.readListBegin()
          for _i2208 in range(_size2204):
            _elem2209 = TObject()
            _elem2209.read(iprot)
            self.values.append(_elem2209)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValuesTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.I32, 2)
      oprot.writeI32(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2210 in self.values:
        iter2210.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 4)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValuesTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2214, _size2211) = iprot.readSetBegin()
          for _i2215 in range(_size2211):
            _elem2216 = iprot.readI64()
            self.success.append(_elem2216)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValuesTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2217 in self.success:
        oprot.writeI64(iter2217)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValues_args:
  """
  Attributes:
   - key
   - operator
   - values
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, operator=None, values=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.operator = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2221, _size2218) = iprot.readListBegin()
          for _i2222 in range(_size2218):
            _elem2223 = TObject()
            _elem2223.read(iprot)
            self.values.append(_elem2223)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValues_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.STRING, 2)
      oprot.writeString(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2224 in self.values:
        iter2224.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValues_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2228, _size2225) = iprot.readSetBegin()
          for _i2229 in range(_size2225):
            _elem2230 = iprot.readI64()
            self.success.append(_elem2230)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValues_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2231 in self.success:
        oprot.writeI64(iter2231)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValuesTime_args:
  """
  Attributes:
   - key
   - operator
   - values
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.I64, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, operator=None, values=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.operator = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2235, _size2232) = iprot.readListBegin()
          for _i2236 in range(_size2232):
            _elem2237 = TObject()
            _elem2237.read(iprot)
            self.values.append(_elem2237)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValuesTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.STRING, 2)
      oprot.writeString(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2238 in self.values:
        iter2238.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 4)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValuesTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2242, _size2239) = iprot.readSetBegin()
          for _i2243 in range(_size2239):
            _elem2244 = iprot.readI64()
            self.success.append(_elem2244)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValuesTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2245 in self.success:
        oprot.writeI64(iter2245)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValuesTimestr_args:
  """
  Attributes:
   - key
   - operator
   - values
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.STRING, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, operator=None, values=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.operator = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2249, _size2246) = iprot.readListBegin()
          for _i2250 in range(_size2246):
            _elem2251 = TObject()
            _elem2251.read(iprot)
            self.values.append(_elem2251)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValuesTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.STRING, 2)
      oprot.writeString(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2252 in self.values:
        iter2252.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 4)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValuesTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2256, _size2253) = iprot.readSetBegin()
          for _i2257 in range(_size2253):
            _elem2258 = iprot.readI64()
            self.success.append(_elem2258)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValuesTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2259 in self.success:
        oprot.writeI64(iter2259)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class search_args:
  """
  Attributes:
   - key
   - query
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'query', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, query=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.query = query
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.query = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('search_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.query is not None:
      oprot.writeFieldBegin('query', TType.STRING, 2)
      oprot.writeString(self.query)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.query)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class search_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2263, _size2260) = iprot.readSetBegin()
          for _i2264 in range(_size2260):
            _elem2265 = iprot.readI64()
            self.success.append(_elem2265)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('search_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2266 in self.success:
        oprot.writeI64(iter2266)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordsTime_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2270, _size2267) = iprot.readListBegin()
          for _i2271 in range(_size2267):
            _elem2272 = iprot.readString()
            self.keys.append(_elem2272)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2276, _size2273) = iprot.readListBegin()
          for _i2277 in range(_size2273):
            _elem2278 = iprot.readI64()
            self.records.append(_elem2278)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordsTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2279 in self.keys:
        oprot.writeString(iter2279)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2280 in self.records:
        oprot.writeI64(iter2280)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordsTime_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordsTime_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordsTimestr_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2284, _size2281) = iprot.readListBegin()
          for _i2285 in range(_size2281):
            _elem2286 = iprot.readString()
            self.keys.append(_elem2286)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2290, _size2287) = iprot.readListBegin()
          for _i2291 in range(_size2287):
            _elem2292 = iprot.readI64()
            self.records.append(_elem2292)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordsTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2293 in self.keys:
        oprot.writeString(iter2293)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2294 in self.records:
        oprot.writeI64(iter2294)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordsTimestr_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordsTimestr_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordTime_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2298, _size2295) = iprot.readListBegin()
          for _i2299 in range(_size2295):
            _elem2300 = iprot.readString()
            self.keys.append(_elem2300)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2301 in self.keys:
        oprot.writeString(iter2301)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordTime_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordTime_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordTimestr_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2305, _size2302) = iprot.readListBegin()
          for _i2306 in range(_size2302):
            _elem2307 = iprot.readString()
            self.keys.append(_elem2307)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2308 in self.keys:
        oprot.writeString(iter2308)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordTimestr_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordTimestr_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordsTime_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2312, _size2309) = iprot.readListBegin()
          for _i2313 in range(_size2309):
            _elem2314 = iprot.readI64()
            self.records.append(_elem2314)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordsTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2315 in self.records:
        oprot.writeI64(iter2315)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordsTime_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordsTime_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordsTimestr_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2319, _size2316) = iprot.readListBegin()
          for _i2320 in range(_size2316):
            _elem2321 = iprot.readI64()
            self.records.append(_elem2321)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordsTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2322 in self.records:
        oprot.writeI64(iter2322)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordsTimestr_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordsTimestr_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordTime_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordTime_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordTime_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordTimestr_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordTimestr_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordTimestr_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingRecords_args:
  """
  Attributes:
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, records=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype2326, _size2323) = iprot.readListBegin()
          for _i2327 in range(_size2323):
            _elem2328 = iprot.readI64()
            self.records.append(_elem2328)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingRecords_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2329 in self.records:
        oprot.writeI64(iter2329)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.BOOL,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2331, _vtype2332, _size2330 ) = iprot.readMapBegin()
          for _i2334 in range(_size2330):
            _key2335 = iprot.readI64()
            _val2336 = iprot.readBool()
            self.success[_key2335] = _val2336
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.BOOL, len(self.success))
      for kiter2337,viter2338 in list(self.success.items()):
        oprot.writeI64(kiter2337)
        oprot.writeBool(viter2338)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingRecord_args:
  """
  Attributes:
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, record=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyAndSwap_args:
  """
  Attributes:
   - key
   - expected
   - record
   - replacement
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'expected', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'replacement', (TObject, TObject.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, expected=None, record=None, replacement=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.expected = expected
    self.record = record
    self.replacement = replacement
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.expected = TObject()
          self.expected.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.replacement = TObject()
          self.replacement.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyAndSwap_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.expected is not None:
      oprot.writeFieldBegin('expected', TType.STRUCT, 2)
      self.expected.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.replacement is not None:
      oprot.writeFieldBegin('replacement', TType.STRUCT, 4)
      self.replacement.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.expected)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.replacement)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyAndSwap_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyAndSwap_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyOrSet_args:
  """
  Attributes:
   - key
   - value
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyOrSet_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyOrSet_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyOrSet_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrAddKeyValue_args:
  """
  Attributes:
   - key
   - value
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, value=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrAddKeyValue_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrAddKeyValue_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
   - ex4
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (DuplicateEntryException, DuplicateEntryException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ex4', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3
    self.ex4 = ex4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = DuplicateEntryException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ex4 = InvalidArgumentException()
          self.ex4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrAddKeyValue_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    if self.ex4 is not None:
      oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
      self.ex4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    value = (value * 31) ^ hash(self.ex4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrInsertCriteriaJson_args:
  """
  Attributes:
   - criteria
   - json
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRING, 'json', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, criteria=None, json=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.json = json
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.json = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrInsertCriteriaJson_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.json is not None:
      oprot.writeFieldBegin('json', TType.STRING, 2)
      oprot.writeString(self.json)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.json)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrInsertCriteriaJson_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (DuplicateEntryException, DuplicateEntryException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = DuplicateEntryException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrInsertCriteriaJson_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrInsertCclJson_args:
  """
  Attributes:
   - ccl
   - json
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRING, 'json', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, ccl=None, json=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.json = json
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.json = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrInsertCclJson_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.json is not None:
      oprot.writeFieldBegin('json', TType.STRING, 2)
      oprot.writeString(self.json)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.json)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrInsertCclJson_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
   - ex4
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ex4', (DuplicateEntryException, DuplicateEntryException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3
    self.ex4 = ex4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ex4 = DuplicateEntryException()
          self.ex4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrInsertCclJson_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    if self.ex4 is not None:
      oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
      self.ex4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    value = (value * 31) ^ hash(self.ex4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServerEnvironment_args:
  """
  Attributes:
   - creds
   - token
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'token', (TransactionToken, TransactionToken.thrift_spec), None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, creds=None, token=None, environment=None,):
    self.creds = creds
    self.token = token
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.token = TransactionToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServerEnvironment_args')
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 1)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 2)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServerEnvironment_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServerEnvironment_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServerVersion_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServerVersion_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServerVersion_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServerVersion_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time_args:
  """
  Attributes:
   - creds
   - token
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'token', (TransactionToken, TransactionToken.thrift_spec), None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, creds=None, token=None, environment=None,):
    self.creds = creds
    self.token = token
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.token = TransactionToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time_args')
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 1)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 2)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timePhrase_args:
  """
  Attributes:
   - phrase
   - creds
   - token
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'phrase', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'token', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, phrase=None, creds=None, token=None, environment=None,):
    self.phrase = phrase
    self.creds = creds
    self.token = token
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.phrase = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.token = TransactionToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timePhrase_args')
    if self.phrase is not None:
      oprot.writeFieldBegin('phrase', TType.STRING, 1)
      oprot.writeString(self.phrase)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 3)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.phrase)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timePhrase_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timePhrase_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
