#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ..shared.ttypes import *  # must use relative import or pdoc breaks
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TSymbolType:
  """
  A representation for an enum that declares the type of a TSymbol.
  """
  CONJUNCTION = 1
  KEY = 2
  VALUE = 3
  PARENTHESIS = 4
  OPERATOR = 5
  TIMESTAMP = 6

  _VALUES_TO_NAMES = {
    1: "CONJUNCTION",
    2: "KEY",
    3: "VALUE",
    4: "PARENTHESIS",
    5: "OPERATOR",
    6: "TIMESTAMP",
  }

  _NAMES_TO_VALUES = {
    "CONJUNCTION": 1,
    "KEY": 2,
    "VALUE": 3,
    "PARENTHESIS": 4,
    "OPERATOR": 5,
    "TIMESTAMP": 6,
  }


class TObject:
  """
  A lightweight wrapper for a typed Object that has been encoded
  as binary data.

  Attributes:
   - data
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'data', None, None, ), # 1
    (2, TType.I32, 'type', None,     7, ), # 2
  )

  def __init__(self, data=None, type=thrift_spec[2][4],):
    self.data = data
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TObject')
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 1)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.data is None:
      raise TProtocol.TProtocolException(message='Required field data is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.data)
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in list(self.__dict__.items())]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSymbol:
  """
  A representation for a Symbol that can be passed over the wire via
  Thrift. Once passed over the wire, the server uses information
  about the symbol type to parse the string representation of the
  symbol to an actual object.

  Attributes:
   - type
   - symbol
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRING, 'symbol', None, None, ), # 2
  )

  def __init__(self, type=None, symbol=None,):
    self.type = type
    self.symbol = symbol

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.symbol = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSymbol')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.symbol is not None:
      oprot.writeFieldBegin('symbol', TType.STRING, 2)
      oprot.writeString(self.symbol)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    if self.symbol is None:
      raise TProtocol.TProtocolException(message='Required field symbol is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.symbol)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in list(self.__dict__.items())]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCriteria:
  """
  A representation for a Criteria that can be passed over the wire via
  Thrift. Once passed over the write, the server goes through the list
  of TSymbols and converts them to actual Symbol objects which can then
  be used in the shunting-yard algorithm.

  Attributes:
   - symbols
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'symbols', (TType.STRUCT,(TSymbol, TSymbol.thrift_spec)), None, ), # 1
  )

  def __init__(self, symbols=None,):
    self.symbols = symbols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.symbols = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in range(_size0):
            _elem5 = TSymbol()
            _elem5.read(iprot)
            self.symbols.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCriteria')
    if self.symbols is not None:
      oprot.writeFieldBegin('symbols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.symbols))
      for iter6 in self.symbols:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.symbols is None:
      raise TProtocol.TProtocolException(message='Required field symbols is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.symbols)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in list(self.__dict__.items())]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
