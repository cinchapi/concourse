#!/usr/bin/env node

'use strict'

const _$endsWith = require('lodash/endsWith')
const _$startsWith = require('lodash/startsWith')
const astTypes = require('ast-types')
const fs = require('fs')
const path = require('path')
const recast = require('recast')
const yargs = require('yargs')

const processFile = (javascriptFilePath, javascriptSource) => {
  const javascriptSourceAst = recast.parse(javascriptSource)
  const javascriptSourceAstNodePath = new astTypes.NodePath(javascriptSourceAst.program)
  javascriptSourceAstNodePath
    .get('body')
    .each((path) => {
      if (astTypes.namedTypes.VariableDeclaration.check(path.node)) {
        path
          .get('declarations')
          .each((path) => {
            if (! astTypes.namedTypes.VariableDeclarator.check(path.node)) {
              return
            }
            const pathIdPath = path.get('id')
            if (! astTypes.namedTypes.Identifier.check(pathIdPath.node)) {
              return
            }
            if (pathIdPath.node.name === 'ConcourseServiceProcessor') {
              path.prune()
            } else if (_$startsWith(pathIdPath.node.name, 'ConcourseService_') &&
                       _$endsWith(pathIdPath.node.name, '_args')) {
              path
                .get('init', 'body', 'body')
                .each((path) => {
                  if (! astTypes.namedTypes.MethodDefinition.check(path.node)) {
                    return
                  }
                  const pathKeyPath = path.get('key')
                  if (! astTypes.namedTypes.Identifier.check(pathKeyPath.node)) {
                    return
                  }
                  if (pathKeyPath.node.name === 'read') {
                    path.prune()
                  }
                })
            } else if (_$startsWith(pathIdPath.node.name, 'ConcourseService_') &&
                       _$endsWith(pathIdPath.node.name, '_result')) {
              path
                .get('init', 'body', 'body')
                .each((path) => {
                  if (! astTypes.namedTypes.MethodDefinition.check(path.node)) {
                    return
                  }
                  const pathKeyPath = path.get('key')
                  if (! astTypes.namedTypes.Identifier.check(pathKeyPath.node)) {
                    return
                  }
                  if (pathKeyPath.node.name === 'write') {
                    path.prune()
                  }
                })
            }
          })
      }
    })
  const updatedJavascriptSource = recast
    .print(javascriptSourceAst)
    .code
  fs.writeFileSync(javascriptFilePath, updatedJavascriptSource, 'utf8')
}

const main = (argv) => {
  yargs
    .command({
      builder: (yargs) => {
        yargs
          .positional('javascript-file', {
            coerce: (filePath) => {
              return path.resolve(filePath)
            }
          })
          .version(false)
      },
      command: '$0 <javascript-file>',
      desc: 'Parses JavaScript code generated by Thrift and removes server code',
      handler: (argv) => {
        const { javascriptFile: javascriptFilePath } = argv
        const javascriptSource = fs.readFileSync(javascriptFilePath, 'utf8')
        processFile(javascriptFilePath, javascriptSource)
      }
    })
    .parse(argv)
}

const argv = process.argv.slice(2)
main(argv)
